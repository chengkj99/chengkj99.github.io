{"meta":{"title":"程是非sky","subtitle":"但行好事 莫问前程","description":"一边奔跑 一边思考","author":"程康健","url":"http://www.chengkangjian.com"},"pages":[{"title":"关于我","date":"2016-09-04T05:24:18.000Z","updated":"2019-06-18T12:28:47.000Z","comments":true,"path":"about/index.html","permalink":"http://www.chengkangjian.com/about/index.html","excerpt":"","text":"1234567&#123; &quot;Name&quot; : &quot;chengshifei&quot;, &quot;City&quot; : &quot;BeiJing&quot;, &quot;Profession&quot; : &quot;Web Developer&quot;, &quot;Email&quot; : &quot;chengkj99@foxmail.com&quot;, &quot;Description&quot; : &quot;Web 开发者，终身学习者，足球爱好者&quot;&#125; 必须让自己内心丰富 才能摆脱那些表面上的相似 …"},{"title":"归档","date":"2019-01-24T16:29:06.444Z","updated":"2017-02-14T10:12:09.000Z","comments":true,"path":"archive/index.html","permalink":"http://www.chengkangjian.com/archive/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-09-04T05:20:57.000Z","updated":"2017-02-05T07:24:26.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.chengkangjian.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-09-04T05:18:59.000Z","updated":"2017-02-05T07:24:26.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.chengkangjian.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习让我感觉我的人生才刚刚开始","slug":"learn-how-to-learn","date":"2019-09-01T08:01:08.000Z","updated":"2019-09-02T10:58:46.271Z","comments":true,"path":"2019/09/01/learn-how-to-learn/","link":"","permalink":"http://www.chengkangjian.com/2019/09/01/learn-how-to-learn/","excerpt":"","text":"醒悟不知道是哪一天，我突然发现，自己虽然学习了这么多年，我好像没有认真的思考过学习这件事情。一旦我想要学习的时候，于是就开始看起书，或看视频、或听书、或查阅网上资料、偶尔实践练习一下、有时做写写读书笔记、作些思维导图，这些大概就是我的学习方式吧。 以前，我总是关注学习的知识，关注我该去学些什么。但是我发现学习的越多，遗忘的也越多，虽然有些知识在我脑海里溅起过一朵朵浪花，多数情况\b是昙花一现，浪花和浪花之间并没有相互作用般地形成波浪。 上学时，老师教过我们「磨刀不误砍柴工」的道理，一直以为懂了，可是好像并没有真的学会，不然怎么会一直没有认真打磨过学习这把「刀」呢。我很庆幸的是现在意识到了这一点，于是我打算重新理解学习这件事，再去好好学习。 什么是学习从维基百科上得知，「学习」一词最早可追溯至孔子在《论语》中所言的：「学而时习之，不亦说乎？」。学习！学习！学习！重要的事情说三遍。这里「学」的意思是指获取知识和学问，「习」有温习、复习、练习的意思。 我意识到，在学校期间的学习——课前预习，课中学习，课后复习，这是一个完整的学习过程，是正确的。但在生活中，我们的大脑每天接收大量的信息或知识，这个过程感觉自己是在「学习」，其实不全是，因为这只是「学」的过程，并没有「习」。这也是产生「为什么听过很多道理，依然过不好这一生？」这个问题原因之一吧，因为我们懂了很多道理，却没有将道理在我们的生活中去运用，去真正的改变和影响我们的生活。 古代哲学家王阳明曾提出「知行合一」。在我看来，学属知习属行，只学不习等于白学，只习不学等于在黑暗中前行。 学是偏重理论方面，习偏重实践方面，从这个角度来看学习，也正好和马克思主义中的「理论与实践相互统一」的原则不谋而合。 为什么要学习就自己而言，学习的最主要的一个方式就是读书。我记得自己小时候并不喜欢学习，也不喜欢读书。开始读书是在大学的时候。那个时候自己会找一些感兴趣的书籍，比如《道德经心释》、《重新认识你自己》等书籍读着玩。那个时候我对读书的感觉是：「每当我读完一本书，我都会拥有获得新知的兴奋感」。 我的大学老师也会推荐书籍让我们去读，印象最深的是，我的大学老师-刘河伟老师，曾经推荐的两本书，一本是《人性的弱点》，这本书让我开始理解「人」这个字背后更多的内容。另一本是《穷爸爸富爸爸》，推荐这本书的时候我们正在上《互联网金融》专业课，我就去认真读了这本书，书中深入浅出的让我理解了什么是资产什么是负债等金融知识，也颠覆了我的财务观（虽然我之前并没有什么财务观），直到现在书中的财务理念还在影响着我。 后来准备要参加实习工作，为了找到一个产品相关的工作，我开始在大学的宿舍里自学产品知识，读了《人人都是产品经理》。读了这本书让我开始对产品经理的职业开始感兴趣，并影响我作出调整择业方向的决定，也帮助我离开桂林到北京找到了一份产品相关的实习工作。 实习工作期间，非常幸运的是我的职业导师也建议我多读书，为了更好的工作，要求我去读《见微知著-WEB用户体验解构》、《把时间当作朋友》等书籍。从《把时间当作朋友》中，我开始了解自我管理，时间管理，认知升级中的一些道理，知道了自己的渺小和无知。经过一年的实习，最后我的职业虽然不是 PM，而是一名 Web Developer，但是在成为 Web Developer 的路上，从外行到入门，最初仅仅是读了两本书，一本书《JavaScript高级程序设计》，另一本是《CSS权威指南》。可以说，读书令我受益匪浅，也是让我成长最快的学习方式之一。 为什么要学习？这个问题从我自身出发来看，我认为学习和读书可以让我变得更好。 我从一个不爱读书和学习的人到一个喜欢上阅读和学习的人，回顾人生的这段经历，读书和学习带给我有很多，一方面读书学习让我了解世界、了解自己。书籍是我的心灵导师，为我答疑解惑，帮助我成长。另一方面，帮助我在生活道路上和职业道路上走的更好。比如，我曾经是一个情绪容易失控的人，自从读了修身养性、心理学相关的书籍，我开始尝试关注自己的情绪，自己的情绪控制也越来越好。 在今天，在学习和读书这件事上，我还是有感到遗憾的，遗憾的是过去十几年的在校学习期间没有读更多的书，不然，现在的我可能是一个更好的自己。另一方面，我也感到庆幸，庆幸的是，我现在开始好好学习还为时不晚。毕竟人生路还长，说到这，我感觉自己的人生才刚刚开始。 如何学习为了学习如何学习，我到 coursera 寻找课程，果不其然的发现一门课程 Learning How to Learn ，在学习过程中得知，此门课程出自一本书叫 《学习之道》 ，于是我开始对此书进行研读，于是有了后面的内容。 后面的内容是我将《学习之道》这本书中的内容进行庖丁解牛式的梳理，将本书的重点内容结合自己的体验和见解，通过逻辑链拆解的方式再表达。当然了，如果你对学习这件事情有兴趣，还是推荐阅读原著。 1. 不要给大脑设限在开始学习如何学习之前，首先明确的是，我们的大脑是神奇而伟大的。 身边很多人包括我自己，都曾经怀疑过或自问过自己：我是不是不适合学英语？我是不是不适合学数学？我是不是不适合写代码？我是不是永远学不会游泳？我是不是永远学不会… 社会上有很多案例证明了「曾经的不可能」和「以为的不适合」只是自己在给自己设限。就自己而言，我曾经认为自己是写不了代码，搞不了技术，玩不了编程的人，所以我最初择业时选择做产品，后来事实证明，是我认为自己不可以，直到我遇到一个伯乐告诉我：「你可以！」，我真的就可以了。我也曾经认为我这辈子也学不会游泳，因为我曾经好多次尝试学习游泳都失败了，我甚至怀疑自己是一个四肢不协调的人，直到我遇到了优秀的同事，遇到了一个学习的时机，我就被教会了！ 由此可见，大脑会撒谎，不仅仅是对别人，也有对自己。现在我特别坚信，大脑拥有无穷的潜力。想想那些牛逼的科学家和发明家，他们代表的是当前人类潜能的「上限」，那些「上限」也在提醒我们，我们每一个人都还可以做的更好。 为了做更好的自己，我们要学会学习，因为学习是人类进步的阶梯啊。如果想更好的学习，需要让大脑更加完美的工作，因为，学习活动需要运用大脑的记忆、理解等功能。所以，学习如何学习的过程，也是一个学习如何使用大脑的过程，我们首先要做的是了解大脑的运作方式，学会更加科学合理的使用大脑。 2. 专注思维和发散思维第一个需要了解的是大脑有 两种工作模式：专注模式和发散模式。注意力高度集中的状态对应着专注模式；更加放松的休息状态对应着发散模式。 当我们在理解或记忆一个未知的概念时，需要用到专注模式。专注模式能够让注意力把大脑各个部分（更偏重左半部分的大脑）区域集中在一起搞事情。 简单说，就是专注模式能够「集中力量搞事情」。尤其是在学习数学和科学的学习过程中专注模式的思维活动必不可少，因为它是一种利用理性、连贯、分解的途径直接解决问题的一种模式。 但是专注模式不是万能的，我们常常会遇到过一种场景是，当面临一个问题待解决，我们在集中注意力的情况下有时候怎么也想不到问题的解决办法，使问题陷入僵局。这个就进入了专注模式的缺点——专注模式容易形成思维定式，思维定式会将思维局限于一种方法里，无法跳出来去寻求更加简单有效的解决途径。 这个时候需要做的事情是给注意力放个假，让大脑休息一下，再次回来，就会收到一份迎面跳出的解决方案作为惊喜。这也是另外一个思维模式在发挥作用——发散模式。 发散模式是休息状态下的思维模式，当我们在洗澡时，散步时，运动时，甚至是睡觉时，大脑的发散模式一直在工作。与专注模式不同的是，发散模式是跳跃式的思维活动，只要当大脑在专注模式下累了，放松一下，此时，发散模式就会趁虚而入，上蹦下跳。发散模式的作用就是让大脑的不同区域（更偏重右半部分的大脑）得到相互联络的机会，跳跃式的思维能反馈给我们宝贵的灵感，带给我们更多的新想法，这在解决问题时尤其管用。 可以想象一下我们经常遇到的这个场景，在之前的专注模式中埋头苦干，然后放松后的某个瞬间，来自发散模式的意外解法突然的醍醐灌顶，灵光突现。 为什么会有这两种思维模式？ 答案可能深藏于生物演化之中。 脊椎动物如果想要生存下去并繁衍后代，就要面对两个主要问题。比如用一只鸟来举例，一方面，它需要集中注意力才能从地面上啄取谷粒，获得食物；与此同时，它也必须警惕视野中是否有老鹰之类的天敌出现。 如何理解这两种思维模式呢？ 可以将专注模式和发散模式类比如聚光灯和散光灯。聚光灯时可以将光线照射的更远、更亮，但是照射的覆盖范围太小。散光灯时可以将光线照射的面积更大，但是不会比聚光灯模式下光线的亮和远。 两种思维模式都很重要，我们在学习中要做的事情是了解这两种工作模式，选择在不同的学习场景下，使用大脑对应的思维模式，并要训练自己能够做到随意切换。 3.工作记忆和长期记忆根据不同场景使用相应的思维模式可以让我们的大脑更有效率的工作。学习使用记忆模式也可以让大脑的工作更有效率。我们的大脑有两种记忆模式：工作记忆和长期记忆。 这两种记忆模式类似于计算机的内存（RAM）和硬盘两种存储空间。 在大脑中对正在处理的信息进行瞬时以及有意识加工的这部分记忆，叫作工作记忆。 现在的广泛共识是，我们的工作记忆能容纳大约四个记忆单元（组块）。也就是说，我们每个人大概能同时记着四件事情。人们需要对工作记忆中的组块不断回想或者说施加能量，不然新陈代谢很容易将工作记忆的组块吞噬掉，这就产生了遗忘。 那么该如何把工作记忆中的信息留住呢？ 一般来说，这需要不断地回想和重复，随着一定的时间回想和重复，大脑将信息从工作记忆转存到长期记忆。 长期记忆就像是一个大脑中的信息仓库。 知识一旦转化为长期记忆，就一直放那儿了。我们现在还可以背诵出儿时学习过的古诗，利用的就是长期记忆；长期记忆空间很大，可以存储十亿个知识组块。 长期记忆 = 工作记忆 + 间隔复习（重复练习） 4. 成为记忆大师记忆力并不是天才技能，每一个人都可以学习和提高。这就像社会上的「开锁师傅」并不是天生下来就会「开锁」一样。顺便透露一个秘密，开锁师傅之所以会开锁，是因为他们知道锁的构造原理和默认设置。提高记忆力也是如此，成为记忆大师不过是了解大脑的记忆规律，加上每个人的勤奋练习。下面将介绍一些有助于学习的默认设置。 回想当我们在背诵一篇文章时，经常用的方式是先反复的熟读再开始背诵。其实这是比较低效率的，更好的方式是利用回想。回想 就是试着回想学习材料，即提取练习。 通过回想学习材料的表现出记忆效果比单纯重复阅读材料好得多。我们通常不断重复阅读笔记或课本（撇开这种学习策略有限的优点不说），却很少有人在学习时进行自我测验或做提取练习。在学习中进行回想——让大脑提取关键概念，而非通过重复阅读被动地获取知识，将让我们更加集中高效地利用学习时间。 但是，不要学习后扔太久（最好24小时内）才进行回想，那样的话我们每次都要从头开始巩固概念。 能力错觉有时候，我们大脑的某些部分会让我们自我感觉良好，无论我们做了什么，无论错得多么离谱。我们常常会把看过以为理解了，背出以为掌握了，这就像是在看着答案做题，看起来都会。 以在书中做标记为例。当在学习材料上划重点和标下画线时，被画线的部分会被误以为是我们自己已经学习过的部分，其实那部分知识有可能只是被我们仅仅浏览过或阅读过，并没有被真正的被理解和掌握，所以要谨慎的标下划线和划重点，画线的动作会让我们欺骗自己大脑在工作，其实只是手在动而已。在作下划线等标记前，最好先训练自己找到主要观点，并把所做标记数量降到最少。 当大脑产生能力错觉时，大脑就陷入了低效率的学习方式。毕竟重复阅读比回想简单多了，在书上做标记、划重点比理解内容、提炼输出方便多了。除非我们只是想简单的了解，不然我们在学习时需要诚实的问问自己，是不是真的懂了。最简单的自我验证方式就是——表达或实践输出。 宫殿记忆记忆宫殿法需要我们回想一个熟悉的空间，比如自己家的布局，然后把它当成视觉形象的记事本，用来存储我们想要记住的概念形象。记忆宫殿法对记忆互无关联的物品很管用，比购物单上的物品（牛奶、面包、鸡蛋）。至于怎样使用这个技巧，我们可以想象家里的桌子上有一大瓶牛奶，面包掉在沙发上，破鸡蛋的蛋清从桌子边一滴滴流下来。 据说，宫殿记忆法是世界记忆大赛冠军训练时使用的方法。其核心原理是将枯燥的无规则的信息，转化为有趣的有色彩的熟悉的空间信息，转化后的信息有助于大脑理解和记忆。我自己也尝试使用这种记忆方法，记住了二十个无关联的名词清单，这个过程感觉很奇妙。如果你有兴趣，这里 记忆宫殿记忆法 有相关的内容可供学习参考。 类比和比喻类比和比喻可以提高大脑的理解力。在数学和科学的学习中，如果我们除了想记住概念，还想理解概念，一个上策就是为它量身打造一个比喻或类比。这个类比越形象，效果越好。比喻就是让一件事和另一件事之间显得大同小异。 比如：我们可以把电压类比成压力；将电流类比为水流；将电脑类比为人脑；将互联网比喻为蜘蛛网等。 所有的科学模型也不过是一种类比；类比（还有模型）之所以重要，是因为对数学和科学概念背后的核心观点而言，它能让我们获得直观形象的理解。 比如，科学家通过发明化学分子结构式帮助人们理解和记忆公式背后的核心概念。比喻和类比也能帮我们摆脱定式效应，让概念牢牢留在脑海中，之所以有这样的功能，是因为它能把新概念和已有的神经结构联系在一起。如果我们对一个概念的理解有难度，就应该尝试一下这个方法。 记忆力需要练习人类的大脑是大自然神奇的发明，我们之所以能够拥有思想和想象力，只因为我们拥有一个高级的大脑。大脑在关于记忆的方面有很多的默认设置，一些记忆方法（宫殿记忆、视觉记忆、回想记忆等）就是根据默认设置来发明的，了解这些默认设置，加以练习就是提高我们记忆力的关键。大脑和身体的其他部位一样的是——也需要经过科学的训练，才能够发挥其更大的潜能。 5. 构建知识组块有了前面的思维模式、记忆模式等基础概念，现在我们来了解一个新概念——组块。让我们的大脑拥有更强的记忆力和理解力是为搭建和固化组块而准备的，而搭建组块又有利于我们增强对知识的记忆和理解。基于此形成良性循环，学习能力就提高了。 组块一词听起来可能会有点陌生，在我看来，组块的过程就是我们平时经常做的将复杂、混乱的知识进行理解、梳理和总结的过程。 组块能够根据意义将信息碎片组成集合。 如果我们想记住 a、l、e、p、p 这些字母，我们可以将它们组合成一个有意义的单词 apple。知识组块利用意义，组合信息碎片形成一个新的概念，这样它只会占用记忆的一个部分空间。如上的例子，如果不创建组块，记忆 a、l、e、p、p 字母，需要使用多个大脑的记忆空间，构建知识组块 apple 之后，只需要创建一个记忆空间，这样很容易就记住了这组字母。 构建知识组块的目的就是为了更方便大脑对知识进行存储和取用。这是一种心智上的飞跃。 这就像是日常生活中的将物品进行分类、压缩、打包，更方便的进行物品的存储和取用是同一个道理。 如何构建知识组块？1.进行组块的第一步：启用专注模式，把注意力集中在需要组块的信息上。 开着娱乐节目当背景音，或者一会儿看手机，一会儿回信息，就别想构建组块了。在开始构建知识组块时。既要创造新的神经模型，也要把新模型和遍布大脑各处的既有模型联结在一起。这个过程需要在专注模式下进行，因为这是一个需要理解和记忆的过程。 2.组块活动的第二步：理解。要把基本概念打包成组块，首先要理解这个基本概念。 无论这个概念是力和质量的关系还是经济学的供求原则，只有理清头绪、把握概念，才能将知识块进行组合和打包。（这就好比日常生活中的打包之前，都需要梳理一下有哪些物品，了解物品的特点(这个过程就是理解)，有些物品还需要特殊处理，然后再根据各个物品的属性进行分类打包） 3.组块的第三步，是获取背景信息。 我们不仅要知道如何进行组块，还要知道如何使用它们。背景信息意味着跳出原始问题，用更宽广的视角看问题。在相关或不相关的问题上反复推敲、练习，使我们了解组块的用武之地，也能清楚它何时派不上用场。还能有助于我们在更大的宏观图景中定位新组块。另外，练习可以使连接到一起的组块不仅稳固，还能实现「条条大路通组块」，增加组块和组块之间的连接路径。 固化组块即使我们使用专注模式通过以上三个步骤构建了一个知识组块，但是目前这个知识组块还存在于工作记忆中，工作记忆中的组块会被大脑的新陈代谢活动吞噬掉，产生遗忘。如果我们想记住某个组块，如「工作记忆和长期记忆」所述，需要间隔复习将短期记忆转化为长期记忆——固化组块。 间隔重复与练习的背后就是大脑在创造固化组块，难点就在于它们会让人觉得枯燥乏味。 谁都知道，要掌握象棋、语言、音乐、舞蹈、计算机中的组块模型，绝非朝夕之功。任何值得去努力的事情，没有重复练习都是不行的。相同时间内，仅靠对材料的练习和回想，我们对学习的内容和学习深度都远远超过了其他方法，练习和重复的的真正美妙之处就在于：练得越多，知识就变得越简单，帮助就越大。 学习学习再学习 学习学习再学习——学习如何学习再去学习。 学习学习再学习，相当于磨刀不误砍柴工，只不过这个道理即使知道，也难免有很多人（包括自己），在很费时费力的砍了很多柴时才发现，自己的「砍刀」如此之钝。 我们在前面介绍了两种思维模式（专注模式和发散模式）、两种记忆模式（工作记忆和长期记忆），以及提高大脑记忆和理解力的一些方法，合理的使用它们，帮助我们构建知识组块并通过间隔重复和回想固化组块，此时的知识才能被掌握，如果再加以测试和练习，还能进一步提高学习效果。当然这些内容并不是「如何学习？」这个主题的全部，还有很多关于如何学习的知识等着去探索。学习以及学会学习都不是一撮而就的。在学习如何学习的道路上没有最好只有更好。 我很遗憾的是自己没有早一点去研究如何学习，我也很庆幸的是现在开始研究学习还不算晚。 虽然大学的时候，那时互联网教育特别火，我也经常的从教育网站上学习一些自己喜欢的课程，但是那时所用的学习方法都是来自老师的熏陶和教导，自己并没有对学习方法进行深度思考和总结。自从近期我开始重新思考「如何学习」和「如何阅读」这些事情，我突然感觉我的人生才刚刚开始。 我认为学习能力是人的一个底层能力，它能够决定着人生发展的天花板。很多颇具影响力的名人，像比尔盖茨、扎克伯格、乔布斯、达尔文都从大学辍学了，而这些人后来取得了的非凡的成就，这意味着他们就是那些能将传统和非传统学习的优点结合到自学中去的人。这说明大学不是学习的唯一途径，自学也可以精通一切。 就像上文如何学习第一小节说的那样：「不要给自己的大脑设限」，我们可以自学一切。 自学的意思在我看来，不是自己一个人学习，而是自主式学习，自己对自己的学习负责。 所谓自学一切，自学的「面向对象」不仅仅是书中的知识，还有身边的朋友和老师，向他们学习也是自学的一部分，毕竟学习的目标是获得知识，而获得知识是自己的事。 学习可以让我们「格物、致知、正心、诚意」，达至「修身」，进而才有「齐家、治国、平天下」的可能。《论语》中有讲：「吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。」，我们谈的最多的是「三十而立，四十而不惑…」，却往往忽视了孔子的第一句「吾十有五而志于学」。是什么原因让我发出「我的人生才刚刚开始！」如此感慨？大概是是因为我才刚刚开始「有志于学」吧！","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.chengkangjian.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"},{"name":"阅读","slug":"阅读","permalink":"http://www.chengkangjian.com/tags/阅读/"}]},{"title":"刷算法题的一点感悟","slug":"a-little-idea","date":"2019-07-09T03:25:32.000Z","updated":"2019-07-09T03:31:02.144Z","comments":true,"path":"2019/07/09/a-little-idea/","link":"","permalink":"http://www.chengkangjian.com/2019/07/09/a-little-idea/","excerpt":"","text":"最近两个月，我刷了50道左右的算法题，感觉自己的思维和解题能力都明显增强。 但是今天当我再回顾曾经自己做过的题，看着自己写的代码，作的注释，竟然发现有点陌生了，看着代码，就像是见到了熟悉的陌生人的感觉。 刷过的题，时间久了不回顾就会忘记。从学习方法的角度来说，我应该频繁的重复回顾才是好的学习方法。 看来大脑的记忆就像是身体的锻炼，内化吸收知识的过程，不是一撮而就的，需要间隔性的不断重复，刻意练习，产生类似于肌肉记忆的知识组块，形成长期记忆。 正好结合最近阅读《学习之道》带给我的感悟，学习是一门学问，如果想要更好的学习，就要先学习如何学习。 所以，我要重新刷一遍这套算法题，这次不用 JS 了，用 go 换个思维方式解题，来看看会产生什么样的效果吧!","categories":[{"name":"想法","slug":"想法","permalink":"http://www.chengkangjian.com/categories/想法/"}],"tags":[{"name":"想法 生活 技术","slug":"想法-生活-技术","permalink":"http://www.chengkangjian.com/tags/想法-生活-技术/"}]},{"title":"「算法」 有效的数独","slug":"algorithm-isValidSudu","date":"2019-07-05T03:06:17.000Z","updated":"2019-07-05T03:15:42.294Z","comments":true,"path":"2019/07/05/algorithm-isValidSudu/","link":"","permalink":"http://www.chengkangjian.com/2019/07/05/algorithm-isValidSudu/","excerpt":"","text":"有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例1234567891011121314示例 1:输入:[ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]输出: true 1234567891011121314示例 2:输入:[ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]输出: false 示例解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例 1 相同。但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 答题根据数独的3个条件，不能在行、列以及 3 * 3 宫内重复出现，于是考虑使用暴力法，先校验每一行是否存在重复，再校验每一列，最后校验九宫格。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; let num = 9 for (let i = 0; i &lt; num; i++) &#123; let hashRow = &#123;&#125; let hashCol = &#123;&#125; // 行 for (let j = 0; j &lt; num; j++) &#123; let curR = board[i][j] if (curR === '.') &#123; continue &#125; if (hashRow[curR]) &#123; return false &#125; else &#123; hashRow[curR] = true &#125; &#125; // 列 for (let j = 0; j &lt; num; j++) &#123; let curC = board[j][i] if (curC === '.') &#123; continue &#125; if (hashCol[curC]) &#123; return false &#125; else &#123; hashCol[curC] = true &#125; &#125; &#125; // 方阵 for (let i = 0; i &lt; num; i += 3) &#123; for (let j = 0; j &lt; num; j += 3) &#123; let hashMatrix = &#123;&#125; for (let a = i; a &lt; 3 + i; a++) &#123; for (let b = j; b &lt; 3 + j; b++) &#123; let curM = board[a][b] if (curM === '.') &#123; continue &#125; if (hashMatrix[curM]) &#123; return false &#125; else &#123; hashMatrix[curM] = true &#125; &#125; &#125; &#125; &#125; return true&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」翻转图象","slug":"algorithm-rorate","date":"2019-07-03T12:36:22.000Z","updated":"2019-07-03T12:41:07.000Z","comments":true,"path":"2019/07/03/algorithm-rorate/","link":"","permalink":"http://www.chengkangjian.com/2019/07/03/algorithm-rorate/","excerpt":"","text":"旋转图像给定一个 n × n 的二维矩阵表示一个图像。 旋转图像将图像顺时针旋转 90 度。 说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例示例 1:123456789101112// 给定:matrix = [ [1,2,3], [4,5,6], [7,8,9]],// 原地旋转输入矩阵，使其变为:matrix = [ [7,4,1], [8,5,2], [9,6,3]] 示例 2:1234567891011121314// 给定:matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],// 原地旋转输入矩阵，使其变为:matrix = [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解题思路是先转置矩阵，再每一行翻转可以实现将图像顺时针旋转 90 度。为什么先转置再翻转可以实现图像的 90 度反转呢？观察以上的两个示例，翻转 90 度就是将第一列变为了第一行，第二列变为了第二行，如果还记得矩阵变换的话，很容易想到，这和矩阵的转置很像。 123456789101112// 给定:matrix = [ [1,2,3], [4,5,6], [7,8,9]],// 转置: 行、列交换matrix = [ [1,4,7], [2,5,8], [3,6,9]] 矩阵旋转 90 度 和矩阵转置的操作都使原矩阵的行和列发生了交换，区别只是每一行元素的顺序是互逆的。 12345678910111213141516171819// 给定：matrix =[ [1,2,3], [4,5,6], =&gt; [7,8,9]],// 转置矩阵: 行列交换[ [1,4,7], [2,5,8], =&gt; [3,6,9]]// 行反转[ [7,4,1], [8,5,2], [9,6,3]] 1234567891011121314151617181920212223242526/** * @param &#123;number[][]&#125; matrix * @return &#123;void&#125; Do not return anything, modify matrix in-place instead. */// 转置加翻转var rotate = function(matrix) &#123; let len = matrix.length // 转置 transpose matrix for (let i = 0; i &lt; len; i++) &#123; for (let j = i; j &lt; len; j++) &#123; let temp = matrix[i][j] matrix[i][j] = matrix[j][i] matrix[j][i] = temp &#125; &#125; // 翻转每一行 reverse each row for (let i = 0; i &lt; len; i++) &#123; matrix[i].reverse() &#125; return matrix&#125;let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]console.log(rotate(arr)) // [ [ 7, 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3 ] ]","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」缺失的数字","slug":"algorithm-missingNumber","date":"2019-07-01T03:35:56.000Z","updated":"2019-07-01T03:40:34.669Z","comments":true,"path":"2019/07/01/algorithm-missingNumber/","link":"","permalink":"http://www.chengkangjian.com/2019/07/01/algorithm-missingNumber/","excerpt":"","text":"缺失数字给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例1234567示例 1:输入: [3,0,1]输出: 2示例 2:输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题解法 1: 循环和 hash先构造一个完整的数组，然后再一个一个去删除已有的元素，返回剩下的那个元素 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber1 = function(nums) &#123; let len = nums.length let n = len + 1 let tempNums = &#123;&#125; for (let i = 0; i &lt; n; i++) &#123; tempNums[i] = true &#125; for (let i = 0; i &lt; len; i++) &#123; let cur = nums[i] if (tempNums[cur]) &#123; delete tempNums[cur] &#125; &#125; return Object.keys(tempNums).toString()&#125;console.log(missingNumber2([9, 6, 4, 2, 3, 5, 7, 0, 1])) // 8 解法 2：异或分析：位的异或运算：相同得 0，不同得 1，6 ^ 6 === 0 异或操作符合交换律： 6 ^ 6 ^ 8 === 6 ^ 8 ^ 6 [0, n]的数列中，可以用n 个数和n 个数的下标进行异或运算，即可得出缺失的值： 123456下标 0 1 2 3 4数字 0 1 3 4 x(缺失的值)missing = 0 ^ 0 ^ 1 ^ 1 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 = 0 ^ 0 ^ 2 ^ 0 ^ 0 = 2 123456789101112/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber2 = function(nums) &#123; let missing = nums.length for (let i = 0; i &lt; nums.length; i++) &#123; missing ^= nums[i] ^ i &#125; return missing&#125;console.log(missingNumber2([9, 6, 4, 2, 3, 5, 7, 0, 1])) // 8","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"如何过上痛苦的生活","slug":"how-to-live-a-painful-life","date":"2019-06-29T09:50:18.000Z","updated":"2019-06-29T15:37:04.900Z","comments":true,"path":"2019/06/29/how-to-live-a-painful-life/","link":"","permalink":"http://www.chengkangjian.com/2019/06/29/how-to-live-a-painful-life/","excerpt":"","text":"如果知道我会死在哪里就好啦，那我将永远不去那个地方。 最近读《穷查理宝典》，查理十一讲的第一讲介绍了查理在哈佛学校的演讲内容。我也听过一些高校的毕业演讲，大多数的演讲者在毕业典礼上对毕业生分享的是是正能量的忠告或祝福。查理对哈佛毕业生分享却反其道而行之，告诉他们怎么过上痛苦的生活，傻子也明白不要过上痛苦的生活，所以这样的方式在我看来是非常有趣以及令人印象深刻。 其实我们多数人都在追求幸福的人生，希望过上幸福的生活，与幸福恰恰相反的是痛苦的人生。如果我们不知道如何过上幸福的生活，何不思考一下，如何避免过上痛苦的人生呢？查理就是这样做的，反过来想，总是反过来想。他在书中提到的每一点都让我陷入了沉思。 为了改变心情或者感觉而使用化学物质人们用化学物质刺激自己已经司空见惯了，抽烟、喝酒、吃药等。古人在诗中“借酒消愁愁更愁”已明确暗示了我们，酒精对人的危害。舆论曾经出现过，适度饮酒有利于健康的新闻，我也一度相信此类新闻一段时间。随着业界的深入研究，2018 年早些时候一篇发表于《柳叶刀》杂志的文章指出，酒精使用是导致死亡和残疾的主要风险因素，酒精根本就不存在所谓的“安全摄入量”，无论摄入量高低，饮酒对身体都是有害的。酒精增加道路事故和自我伤害的风险，以及增加对心血管疾病、癌症等疾病的患病风险。 我虽然不喜欢喝酒，也不理解由于一些烦心事用酒精麻醉自己的人。但是，为了过上痛苦的生活，是时候开始尝试一下了，迷茫的时候，不开心的时候，没有信心的时候就喝酒或者抽烟吧，它们虽然无助于解决任何问题，但是一定可以有助于你走进痛苦生活的世界。 妒忌妒忌，和令人上瘾的化学物质一样。是会给人带来痛苦的东西。每个人都会产生妒忌，区别是有的人会转念自己的妒忌心理，有的人则任由妒忌之心摆布自己，不加以控制，最终产生害人害己的后果。 嫉妒是基督教会的七宗罪之一。就像经文中所说的：“您不得觊觎你邻居的房子，你不得觊觎你邻居的妻子，或男，或女，或奴隶，或牛，或驴，或任何属于你邻居的东西”。 所以，为了过上痛苦的生活，请毫不犹豫的去妒忌身边的一切吧，很快妒忌的威力将会显现出来，它将摧毁我们每个人曾经的美好，让人从此过上痛苦的生活。 怨恨西方有一句谚语说：“当你怨恨一个人的时候，你就成为了他的奴隶”。换句话说，怨恨是希望别人死掉，却自己服了毒药。怨恨和妒忌一样都是会害人害己的。如果你觉得抽烟喝酒和妒忌心不够让自己痛苦，那就让自己怨恨起来吧，怨恨可以让人发怒、失控、粗暴…相信这可以加倍人们的痛苦生活。 要反复无常，不要虔诚地做你正在做的事这点对于一个喜欢不受信任，喜欢一事无成的人或许是很有帮助的…只要养成这个习惯，人们将会永远扮演《龟兔赛跑》寓言里那只兔子的角色，只不过跑的比兔子快的不是一只优秀的乌龟，而是一群又一群平庸的乌龟，甚至是拄着拐的平庸乌龟，如果想要过上痛苦的生活，就做这样的兔子吧，大概非常轻松的就实现了一事无成的一生。 不要参考他人成功或失败的教训尽可能从自身的经验获得知识，尽量别从其他人成功或失败的经验中广泛地吸取教训，不管他们是古人或是今人。这肯定能保证让我们过上痛苦的生活，取得二流的成就。 只要看看身边发生的事情，就能明白拒不借鉴别人的教训所造成的后果。人类常见的灾难全都毫无创意——酒后驾车导致的身亡，鲁莽驾驶引起的残疾，赌博造成的倾家荡产，吸毒带来的毁灭，加入毁形灭性的邪教的哪些聪明的大学生被洗脑后变成的行尸走肉，由于重蹈前人显而易见的覆辙而导致的生意失败，还有各种形式的集体疯狂等等。人们若要寻找那条通往没有创意的错误而引起的人生麻烦的道路，就会变成现代谚语所描述的那样：“人生就像悬挂式滑翔，起步没有成功就完蛋啦“。 当在人生战场上失败时，要从此意志消沉，一蹶不振当你们在人生的战场上遭遇第一、第二或者第三次严重的失败时，就请意志消沉，从此一蹶不振吧。 世界的样子，并不是我们从课本中学习到的样子，也不是她和他说的样子，每个人心中都有一个世界的样子，世界是一面镜子映射着每一个人的内心，反映着我们的言谈举止。当我们在表达愁苦的时候，此时的世界就是愁苦的；当我们在表达欢乐的时候，此时的世界充满了欢声笑语。这个世界充满了挑战、未知，也同样充满了美好。喜怒哀乐构成了我们生活的日常。 世界是复杂的，是千人千面的，虽然每个人的人生都不一样，但是没有人的人生是一帆风顺的。因为至少要经历上学读书就要经历学习成绩的波折，要经历爱情就要经历恋情的分分合合，要出门在外就会遇到坏人和好人，要开始谋生的时候就要开始经历赚钱的辛苦…如果你想要过上痛苦的生活，不要放过每一个面对困难的机会，每当困难来临时，不要畏惧，双手举起投降就好了，这条路走不通，总会有下一条走不通的路等着你，直到将要走投无路为止，痛苦生活也将来临了。 不要反过来想请忽略小时候人们告诉我的那个乡下人故事。曾经有个乡下人说：“要是知道我会死在哪里就好啦，那我将永远不去那个地方。 生活中的我们都习惯了按照正向的思维思考问题。如果想要过上痛苦的生活，就一根正向思维的筋想到底吧，千万别回头。 我们常常由于丢了钱包而郁闷，这个时候一定要郁闷到底，一旦反过来想，就会告诉自己：”我很庆幸我丢掉的不是我的性命“，这种想法只会让自己离痛苦生活越来越远。当我们想要找一份工作时，就毫无犹豫的出发吧，尽情感受四处碰壁带来的痛苦感受，不用考虑规划职业提高自己等着工作来找你。我们小时候都学习过《司马光砸缸》的故事，如果想过上痛苦的生活，千万不要向司马缸学习，怎么可能为了救人能把缸砸了呢，这样就会拥有如此愚蠢的经历了。 尽可能的减少客观性客观，简单说是一种事物原本真实的样子，它不因人的意志而改变，不受人的思想、感觉、工具、计算等主观手段的影响。与之相反的是主观，主观简单的说是指从人的或者某个单一角度看待事物。中学思修课本上说过——主观判断往往违反客观事实，是比较有道理的。因为从一个角度看问题看待事物，在多数情况下，是片面的，没有从多个角度上看问题和事物更加全面，所以客观相对来说更能还原事物的真实性。 尽可能的减少客观性，这样会帮助人们减少真理带来的的好处，会让人们永远活在自己的世界里，帮助人们增加犯错的机会，从而让人们过上痛苦的生活。只要减少客观，人们很容易成为生活中的键盘侠或传谣者，也会很容易成为童话故事《皇帝的新装》中人云亦云的看客。 最后最后我在想，关于如何过上幸福的生活这样的问题，是没有一个标准答案的。因为幸福的生活是千人千面的，幸福感和金钱无关，和名利无关。人的贪欲是无穷的，如果不懂得知足和珍惜现在，永远不会知道幸福在哪里。就像是小酒馆里拎着酒壶打酒的老大爷，对于他来说喝着几块钱一斤的小酒不一定不比在高级酒店里喝着茅台的人们幸福。于是我想，我们可以不知道如何过上幸福的生活，只要我们知道如何可以避免过上痛苦的生活，然后每天学习精进自己，每天进步一点点，慢慢的，生活应该会通向自己想要的那条幸福大道吧，如同一首儿歌写的那样：”一步又一步，才能到多佛“。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"},{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://www.chengkangjian.com/tags/感悟/"}]},{"title":"「算法」杨辉三角","slug":"algorithm-generate","date":"2019-06-28T03:33:55.000Z","updated":"2019-06-28T03:42:37.000Z","comments":true,"path":"2019/06/28/algorithm-generate/","link":"","permalink":"http://www.chengkangjian.com/2019/06/28/algorithm-generate/","excerpt":"","text":"杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:12输入: 5输出: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] 解题题目看起来比较简单，思路如下： 需要使用一个嵌套循环。 一层行数的循环 一层根据行数得出的每一行的数组长度大小的循环，用来得到每一行的数组 然后分析得出一下规律，当每一行的第一个和最后一个元素时，值为 1；每一行的中间的位置等于上一行上一个索引对应的值 + 上一行当前索引对应的值；如下：123456第 1 行: [1]第 2 行: [1, 1]第 3 行: [1, 2, 3]...第 row-1 行: dp[row-1] = dp[row-2][i-1][i] (row &gt;= 2, row = 0)第 row 行: dp[row] = dp[row-1][i-1][i] (row &gt;= 2, row = 0) 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number&#125; numRows * @return &#123;number[][]&#125; */var generate = function(numRows) &#123; const res = [] for (let row = 0; row &lt; numRows; row++) &#123; const rowRes = [] for (let i = 0; i &lt;= row; i++) &#123; if (row &lt; 2) &#123; rowRes.push(1) &#125; else &#123; let cur = 0 if (i === 0 || i === row) &#123; // 当每一行的第一个和最后一个元素时，值为 1 cur = 1 &#125; else &#123; const preRow = res[row - 1] // 根据发现的规律：中间的位置等于上一行元素的上一个索引对应的值 + 当前索引对应的值 let x = preRow[i - 1] let y = preRow[i] cur = x + y &#125; rowRes.push(cur) &#125; &#125; res.push(rowRes) &#125; return res&#125;console.log(generate(5)) // [ [ 1 ], [ 1, 1 ], [ 1, 2, 1 ], [ 1, 3, 3, 1 ], [ 1, 4, 6, 4, 1 ] ]","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」颠倒二进制位","slug":"algorithm-reverseBits","date":"2019-06-27T06:03:09.000Z","updated":"2019-06-27T08:45:28.561Z","comments":true,"path":"2019/06/27/algorithm-reverseBits/","link":"","permalink":"http://www.chengkangjian.com/2019/06/27/algorithm-reverseBits/","excerpt":"","text":"颠倒二进制位颠倒给定的 32 位无符号整数的二进制位。 示例示例 1：1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2：1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示：请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题循环和二进制转换题目看起来比较简单，思路如下： 将十进制转二进制 二进制字符串转数组 反转数组 不足32位用 0 补足（因为在十进制转二进制时得到的二进制字符串是从最后一位为 1 开始的二进制数，前面的 0 默认被省略了，不足 32 位） 将二进制转十进制 1234567891011121314151617181920/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; - a positive integer */var reverseBits = function(n) &#123; let binaryArr = parseInt(n) .toString(2) .split('') .reverse() let rest = 32 - binaryArr.length while (rest &gt; 0) &#123; binaryArr.push('0') rest-- &#125; let binaryNum = binaryArr.join('') let targetNum = parseInt(binaryNum, 2) return targetNum&#125;console.log(reverseBits2(43261596)) // 964176192","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」计算汉明距离","slug":"algorithm-hammingDistance","date":"2019-06-25T02:19:52.000Z","updated":"2019-06-25T02:41:55.856Z","comments":true,"path":"2019/06/25/algorithm-hammingDistance/","link":"","permalink":"http://www.chengkangjian.com/2019/06/25/algorithm-hammingDistance/","excerpt":"","text":"汉明距离两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例:1234567输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 解题正好昨天刚刚复习了位的异或操作，当时还在想，这个操作能有什么用呢，没想到今天看到这个题突然就想到了用这个方法。 首先将两个数异或操作，根据异或操作同为 0 ，异为 1的特性，然后，计算 1 的个数即是汉明距离。 123456如:1 (0 0 0 1) &amp;4 (0 1 0 0)2 (0 1 0 1)// 异或结果中 1 的个数是 2 所以，汉明距离是2。 12345678910111213141516/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @return &#123;number&#125; */var hammingDistance = function(x, y) &#123; let z = x ^ y let count = 0 while (z != 0) &#123; count++ z &amp;= z - 1 &#125; return count&#125;console.log('hammingDistance', hammingDistance(1, 4)) // 2","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」计算汉明重量","slug":"algorithm-hammingWeight","date":"2019-06-25T02:19:37.000Z","updated":"2019-06-25T02:59:31.816Z","comments":true,"path":"2019/06/25/algorithm-hammingWeight/","link":"","permalink":"http://www.chengkangjian.com/2019/06/25/algorithm-hammingWeight/","excerpt":"","text":"位1的个数（汉明重量）编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例示例 1：12输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2：12输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3：12输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 提示：请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题解法1: 循环和类型转换首先想到的方法是，先将数值转化为二进制数值，再类型转换为数值，然后循环判断字符串中 ‘1’ 的个数。 也就是 整数 -&gt; 二进制数 -&gt; 1 的个数。12345678910111213141516/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; */function hammingWeight1(n) &#123; let count = 0 const binaryNum = parseInt(n, 10).toString(2) const s = String(binaryNum) for (let i = 0; i &lt; s.length; i++) &#123; if (s.charAt(i) === '1') &#123; count++ &#125; &#125; return count&#125; 解法2：循环和位移动第二种解法是利用了位与（&amp;）的运算，最大的数值是32位，遍历数字的 32 位，每一位 &amp; 运算，如果 != 0 说明是 1，否则向左移一位；123456// 如： 输入 8，8 的二进制是 10001000 &amp; 1 == 01000 &amp; 10 == 01000 &amp; 10 == 01000 &amp; 100 == 01000 &amp; 1000 == 1 123456789101112131415/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; */function hammingWeight2(n) &#123; let bits = 0 let mask = 1 for (let i = 0; i &lt; 32; i++) &#123; if ((n &amp; mask) != 0) &#123; bits++ &#125; mask &lt;&lt;= 1 &#125; return bits&#125; 解法3: 位操作将 n 和 n - 1 做与运算，会把最后一个 1 的位变成 0，当数字变成 0 的时候，我们就知道它没有 1 的位了; 12345678// 如：输入 8，8 的二进制是 1000// 8 &amp; 71000 &amp; 0111 === 0// 计算一次 count = 1// 如：输入 3，3 的二进制是 1011 &amp; 1010 &amp; 01 === 0// 计算两次 count = 2 12345678910111213141516/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; */function hammingWeight3(n) &#123; let count = 0 while(n != 0) &#123; count++ n = n &amp; (n-1) &#125; return count&#125;console.log(hammingWeight1(100)) 3console.log(hammingWeight2(100)) 3console.log(hammingWeight3(100)) 3","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」罗马数字转整数","slug":"algorithm-romanIntMap","date":"2019-06-21T03:00:22.000Z","updated":"2019-06-21T03:07:00.036Z","comments":true,"path":"2019/06/21/algorithm-romanIntMap/","link":"","permalink":"http://www.chengkangjian.com/2019/06/21/algorithm-romanIntMap/","excerpt":"","text":"罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:12输入: \"III\"输出: 3 示例 2:12输入: \"IV\"输出: 4 示例 3:12输入: \"IX\"输出: 9 示例 4:123输入: \"LVIII\"输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: \"MCMXCIV\"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题看到题的第一感觉感觉不是一个难题，只要读懂题的意思，梳理思路即可完成答题。 首先想到的是先做一个映射表对罗马数字和阿拉伯数字建立一个映射关系。根据常识，平时做加减法运算时是按照个、十、百…依次解析的。然后在正常的解析思路的基础上再考虑一些异常或者特殊情况即可。 简单说分为两步： 建立一个数字映射表 如果特殊的六种情况特殊处理，否则就正常解析 按照以上分析完成代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanIntMap = &#123; I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000&#125;var chars = Object.keys(romanIntMap).reduce((pre, cur) =&gt; (&#123; ...pre, [cur]: cur &#125;), &#123;&#125;)var romanToInt = function(s) &#123; if (!s) return 0 let value = 0 let len = s.length for (let i = len - 1; i &gt;= 0; i--) &#123; let curChar = s.charAt(i) // Special Resolve if ([chars.I, chars.X, chars.C].includes(curChar)) &#123; let preChar = s.charAt(i + 1) if ([chars.X, chars.V].includes(preChar) &amp;&amp; curChar === chars.I) &#123; value -= romanIntMap[curChar] continue &#125; if ([chars.L, chars.C].includes(preChar) &amp;&amp; curChar === chars.X) &#123; value -= romanIntMap[curChar] continue &#125; if ([chars.D, chars.M].includes(preChar) &amp;&amp; curChar === chars.C) &#123; value -= romanIntMap[curChar] continue &#125; &#125; value += romanIntMap[curChar] &#125; return value&#125;console.log(romanToInt('III')) // 3console.log(romanToInt('IV')) // 4console.log(romanToInt('IX')) // 9console.log(romanToInt('LVIII')) // 58console.log(romanToInt('MCMXCIV')) // 1994 但是这个思路完全是按照自己的想法，应该会有更加简单或者更有效率的思路，心情好的时候，再继续深究吧。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"「算法」判断一个数是 3 的幂次方","slug":"algorithm-isPowerOfThree","date":"2019-06-20T06:10:40.000Z","updated":"2019-06-20T06:15:59.733Z","comments":true,"path":"2019/06/20/algorithm-isPowerOfThree/","link":"","permalink":"http://www.chengkangjian.com/2019/06/20/algorithm-isPowerOfThree/","excerpt":"","text":"判断一个数是 3 的幂次方给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例123456789101112131415示例 1:输入: 27输出: true示例 2:输入: 0输出: false示例 3:输入: 9输出: true示例 4:输入: 45输出: false 进阶你能不使用循环或者递归来完成本题吗？ 解题因为进阶部分给予了提示，能不使用循环或递归完成本题吗，于是首先就先用这两种方法解题，再想其他的方法。 首先利用 while 循环，其每次的结果如果小于目标值，一直乘以 3，如果大于等于结果，结束循环，判断结果值是不是等于目前值，如果等于则这个数就是 3 的幂次方，否则就不是。 1234567891011/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfThree = function(n) &#123; let num = 1 while (num &lt; n) &#123; num = num * 3 &#125; return num === n&#125; 如果使用递归，首先要有一个递归的结束条件，另外需要每次递归的处理过程，然后就一直递归下去，得到递归结果。在本题中，初始条件是 3 的幂次方的待判定结果值，于是想到，每一次除以 3 作为处理过程，最终的结果是一个小于 3 的余数，这个余数如果等于 1，说明能被 3 整除，说明给的数是 3 的幂次方，这也是递归的结束条件。 123456789101112/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfThree = function(n) &#123; if (n &lt; 3) &#123; return n === 1 &#125; else &#123; n = n / 3 return isPowerOfThree2(n) &#125;&#125; 由于进阶中，要求是否可以不适用循环和递归，在借鉴了资料提到了对数的思路，不过这个思路的实现比想象中要困难，因为 JS 数值的精度问题。这里 getBaseLog(x, y) 方法得到的是 以 x 为底值，y 为真数的对数，如果对数是个整数，说明这个数是可以被 3 幂次方得到的。但是 Math.log(y) / Math.log(x) 的结果由于精度问题得到的是类似于 3.0000000000000000004 的整数，所以，不得不对 Math.log(y) / Math.log(x) 的结果值进行四舍五入取整， 并定义一个精度值的安全范围 accuracyValue 作为四舍五入后的整数值和处理前的值进行判断是否在安全的精度值范围内，如果 是 这个数就被认为是以 3 为底的真数。 1234567891011121314151617181920212223242526/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */// 利用对数 Math.log()// 如果以 3 为底的真数是一个整数，则这个真数是 3 的幂次方得到的。const numbersCloseEnoughToEqual = (n1, n2) =&gt; &#123; // 精度值的安全范围 const accuracyValue = 0.00000000001 return Math.abs(n1 - n2) &lt; accuracyValue&#125;const getBaseLog = (x, y) =&gt; &#123; let value = Math.log(y) / Math.log(x) let closeValue = Math.round(value) return numbersCloseEnoughToEqual(value, closeValue)&#125;var isPowerOfThree = function(n) &#123; const baseNumber = 3 return getBaseLog(baseNumber, n)&#125;console.log(isPowerOfThree(3)) // trueconsole.log(isPowerOfThree(9)) // trueconsole.log(isPowerOfThree(27)) // trueconsole.log(isPowerOfThree(81)) // trueconsole.log(isPowerOfThree(12)) // false","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chengkangjian.com/tags/算法/"}]},{"title":"人生中第一个乌龙球","slug":"oolong-ball","date":"2019-05-16T07:19:07.000Z","updated":"2019-06-18T12:20:51.854Z","comments":true,"path":"2019/05/16/oolong-ball/","link":"","permalink":"http://www.chengkangjian.com/2019/05/16/oolong-ball/","excerpt":"","text":"记得小学课本中有一段话说过: 第一次真好，第一次的感觉就是奇妙，生命中的第一次越多，生命越多姿多彩。这段话我背诵的很熟，以至于课文标题记不清了，这段还记忆深刻。 我的人生经历了很多第一次，比如: 第一次醉酒第一次坐飞机第一次写检讨书第一次穿越沙漠… 每一个第一次的背后，都是一个故事。有些第一次是美好的，有些第一次是令人遗憾的，经历过一个每一个第一次，都给我的心理历程图描绘了一笔。 今天，我又经历了一个第一次。万万没想到。 我在电视前看到过无数次球员或守门员进了乌龙球，每次看到他们失落的表情，作为旁观者，我更多的是无感和有一点点的同情，但是做不到真正的感同身受。今天是旷视参加的中关村缤纷足球运动会的关键战役，只有赢球才能出现。在这样关键的比赛中，因为自己的一个乌龙导致平局，我的心情五味杂陈。 我在赛前怎么也没想到会有乌龙。今天的乌龙产生于自己的头球，自己的头球本来就是不稳的，在那个门前右前方关键的位置应该用最有把握的方式解围，我不知道当时是怎么想的，虽然头球是合理的方式，只是没有注意到背后的大门。 然后，就是蓝瘦香菇了… 有时候人生的第一次就是这样的不经意间突然出现，究其原因，我想以后在重要的情景下，犯错成本很高的情况下，要用最稳妥的办法去解决问题，不要有侥幸心理，因为一旦犯错很有可能没有机会重新再来。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"}]},{"title":"关于写代码的那点思考","slug":"code-and-startup","date":"2019-04-28T07:40:16.000Z","updated":"2019-06-18T12:19:57.394Z","comments":true,"path":"2019/04/28/code-and-startup/","link":"","permalink":"http://www.chengkangjian.com/2019/04/28/code-and-startup/","excerpt":"","text":"创业和用代码实现一个产品的过程很像，在第一次实现一个功能或产品的时候，都是紧张的、兴奋的、心里没底的，但是遇到问题的时候总会去网上搜索，去询问…去想尽一切办法去实现。 当完成了三次功能实现后，就轻车熟路了，发现也不过如此了，这个时候就到了自己的舒适区，此时到了瓶颈期。 为了不断的成长，此时需要继续探索提高效率的方法，探索新技术、新方案改进生产方式，一方面提高生产效率，一方面提高生产品质，达到客户（合作伙伴，领导等）的满意，用表现获得回报。 随着编程经验和技术的增长，有能力的程序员，去造优质轮子，发明新技术、新方案去影响某一个行业的技术发展或技术更新，这种工程师是技术大神了，也相当于创业公司成为为平台级的公司了，类似于程序员发明一个前端的开发框架，或者创造一个腾讯这样的平台级公司。 如此反复，去进一步接受更大的挑战，去获得更大的回报…","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"}]},{"title":"git 常用命令","slug":"git","date":"2019-04-22T03:36:52.000Z","updated":"2019-07-31T07:35:20.086Z","comments":true,"path":"2019/04/22/git/","link":"","permalink":"http://www.chengkangjian.com/2019/04/22/git/","excerpt":"","text":"分支操作123456789101112131415git checkout -b new_branch # 基于当前分支创建分支git checkout -b new_branch commitId # 基于历史 commit 切分支git branch -a # 查看所有分支git branch -r # 查看远程分支git branch -vv # 查看本地分支所关联的远程分支git branch -m old_branch new_branch #修改分支名称git push origin :old_branch # 删除远程分支git push --delete origin branch_name # 删除远程分支git push --set-upstream origin new_branch # push 新分支到远程分支git push -u origin new_branch # push 新分支到远程分支 remote 操作1234git remote remove origin # 删除本地 remotegit remote rename origin upstream # 重命名 remotegit remote rename upstream origin # 修改 remote name 添加/关联远程仓库git remote add origin git@github.com:chengkj99/chengkj-blog.git 删除 git 缓存git rm -r --cached &quot;file name&quot; 打 tagtag 是特定 commit 一个指针，也就是每个 tag 对应一个特定的 commit，通过 tag 可以返回到项目的特定状态下，所以可以将 tag 看作是在大量 commit 中设定的书签。releases 是基于 tag 编译好的二进制文件。可以记录项目的发布历史。 1234567891011git tag tagName # 打 taggit tag -a tagName -m \"Release version tagName\" # 打 tag 用 -a 指定标签名，-m 指定说明文字：git push origin --tags # push tag 到远程git show tagName # 查看 tag 信息git tag -d tagName # 删除 taggit push origin --delete tag tagName # 删除远程 tag …待补充","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.chengkangjian.com/tags/git/"}]},{"title":"关于代码的那点思考","slug":"with-code","date":"2019-04-15T10:42:51.000Z","updated":"2019-06-18T12:23:04.000Z","comments":true,"path":"2019/04/15/with-code/","link":"","permalink":"http://www.chengkangjian.com/2019/04/15/with-code/","excerpt":"","text":"有一段时间认为，写代码是和机器打交道，写久了会忘记如何与人打交道。现在的想法有点改变了：你必须对你的代码实在，用心，这样代码才能够很好的运行，你也不用为改 bug 而烦恼，就像是对身边的人一样如此。","categories":[{"name":"想法","slug":"想法","permalink":"http://www.chengkangjian.com/categories/想法/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"}]},{"title":"观 2019 歌手有感","slug":"singer","date":"2019-04-13T14:31:20.000Z","updated":"2019-06-18T12:21:07.609Z","comments":true,"path":"2019/04/13/singer/","link":"","permalink":"http://www.chengkangjian.com/2019/04/13/singer/","excerpt":"","text":"看了 2019 季的 「歌手」，很感动。我最喜欢的是龚琳娜和刘欢的作品。龚琳娜的作品将传统的文化与流行融合，让人赏心悦目，龚琳娜真的是一个艺术家，每一个作品都令我感到震撼。另外一个是刘欢，刘欢的歌格局高，上档次，还能深入人心。尤其最后的一首「甄嬛」，颇有意义，虽然刘欢刚做完手术，听着他喘着粗气完成「甄嬛」这首作品，真是令人敬仰和尊重的艺术家，刘欢是用生命在唱歌。而且他带着姚贝娜的天堂的歌声在总决赛演出，让我感动到不由自主的潸然泪下。 姚贝娜是我非常喜欢的一个歌手，作为一个不会唱歌但是喜欢听歌的音乐爱好者，在听到姚贝娜离开这个世界的消息时宛如自己的亲人离开了自己一样，那个时候我还是上大学，在学校宿舍的床上，夜里听着姚贝娜的歌，默默的，边听边哭，我作为一个男生，我也不想哭，实在忍不住。就像当时我在网易的 lofter 表达的那样：天机算不尽，交织悲与欢，对她的离开很痛心。她的歌在我的网易云里，每次听的时候仿佛她依然活在这个世界上。她在患癌期间依然参加中国好声音，她的网易云的歌单里只有一首歌「你不能爱我」，大概她还有着未完成的梦想和憧憬着的爱情吧。 这些艺术家们激励着我要珍惜现在，好好生活。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://www.chengkangjian.com/tags/感悟/"}]},{"title":"使用 prettier 格式化统一代码风格","slug":"prettier","date":"2019-04-04T08:55:39.000Z","updated":"2019-06-18T12:21:00.243Z","comments":true,"path":"2019/04/04/prettier/","link":"","permalink":"http://www.chengkangjian.com/2019/04/04/prettier/","excerpt":"","text":"背景最近在参与的一个项目中，项目的代码质量是不规范的，分号时加时不加，空格这有那没有，括号这括那不括…我终于体会到了曾经身边的大佬们看我的代码是什么感觉了。 刚刚还看了老许的「许式伟的架构课」开篇词，老许将程序员类比成建筑师时，按照能力水平分，大概分为三类，搬砖师、工程师、架构师。搬砖师主要写能跑的程序，只要程序能跑起来，就万事大吉了。工程师会从多个维度关注代码的质量、关注代码的可阅读性、可扩展性、可维护性、可复用性…。因为世界是变化的，代码能跑起来是远远不够的，我们需要花时间去考虑如何去维护代码，增加新需求，适应最新的变化。这才是工程师-不断提升软件工程质量的程序员。 关于代码质量的提升，在我看来，最好的方式是认真的逐行 code review，因为我的代码提升就是在大牛的带领下，通过code review一天比一天好，我在心里一直感谢着曾经看过自己的代码，发现和提出自己代码问题的人。 一般情况下，发现问题，我们使用手工的方式修改和调整，后来有了 eslint、tslint 等工具帮助我们发现代码风格和质量问题，不过发现归发现，修改还是得亲自动手的，生命就这样一天一天在改 bug 中度过，直到出现了 prettier，就像是黎明遇到了黑夜，一切都变的简单起来，生活也顿时充满了希望。 什么是 prettierprettier 是一个代码格式化工具。它可以在不改变代码语义的情况下，美化代码，让你的代码清晰易读，风格统一。 为什么要用 prettier统一团队代码风格一个团队如果没有一个统一的代码风格，团队成员之间相互参与到对方的项目是非常不方便的，有时也会产生代码风格的讨论和争议，这是高成本的（关于代码风格的讨论和争吵是非常消耗时间的）。而且人们在写代码的时候是感性的，没有人愿意轻易接受别人的风格，也没有人喜欢频繁告诉身边的同事如何设计他们的代码，因为这往往是并没有对错的，只是风格没有统一，而使用 prettier 可以按照一定的格式，将团队的代码风格进行自动的格式化统一，这样很好的解决「你可以有你的原则，团队有团队的规则」的矛盾关系。 帮助新人这里的新人可以指团队新成员或者刚入门的初级开发者。如果一个团队新加入了一个成员，那么新成员的代码风格和现有团队的风格有很大的可能是不一样的，毕竟来自不同的工作背景。使用prettier 后，可以不用担心新成员的风格和现有团队风格到的格格不入，因为它能格式化你的代码符合现有的风格，无论你来自哪里，你到了这里，你就是我们的一份子，很好的帮助了新人快速融入团队。如果是一个刚入门的初级开发者加入团队，这个时候新人往往可能是不太清楚如何写出好的代码的，prettier 也能帮助新人避免一些错误，帮助他们更好的成长，写出让人容易阅读的代码。 提高效率提高效率，可以节约时间，节约时间就是珍惜生命，没想到这里，我就会想到著名的一段话：「人最宝贵的是生命，生命每人只有一次，人的一生应当这样度过：当他回忆往事的时候，他不会因为虚度年华而悔恨；也不会因为碌碌无为而羞愧，当他临死的时候，他能够说：我的整个生命和全部精力，都献给了世界上最壮丽的事业——为人类的解放而斗争。人应当赶紧的充分的生活，因为意外的疾病和悲惨的事故随时都可能结束他的生命。」为了让自己的一分一秒过的有价值，要将自己从繁琐的事务的脱离出来，去做一些自己能力范围内更有价值的事情。我相信，没有人愿意在写代码的时候，这里删个「括号」，那里加个「分号」，使用prettier，一键格式化，让生命更有价值。 简单易用可信赖简单易用意味着使用成本很低，意味着小投资，大回报。在项目中使用 prettier 不会影响项目的稳定性，也不会带来冲突或负面影响。目前为止，从 2017 年发布至今，已经有 31000+ 的 star，已经被 facebook、react、webpack、babel、yarn 等众多知名项目中采用。 如何使用如何使用 prettier，官方文档中介绍了很详细 prettier，因为大多数项目目前都会集成 Eslint，这里简单介绍下如何与 Eslint 集成使用 prettier。 1.Use ESLint to run Prettier 使用这种方式意味着用 ESLint 运行 Prettier，但是需要保证 ESLint 和 Prettier 的规则一致性，不然会导致规则冲突，比如：ESLint 的规则是 semicolon: true 而 Prettier 的规则是 semicolon: false 那么，此时无论分号是否添加，总会出现 [eslint] Insert;(prettier/prettie 或 [eslint] Extra semicolon. (semi) 提示修改。 123456789yarn add --dev prettier eslint-plugin-prettiereslintrc.json:&#123; &quot;plugins&quot;: [&quot;prettier&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot; &#125;&#125; 2.Turn off ESLint’s formatting rules使用这种方式，意味着，关闭了 ESLint 的规则，仅使用 Prettier 的配置，此时，ESLint 的配置就无效了。 123456yarn add --dev eslint-config-prettiereslintrc.json:&#123; &quot;extends&quot;: [&quot;prettier&quot;]&#125; 3.Use both同时开启 ESLint 和 Prettier，同时对代码进行美化。 123456yarn add --dev eslint-plugin-prettier eslint-config-prettiereslintrc.json:&#123; &quot;extends&quot;: [&quot;plugin:prettier/recommended&quot;]&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://www.chengkangjian.com/tags/FE/"}]},{"title":"「选择」你有你的计划，世界另有安排","slug":"about-select","date":"2019-03-26T12:35:21.000Z","updated":"2019-06-18T12:19:03.535Z","comments":true,"path":"2019/03/26/about-select/","link":"","permalink":"http://www.chengkangjian.com/2019/03/26/about-select/","excerpt":"","text":"关于选择 最近一段时间，面临的选择突然多了起来，关于工作机会的选择，关于股票买卖的选择，关于一个多年未联系的老朋友要不要去联系的选择…人生由选择构成，也可能终于选择。 所以，我也顺便回忆了下自己的人生选择。小的时候，我不懂什么叫选择，虽然不懂，也做了很多选择，我选择了和我兴致相投的同学做了朋友，选择了在喜欢的老师的课堂上认真听讲，选择了经常去游戏机厅打游戏，选择了和一个不喜欢的同学打一架，选择了一双喜欢的鞋，选择了一首爱听的歌…每一个在当时的选择都没有声音，却都在今天影响着我。我不懂什么叫选择，我根据着自己的潜意识做着选择，感谢过去，没有让自己选择过于糟的事情，以致于我现在还好。 父母是小时候选择的保护伞，当我选择了错误，会引导我改正，会承担起自己选择的后果。小时候多好啊，尽情的选择，只要选择不是太糟糕，而不用去承担什么，有爸爸妈妈保护着，甚至还有《未成年人保护法》保护着。 选择一个大学和专业 随着成长，18岁的那一年，我作出了自己当时人生中最重要的一个选择，没有经过家长的同意下，选择填报了「桂林理工大学」的「电子商务」专业。其实，「桂林理工大学」最好的专业是「给水排水」、「土木工程」等工程类专业，毕竟这些专业在「桂工」是比较成熟和优秀的，但是我还是选择了「电子商务」，我的选择没有什么根据，主要是直觉，可能是我对「商」这个字情有独钟吧，我对商业是比较感兴趣的，而且，电商这个东西感觉以后会有前景（之所以这么想，可能是由于在高中的那个时候在「淘宝」买过一件非常非常喜欢的 T-shirt，哈哈）。直觉是一个很神奇的东西，虽然不知道直觉是什么。如今看来，当初的选择不是很差，至少让我上了大学，让我有能力立足于社会，也符合了当初的预期。 选择一个城市 人生就是一场意料之外，除了桂林，我当然想过去很多城市上大学：青岛、济南、南京、上海…小时候我从来没想过来桂林，初中时从来没想过来桂林，高中时也没想过来桂林，直到我去了桂林，我发现我来了桂林。 人生就是一场突如其来，除了北京，我当然想过去很多城市去就业，上海、杭州、青岛、济南、苏州…小时候我从来没想过来北京，中学时从来没想过来北京，大学时也没想过来北京，直到我来了北京，我发现我来了北京。 选择一个职业 在大三那年的暑假，选择了暑假不回家过暑期，不是我不想家，我选择了留在学校准备着寻找实习工作，两个月的时间不长不短，过得不浪费不充实，自然而然的每天学习着 Java、SSH、数据库等技术的实践和应用，报名参加了阿里和 360 的 2016 应届生校招笔试，但是笔试完成后，我受到了人生中第一次小小的打击，笔试中的内容完全不在我的准备范围内，笔试中考查的是对数学、逻辑、coding 能力等基础知识技能的考查，很少涉及到编程实践和应用。当时，我再一次陷入了失望和迷茫之中，我本科学习的是电子商务，虽然涉及到了计算机科学技术相关知识，但是和理科生相比，我并不是很有优势，那段时间每天思考的是我未来到底能做什么，我能去什么样的企业，我能不能在社会立足…那段时间，经常和自己的远方上大学的好朋友在深夜 11 点打电话诉说着自己的迷茫和惆怅，然后白天仍然继续思考着未来的路在何方。 我在有道云笔记上写下着我未来可能从事着的职业，职业目录上有先被排除的设计、网络工程师等职业，也有待选择的产品、数据挖掘等职业，却没有我现在目前正在从事的职业，当时我是万万没想到的，生活就是这样的奇妙，你永远不知道，明天会发生什么，就像是股市，永远不知道明天是涨还是跌。现在还清晰的记得，当时去办公室和老师们请教问题，带我们「信息管理系统」课的侯治平老师，跟我说：“建议我选择做数据挖掘，未来有可能是成为数据科学家，千万不要做前端，前端的很工作，像修改界面样式等工作都是费事费时没有产出的。”，老师的话，我觉得很有道理，我心里默默的想，一定不要成为前端开发者，尽量做数据挖掘吧。尤其是听到「数据科学家」的称谓可是另作为学生的我很激动的，这也为我后来的第一份实习工作埋下了伏笔。 所有的想法都是一念之间，如不去沉淀，反复思考，转变为行动，最终都会随风而去，随时间流逝。有道云笔记中的诸多待选岗位不可能一一有机会去尝试和排除，后来无意中在互联网的世界里发现了「产品经理」的岗位，发现这真是一个很适合自己的岗位，比起程序员虽然可以实现一个产品，但是并不知道需要实现一个什么产品，而产品经理知道，产品经理就是产品的总负责人、把握着产品当下和未来。这听起来比程序员酷多了。于是我找了「人人都是产品经理」这本书进行了阅读，又学习了「Axure」软件可以绘制产品原型，结合自己的大学生活的思考和体会，觉得自己可以尝试这个职业。于是我将目前岗位从 「Java 软件开发」改为了「产品实习生」，再一次开始了我的求职之路。 投递简历的过程肯定是失败的多，我投递简历从杭州的岗位机会开始投，然后投上海，最后投北京，杭州和上海都有提供一两家实习机会，由于我还不能离开桂林前去面试，最终都放弃了。最后在北京投递的时候，因为当时的我可以离开桂林了，而且我还没去过北京，于是我将简历中的所在地的信息「桂林」更改为「北京」，没想到，这成为了一个转折点，简历通过率突然提高了，面试机会突然多了起来，\b于是我约了「亚信」、「优分期」、「爱鲜蜂」等四五个机会，定了火车票，定了青年旅馆、拉着行李箱，还有大学同学送给我的一个北京交通卡(很感慨)，决定独自一个人去了北京。 但是我桂林的朋友有着不让我去的诱惑，让我留下来，本着想去大一点的城市去学习和成长的原则，坚定了自己的选择。为了面试成功，我提前两天到了北京，住进了北宫门附近的青年旅社，并积极准备着自我介绍和简历中的内容。面试的那天，虽然面试时间是十点，地点是中关村软件园，因为是道路不熟悉，所以早晨五点就起来了，可能是上帝的眷顾，面试的过程很顺利。我最终我选择了亚信提供的产品实习机会，因为这个岗位是做数据相关的事情，有很多的未知等待着我去学习和探索。 在亚信呆了一年多，由产品实习生转变为了前端开发实习生，这是一个偶然，我从没想过要是做前端开发，但是还是主动去作出了这样的选择。现在想来，原因大概是：产品的工作有点虚，那段时间写产品文档，作竞品分析表现的都不是很好，而当时前端正好也缺人，萌生了转前端开发的念头。在决定要做产品的时候，我本来以为我这辈子也不可能做程序员了，世界就是这样的，经常和我们开玩笑。从此以后，我开始了前端开发的职业道路。 如何选择 自从2015年10月来北京至今，已经3年零5个月了，这三年里经历的最多的是换工作的选择，我并不是想频繁换工作，互联网的大环境就是这样，变化很快、流动性很高，无论是主动的还是被动的选择，每一个新工作的选择看在当时起来没什么，从未来的角度来看，每一次选择都至关重要。现在我面对每一次选择都很谨慎，因为人生只有一次，选择的机会成本很高。如果人生是一个棋盘，每一步选择就意味着走一步棋，一步不慎，会导致一步错、步步错的尴尬境地。无论怎样，我对曾经作出的选择都不后悔，当初的选择无论是从当时，还是从现在来看都不是很糟的选择，我不知道当初如果作出了另外一种选择会是什么样子，至少我现在是满意的，这就够了吧。 未来肯定还会遇到很多的选择，本着现有的经历和思考，我会根据以下的原则来作出原则： 首先，我会思考每一个选择后的结果。选择后的结果又可以分为两种：直接结果和间接结果。如果是两个工作机会，工作薪水的高低意味着选择的直接结果，工作本身带来的行业经验等意味着长远的间接结果。 其次，我会考虑每一个选择背后的风险，必须要把风险控制在可接受的范围内。如果说炒股或者抄币，我肯定不会拿出我的大部分积蓄去炒，因为风险太高。拿出 20% ~ 30% 的闲置资金是可以接受的，即使全部亏损。 另外，我会考虑选择的机会成本。如果我失去了一棵树，我将得到整个森林。选择伴侣和工作都是这样，选择了一个，意味着失去了其他的所有，除非放弃现在的那个。这个时候会有个问题，就是我怎么知道当下的计划是不是最好的，我怎么知道以后会不会有更好的机会。有个「三分之一法则」值得参考，就是无论什么样的选择，我在总数大概三分之一数量的机会上持观望，剩下的机会如果有比前面三分之一更好的机会立即决定。当然，这个法则有一定的适用场景。 然后，利用好理性选择和感性选择两把双刃剑。在对待事情的选择上，更多的是以理性为主作出决策，会判断每一种选择的结果概率，理性分析作出选择。在关于和人相关的决策上，会多考虑感性的因素，比如在和女朋友吵架认错这件事上，认为自己正确的一方不一定就不会认错。 最后，会尽可能的选择不敢做的美好的事情。在选择去做不敢做的事情上，意味着会突破自己的舒适区。就像是最近一期「歌手」录制中陈楚生在开始演唱「鱼」时提到：“陈绮贞在创作「鱼」这首歌时，是想送给很多在做选择的人，在她平时的日子里，她也想要去突破一些自己的极限，可是每次要去做这样的事情的时候，她又被现实给拉回来，但是其实没有一个选择是完全正确的，只有当你踏出那一步，他才有可能让你看到不一样的风景”。TED 上有一个视频：去做那些你害怕的事吧，这让你更强大！ 提到，我们害怕去做的、问的、说的，这些有可能正是我们需要的，换句话说就是：简单生活，痛苦选择；痛苦选择，简单生活；","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"},{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"},{"name":"选择","slug":"选择","permalink":"http://www.chengkangjian.com/tags/选择/"}]},{"title":"我好像知道了上帝是谁","slug":"what-is-god","date":"2018-11-11T02:40:42.000Z","updated":"2019-06-30T02:30:48.419Z","comments":true,"path":"2018/11/11/what-is-god/","link":"","permalink":"http://www.chengkangjian.com/2018/11/11/what-is-god/","excerpt":"","text":"小时候，听过一首歌，上帝是女孩，打开了我思考上帝之门… 作为十多岁男孩的我于是开始思考上帝是谁… 为什么现在我在过马路？为什么我在问自己这个问题？谁在控制着我？我又是谁？ 那时候我还小，肯定是不知道答案的，想着想着就忘了 后来我渐渐长大，有一天我无意看到了一篇文章 「上帝正在惩罚不读书的人」 「上帝」两个字再一次映入我的眼帘和脑海，上帝啊，你到底是谁… 后来我开始听「吴军老师的得到专栏」，他曾在专栏里说过，「上帝喜欢笨人」 又是上帝… 这么厉害的人不断在他们的言论中提及「上帝」，每次听到「上帝」这个词，我就会想「上帝是谁」这个问题 于是，突然，我仿佛思考到了上帝的样子… 动物世界中的上帝，就是动物世界的生存法则 — 弱肉强食 人类社会中的上帝，也就是人类社会的生存法则 — 人类的社会制度、法律、道德原则、经济周期等 上帝是看不见摸不着的，但是如果你做了上帝不允许的事情或者不喜欢的事情，上帝就会出来惩罚你 上帝和自然的关系，竟然和老子的「道法自然」异曲同工 上帝在我眼中，简单的说就是:「自然法则」","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"},{"name":"感悟","slug":"感悟","permalink":"http://www.chengkangjian.com/tags/感悟/"}]},{"title":"如何在残酷的世界中好好生活","slug":"How-to-live-in-a-cruel-world","date":"2018-03-07T15:00:02.000Z","updated":"2019-06-18T12:20:29.357Z","comments":true,"path":"2018/03/07/How-to-live-in-a-cruel-world/","link":"","permalink":"http://www.chengkangjian.com/2018/03/07/How-to-live-in-a-cruel-world/","excerpt":"","text":"最近的一年，我有意无意中知道了一些很多不好的事情，认识到世界，不是我想象的那样不好，而且这个世界的黑暗超过了我的想象。 每当我走在路上，发现了路边的被遗弃的、被虐待的共享单车，我就在想，为什么有的人就是想做坏事呢？对于破坏共享单车的这部分人，我联想到我小时候犯错误的情景，我记得老师问我：“为什么踢隔壁班教室的门”？我当时也认真的问了自己，然后回答：“不知道！”。是的，对于作恶的人，是真正意识不到自己的恶的，或者偶尔良心发现意识到自己的恶了，却又被心中的黑暗所蒙蔽。我想，如果一个人真正的意识到了自己的行为是恶的，自己的行为是不好的，他或许会改邪归正。 身在这样的一个互联网的时代，我认为人们都是在裸奔的。前段时间知道了互联网的世界里有“暗网”这回事，而且据说占据了整个互联网八九成（大概的参考统计，数据来自互联网）的比重，原来阳光下的互联网仅仅是冰山一角，有相当的一部分人在暗网底下做着 拐卖儿童、绑架谋杀、毒品交易、人体器官买卖等如此黑暗的事情。据说看了的人，三观会沦陷崩塌。我还没看，听说了这回事，三观已经开始崩塌了。原来，看起来这是一个美好和谐的世界，实则是和丑恶并存的世界，我该如何在这样的世界中好好生活。 首先想到的赚钱，没错的，金钱就是力量，钱多了，是自我保护的有力手段，所以要好好赚钱。钱有时候是一个武器，可以让每个人在社会的环境中一定程度的保护自己。但是很多时候，钱又是无力的。比如，面对着互联网嘈杂的信息和诱惑，如果进行防御和抵抗，这个时候就和钱没关系了，这个时候需要个人的价值观的导向帮助你去做正确的选择，来筛选有用的信息浏览和阅读。很多时候，世界的黑暗面是很强大的，每一个随时都有可能被黑暗吞噬。我们需要做的是，把时间浪费在美好的事情上。 互联网中充斥着真真假假、善善恶恶、是是非非的信息，改变能改变的吧，接纳不能改变的，努力辨别哪些是可以改变的哪些是不能改变的吧，然后过好自己的生活。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"}]},{"title":"聊聊也好","slug":"a-change-in-the-attitude-of-the-XiongAn","date":"2018-01-06T16:34:18.000Z","updated":"2019-06-18T12:17:30.939Z","comments":true,"path":"2018/01/07/a-change-in-the-attitude-of-the-XiongAn/","link":"","permalink":"http://www.chengkangjian.com/2018/01/07/a-change-in-the-attitude-of-the-XiongAn/","excerpt":"","text":"前些日子，听闻北京炒房团连夜赶车到雄安炒房的消息时，我的心里表现的是一脸的不屑和不解，那里有什么值得你们做出这么疯狂的决定，一个新区这么让人疯狂吗？时间过了大概一年了，现在我不再这么认为了，对于投资和赚钱而言，没有很疯狂只有更疯狂，如果对于赚钱都不着急，还有什么值得去着急。 今天和老同事旭哥和新元，时隔我从前东家离职一年多以来再次相聚，讨论了这个话题，老刘不愧是清华毕业生，思考问题的角度就是有深度。颠覆了我之前的一些认知。 对于雄安我没有归属感的认知。每次和周围的朋友或者亲戚谈论到买房，都会有意或无意的谈及和建议我到雄安买房，我之前认为我不会去那里，因为那里没有归属感，作为一个山东人，要去河北一个城市定居，这是我这辈子也没有想过的，倒是想过去杭州、苏州、南京等城市都有想过，由于没想过，所以对于身边人的这个雄安落地的建议，我甚至都不思考，直接用“不可能”回绝。其实现在想一想，无论我人在哪里，只要生活品质优越，有钱花，出门便捷，生活幸福不就是自己追求的吗? 我之所以选择杭州、苏州等城市不正是看上这些二线城市的生活环境相对来说既有大城市完善的基础设施带来的便捷，又没有那么多大城市病不是吗。如果雄安可以带来和苏州、杭州等城市一样的甚至更好的生活环境，选择雄安作为自己的归属地又何乐而不为呢。 对于企业发展的背后原因的认知。2017年发生的事情，美团进入网约车领域，如果用常人的思维思考，美团要跨界发展；如果再深入一点，美团以团购起家陆续有了团购、外卖、酒店、旅游、电影等领域、涵盖了吃喝玩乐的方方面面，从衣食住行的角度来看，美团已经进入了食住的领域，衣和行的领域是待进入的，所以现在进入出行领域并没有什么奇怪的。如果换个角度，从企业背后的资本方考虑，进入出行领域，无疑是想在网约车市场分一杯羹，这其实体现的是新势力对旧势力的挑战，这背后代表的是两股力量。 最近在思考投资的事情，再次买了一些基金，其实我对基金的背后的样子是一无所知的，老刘提出的观点再一次颠覆我的认知，“基金存在的原因是对国家队资金动向的一个遮罩层” ，国家队的资金难道是在诸多的基金公司里吗？我不清楚，但不重要，这个观点已足以让我惊讶。 我更深入的理解了洗钱的含义，把钱洗一遍就是洗钱，这个“洗”字，就是把黑钱变成了白钱，把不合法变为了合法。有很多没想到的套路，比如：自己开个游戏公司，通过将黑钱用来买游戏装备，游戏公司赚来的收益就是合法的收益，这个过程就将黑钱洗白，完成一个洗钱的过程。洗钱的手段有很多，网购、比特币等，所以网络实名制的政策不排除有反洗钱的原因吧。 本次交流，让我更加坚信的认为线下的交流很有意义，应用通信的发展，一方面确实给我们带来了极大的便捷，但是也带来了新的问题。微信等应用软件看似让人与人的沟通不受时间和空间的限制，方便人们的交流，这在本来是好事，应该会拉近人的距离才是，但是结果是相反的，不仅没有拉近人的距离，反而让人与人之间变得更疏远。 没有微信的时代，人与人相隔五年没联系再次联系可能会两眼泪汪汪，感情如初不说，甚至情谊更加深厚，这个时候感情不会随着时间而改变，是恒定的。而有微信的时代，如果好朋友五年不联系，再次联系，导致的结果是两个熟悉的陌生人，这个时候感情会随着时间逐渐变淡，是下降的。究其原因，没有微信的不联系是无法联系是被动的不联系，朋友之间时而还会挂念对方也会想对方在挂念着自己，再次联系的时候是自然的，没有隔阂的。而有微信的不联系是能联系而不联系是主动的不联系，朋友之间可能也会时而想念对方但是如果不联系会让对方误认为对方或许已经将自己遗忘，再次联系的时候的感觉，是不自然的，是有心理隔阂的。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"}]},{"title":"我的无知","slug":"unknow","date":"2017-12-14T13:53:19.000Z","updated":"2019-06-30T02:32:14.362Z","comments":true,"path":"2017/12/14/unknow/","link":"","permalink":"http://www.chengkangjian.com/2017/12/14/unknow/","excerpt":"","text":"最近听了老师的传播学课，让我对传播二字有了新的认识。在这之前，我所理解的传播应该是知识的传播，文化的传播等这些事物传播组成的词语，或者是传达、播报等对传播的字面意思的肤浅理解。 即使上完了这门课，我现在依然是不懂传播，但是我知道了，传播不再是我之前所理解的传播了。 现在我所知道的传播，比如传播的范围，小到人与人之间的传播，中到组织传播，比如高校，企业，社会团体等组织之间的传播，再大一点到大众传播，每个领域内的传播都有区别和联系。 后来我总结，其实人与人之间的传播不也是人际沟通和推广的学问嘛，不也是有营销的学问嘛，不还是心理学，行为学的学问嘛，人与人之间传播的学问，不简单。组织间的传播学问，也包含着领导力，组织管理，项目管理，企业文化建设等学问。大众传播范围就更大了，社会行为学，社会心理学等学问也都属于大众传播的范畴。 想到这里，我感受到了知识的博大精深，令我望而生畏。 我再也不敢说我懂了什么，我发现我对我以及我周围的一切一无所知。 我懂自己了吗，此时此刻我好像知道自己在做什么，也好像知道自己的行为的目的，但知道的又不是那么的准确。 我懂世界了吗？世界那么大，我肯定不懂。我只是通过我的感知了解和体会了一个世界在自己内心的镜像，是一个经过了我自己加工过的片面的世界，这不是一个真正的世界。 联想到自己穿的衣服，做的椅子，桌子及桌子上碳素笔，笔记本，显示器，掉落的头发丝，还有那瓶子里蒲公英茶… 我身边的一切的一切我都不懂。 每一样事物都是熟悉的，又是陌生的，我想努力去了解，却变得愈来愈熟悉，愈来愈陌生…","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"}]},{"title":"CDN 集群服务和负载均衡技术","slug":"CDN-four-chapter","date":"2017-09-12T12:11:20.000Z","updated":"2019-06-18T12:54:57.883Z","comments":true,"path":"2017/09/12/CDN-four-chapter/","link":"","permalink":"http://www.chengkangjian.com/2017/09/12/CDN-four-chapter/","excerpt":"","text":"当一台Cache设备无法满足服务的响应要求时，就需要考虑通过一组服务器形成Cache集群进行服务。 服务器集群技术 服务器集群优势：提高性能、降低成本、提高可扩展性、增强可用性 集群分类：计算集群、负载均衡集群（任务处理负载，I/O流量负载）、高可用集群。 CDN的节点系统是一种典型的负载均衡系统。 集群的系统结构：网络层、节点服务器操作系统层、应用层、集群管理系统层。 Cache 集群协同交互法 协同的目标：在各个服务器节点间建立良好的通信通道，及时沟通服务器的缓存情况，为用户提供良好的用户体验。 通信协议：松散耦合（ICP、HTCP、Digest、Cache Pre-filling）、紧密耦合（CARP）两类。 ICP：基于UDP协议实现，应答不包含HTTP头信息，通过向邻居发出请求并获得应答来反应Web对象在集群中的缓存情况。 HTCP：它能够管理一组HTTP Cache服务器并监控相关的缓存活动，应答包含HTTP头信息，数据和认证。 Cache Diest： 它的出现主要为了解决ICP 和 HTCP 协议在使用时的网络延迟和拥塞问题，不采用请求响应模式，而是在服务器之间建立对等关系，是一种用空间交换时间的思路。 Cache Pre-filling： 是一种推送Cache内容的机制，优点是可以向多个接收器传输大容量的数据，缺乏统一的标准。 CARP：一个分布式的缓存协议。 负载均衡技术实现 按照负载均衡策略分发； 两种角色：任务负担、协同计算； 以前负载均衡主要在OSI七层模型的第四层展开； 现在，基于第七层的负载均衡技术逐渐称为主流； 关键技术 负载均衡调度算法轮询、加权轮询、随机、加权随机、基于源IP的Hash、基于源IP端口的Hash、基于目的IP的Hash、基于UDP报文净荷的Hash、最小链接、加权最小链接、最小响应时间 会话持续性保证技术 基于源IP地址的持续性保持 基于Cookie数据的持续性保持 基于SIP报文Call-ID的持续性保持 基于HTTP报文头的持续性保持 服务器健康监测技术（服务器健康监测）： ICMP、 TCP、 HTTP、 FTP、 DNS、 RAUIUS、 SSL 负载均衡部署方式常用方式： 直连部署 旁挂部署 双机热备部署方式： 主备模式 负载分担模式 服务器负载均衡 四层负载均衡NAT方式、DR方式 七层负载均衡 链路负载均衡 OutBound链路负载均衡 Inbound链路负载均衡 开源负载均衡软件我们的架构：LVS（负载均衡）| Nginx | OpenResty | ATS","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://www.chengkangjian.com/tags/CDN/"}]},{"title":"CDN 内容缓存工作原理及实现","slug":"CDN-three-capter","date":"2017-09-10T10:50:27.000Z","updated":"2019-06-18T13:09:25.672Z","comments":true,"path":"2017/09/10/CDN-three-capter/","link":"","permalink":"http://www.chengkangjian.com/2017/09/10/CDN-three-capter/","excerpt":"","text":"缓存（Cache）是 CDN 的基础技术和组成单元，从外部看，整个 CDN 像一个大的 Cache 向外部提供服务。 内容缓存技术的发展背景 随着网络内容和用户数量的增长，网站服务面临瓶颈。 为此，提高服务器硬件配置、后来出现多台服务器组成服务器集群负载分担，但这些都没有解决网络延迟、“最后一公里”等问题，所以，内容缓存技术出现了。 网站的问题和需求 网站无法及时满足用户增长的需要； 不容易满足远处客户的需要； 设置镜像后，中心服务器和镜像之间同步不及时； 一个镜像失败，无法及时高效的切换调度最近的镜像服务； 通过部署更多镜像解决问题增加成本； 中心服务器IP暴露易遭受DDos攻击； 这些问题也是CDN致力于解决的问题； CDN 出现前的网站服务技术扩展技术 Scale up／out 提高服务器硬件配置 采用服务器集群技术镜像技术 Mirroring 镜像：数字媒体的服务能力和完整内容备份到网络上不同地址的另一个地方。 实现：对整个网站进行镜像复制，多点部署（不同地区不同运营商）。缓存技术 缓存：访问过的内容储存起来，为后续重复访问使用。 缓存代理服务一定范围的访问域（分层缓存）。 CDN将内容缓存到离用户最近的地方实现就近服务；可以说，CDN就是在缓存技术的基础上发展起来的， 也可以说，CDN 是缓存的分布式集群实现，负载均衡系统、运营管理系统是为了各个缓存节点更好的协同工作。CDN 也可以理解为是 智能调度 + 分层缓存技术 的组合。 Cache 设备工作方式和设计要求Cache 设备 根据内容不同，将Cache设备分为 Web Cache（只要用于网页内容和对象） 和 流媒体 Cache（主要用于视频流媒体加速服务）。 大多数设备厂商不会对两者进行区分。但是，CDN服务提供商会对两类服务分别进行开发和优化（内容类型、用户行为、内容更新的差异）。 Web Cache： WebCache作为一种网页缓存技术，可以在任何一个中间网元上实现。 通常，一次网页访问，会涉及四个关键网元：用户、代理、网关、Web服务器。 WebCache通常作为代理或网关部署在用户访问路径上。 部署位置不同，工作模式不同，对WebCache有不同的要求。 部署在代理位置时：透明代理、正向代理模式进行服务。 部署在网关位置时：反向代理。（多数部署在网关） 代理模式： 正向代理：配置正向代理的服务器地址和端口号即可。也常用于中小企业网络环境的搭建。 反向代理：反向代理服务器会接收用户的请求向原始服务器进行请求并响应。 透明代理：可以看作是通过网络设备和协议实现的正向代理工作模式。 WebCache 产品实现关键要素分析 WebCache 应具备 HTTP 协议所描述的基本功能(转发访问请求)。 要根据应用场景和工作模式来确定 WebCache 具备的功能： 面向企业时：主要考虑正向代理、透明代理、用户数量、并发链接数、流量大小、存储空间、缓存大小，以及数据分析、过滤和安全保障能力等情况 面向Web站点时：主要考虑新增链接的处理能力、并发链接处理能力、存储空间和缓存大小等性能指标 Web Cache 的实现基础 - 基于 HTTP 协议的 Web 缓存技术Web 与 HTTP1 WEB 互联网被大众接受，是万维网（World Wide Web）的诞生开始的。 Web特性： 跨平台性、交互性 Web三个精华之处： 用超文本技术 HTML 实现信息和信息的链接 用统一资源定位符 URL 实现全球信息的精确定位 用应用层协议 HTTP 实现分布式的信息共享 2 HTTP HTTP 请求前需建立好 TCP 链接； HTTP 是无状态协议，每次请求和响应都是独立的。 HTTP 链接： 非持久链接 持续链接机制 不带流水线的链接：只有在上一个请求响应后才能发出下一个请求； 带流水线：发现引用就可发起链接； 在HTTP1.1中，默认的是持续的带流水线的HTTP链接。对应的是HTTP 头中的 Connection: Keep-Alive（持久链接） or false（非持久链接） HTTP 工作方式：请求 + 响应 关键概念：连接、消息、请求、响应、资源、实体、客户端、服务器、源服务器、代理、网关、隧道、缓存 HTTP 请求格式：12345678910111213请求方法 URL 版本号通用头1： 通用头值1...通用头N： 通用头N...请求头1: 请求头N...请求头： 请求头N实体头1: 实体头N...实体头： 实体头N实体内容 请求方式：GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 通用请求头：Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via、Warning 常用请求头：Accept Accept-Charset … 此外还有响应格式、响应方式、响应头。 除了以上基本原理之外，还有 Cookie、Session、安全协议、缓存机制关键应用。 HTTP 中的 Cookie 和 Session在请求发出去前，浏览器会先查看本地是否保存此网站的 cookie 文件，如果有会将 cookie 信息放在 cookie 头中一并发出去，如果没有，则不会发送。 cookie 信息的 Exporation 有效期设置，如果没有设置，浏览器认为不保存 Cookie 信息；每个客户端最多保存 300 个 cookie；每个域下 20 个 cookie； Cookie 欺骗； 服务器将 SessionID 返回给浏览器两种方法：一种是 cookie 方法；另一种是 URL 重写； 两者在应用场景、安全性、性能、失效性、等其他方面存在区别； HTTPS 安全协议HTTP + SSL 更能保证整个通信的保密性； HTTP 协议中的缓存技术 使用缓存三大好处：减少延迟；减少网络损耗；降低服务器负载； HTTP协议定义了各种各样的缓存控制方法，合理使用，帮助提高网站服务能力； 缓存工作的基本原则； 头信息设置不缓存 、源服务器认证或涉及安全协议，使请求内容不被缓存； 含有过期时间和寿命信息、且此内容没有过期、缓存内容近期提供过服务且最后更新时间相对于最近使用的时间较持久，使的不需要从源服务器重新获取内容； 若缓存内容已过期，缓存内容服务器向源服务器发出认证是否可以继续使用当前内容； 若网络中断，缓存内容在过期的情况下继续提供服务； 如果响应消息中不存在用于判断内容是否变化的值（ETag、Last-Modified），且没有任何新鲜度的消息，内容不会被缓存。 控制缓存的方法： HTML META标签和HTTP头信息 Expires（过期时间）头信息来控制保鲜期 验证（验证缓存内容是否可用） Cache-Control（缓存控制）HTTP 头信息 Pragma HTTP 头信息 Web Cache 技术实现关键点分析WebCache多采用反向代理的工作方式，用于衡量设备的关键性能指标： 关键性能指标并发量、吞吐量、命中率、请求时间和丢包率 内容存储机制三种方案：共享存储、本地附加存储（DAS）、分布式存储 内容更新机制涉及两方面的内容：哪些内容需要缓存？缓存内容如何更新？ 内容更新机制根据设置的缓存原则进行更新： 头信息告诉 Cache 不用缓存 内容的请求信息需要认证或安全加密的，不缓存 在 HTTP 响应中没有 Etag 或 Last-Modified 头信息，Cache 会认为缺少直接的更新度信息，默认不缓存； Cache 认为缓存内容是足够新的，不会去源站请求；（1.完整的过期时间和寿命控制头信息；2.缓存内容被使用过，并检查过新鲜度。） 如果缓存内容很旧了，会向源站进行验证是否继续可用，如果可用将避免重新获取。（根据经验，一般 html 文件、图片等静态资源会被缓存；而动态资源一般不会被缓存。） Web Cache 协议优化对 Web Cache 的性能优化除了可以从存储机制、内容更新机制入手，也可以从协议优化入手； 优化方法： HTTP链接聚合(把多个短链接聚合成一个长链接，减少频繁开启关闭TCP链接带来的资源消耗) HTTP gzip压缩（网页中音乐、视频等文件被压缩过，再压缩处理效果不大；对HTML、CSS、JS等文件进行压缩可以取得较好的效果） Web Cache安全实现机制 访问控制 病毒防护 网络安全防护 内容加密 开源的Web缓存代理软件-squid该软件主要有以下功能 web代理 内容缓存和加速 ACL访问控制 用户认证 日志","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://www.chengkangjian.com/tags/CDN/"}]},{"title":"CDN 技术概述","slug":"CDN-two-chapter","date":"2017-09-05T11:32:10.000Z","updated":"2019-06-18T13:09:29.092Z","comments":true,"path":"2017/09/05/CDN-two-chapter/","link":"","permalink":"http://www.chengkangjian.com/2017/09/05/CDN-two-chapter/","excerpt":"","text":"CDN 原理CDN 主要由内容缓存、负载均衡、流媒体加速、动态内容加速 几部分内容构成。其主要做的事情是： 选择最优设备为用户服务； 如果某个内容被用户所需要，他会被缓存在就近节点。 数百台 CDN 服务器（Cache）部署在 IDC 机房中，CDN 服务器在 Cache 中复制内容，当内容提供者更新内容时，CDN 向 Cache 重新分发。CDN 提供一种机制，当用户请求内容时，该内容能被最快提供内容的 Cache 向用户提供。这个挑选最优的过程称之为负载均衡。 功能架构功能架构在2003年相对稳定。CDN系统架构主要包含：内容分发系统、负载均衡系统、运营管理系统。 内容分发系统一般由缓存服务器承担这个任务。作用是从内容源中心向边缘缓存和推送的客户请求的内容。内容分发系统含有多个子系统，如：网页加速子系统、流媒体加速子系统应用加速子系统等，这是衡量CDN服务能力的指标。系统除了在承担内容同步、响应用户需求外，还要提供每个设备的响应情况、健康状况等信息，以供调度决策使用哪个缓存组进行服务。 负载均衡系统 负载均衡系统也称调度系统，分为：全局负载均衡系统 GSLB、本地负载均衡系统 SLB。 运营管理系统 包含：运营管理 和 网络管理 两个子系统。运营管理：业务层面的管理。包含客户、计费、产品、统计分析等管理。网络管理：网络设备管理、拓扑管理、链路监控、故障管理等全网资源集中化的管理。 部署架构一般典型的三层架构：边缘层（边缘节点、POP节点）、区域层、中心层。中心层可能承担服务响应请求的功能，也有可能只向下级节点服务。无论是缓存节点还是中心节点均由负载均衡设备和 Cache 设备构成。 Cache 设备 和负载均衡设备的链接一般方式两种：旁路（SLB交换机实现）和穿越（并联、公共的IP地址、软件实现）方式。 CDN 系统分类CDN 发展和互联网发展相辅相成；CDN 系统可以从不同服务承载类型和不同内容生成机制两个视角进行分类。 基于不同服务承载类型分类可以分为： 网页加速； 流媒体加速； 文件传输加速； 应用协议加速； 基于不同内容生成机制分类，互联网的内容主要有两类： 静态内容； 动态内容； Web 网站系统在逻辑上划分三个层次：变现层、业务逻辑层、数据访问层。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://www.chengkangjian.com/tags/CDN/"}]},{"title":"学习了下「CDN」","slug":"CDN-one-chapter","date":"2017-08-30T15:43:27.000Z","updated":"2019-06-18T12:41:43.000Z","comments":true,"path":"2017/08/30/CDN-one-chapter/","link":"","permalink":"http://www.chengkangjian.com/2017/08/30/CDN-one-chapter/","excerpt":"","text":"前段时间，因工作内容中中设计到很多 CDN 业务的知识，于是读了一遍《CDN 技术详解》，这本书内容很丰富，讲了很多 CDN 实现的原理和细节，想吃透这本书，读一遍肯定是不够的，需要理解、思考、和长期实践才能真正的理解 CDN 这块内容。 在阅读此书之前，我仅仅是知道 CDN 可以提高内容的加载速度，通过将网站的资源图片等文件放到七牛的存储服务器中，会提高资源的加载效率，但是我没有测试过，也不知道其是如何做到的。经过几个月的工作实践和阅读，我对 CDN 的理解更进一步。尤其是让我进一步了解了 CDN 和互联网这个概念。 CDN 是全称是(Content-Distribute-Network)，中文直译名称：内容分发忘网络。简单说，CDN 要做的是将网络一端内容快速、准确的传输到用户面前。类似于现实世界的物流，将企业的商品，快速、安全的送达到用户手中。 现如今，互联网世界里的人都在大谈特谈互联网、互联网+，感觉自己作为一名互联网从业人员，并没有理解互联网，它是人类几十年智慧的结晶，我知道真正理解它并不容易。《CDN 技术详解》这书让刷新了我对互联网的认识。 互联网概念可以从两层层面看:一层是狭义的互联网，一层是广义的互联网。 狭义的互联网是以 TCP／IP 代表的网络层，也就是通过 TCP／IP 网络形成的互联网基础，将计算机链接起来，实现了计算机之间的互联互通。广义的互联网也就是我们常说的互联网，它由以 TCP／IP 代表的网络层和以 WWW 万维网为代表的应用层两层组成。 互联网的设计理念是(相对的)中立和无控制的，(相对的)说任何人都有决定权，它的任务就是如何更好的将数据进行端对端的传输。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://www.chengkangjian.com/tags/CDN/"}]},{"title":"未知的花，魅知的旅","slug":"unknow-flower-unknoe-road","date":"2017-08-18T05:29:08.000Z","updated":"2019-06-18T12:21:31.427Z","comments":true,"path":"2017/08/18/unknow-flower-unknoe-road/","link":"","permalink":"http://www.chengkangjian.com/2017/08/18/unknow-flower-unknoe-road/","excerpt":"","text":"在听一首曲子《未知的花，魅知的旅》，有时候音乐的表达更能打动人心。 世界很喧嚣，社会很烦躁，当我带上了耳机，顿时，全世界与我无关。 这种感觉是幸福的。 于是：想到了下面的小诗： 你见，或者不见我， 我就在那里，不悲不喜； 你念，或者不念我， 情就在那里，不来不去； 你爱，或者不爱我， 爱就在那里，不增不减； 你跟，或者不跟我， 我的手就在你手里，不舍不弃； 来我的怀里， 或者， 让我住进你的心里。 默然，相爱；寂静，欢喜… 我喜欢用 省略号 给一首诗、一段话、一篇文章…作结尾。也喜欢用 省略号 给一个不知道想表达的情景作描述。 就像现在这样，这样…","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.chengkangjian.com/tags/心情/"}]},{"title":"Object.defineProperty 的使用总结","slug":"Object-defineProperty","date":"2017-08-16T13:37:02.000Z","updated":"2019-06-18T13:21:34.447Z","comments":true,"path":"2017/08/16/Object-defineProperty/","link":"","permalink":"http://www.chengkangjian.com/2017/08/16/Object-defineProperty/","excerpt":"","text":"Object.definedProperty The Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.Object.defineProperty 可以在一个对象上定义一个新的属性，或修改一个已经存在的属性。并返回该对象。 简而言之，Object.defineProperty 是定义对象属性的方法。 平时我们通过以下的方式定义属性 123let o = &#123;&#125;o.a = 'apple'o['b'] = 'banana' Object.defineProperty 算是第三种，这种方式比以上两种方式更加强大。 语法Object.defineProperty(obj, prop, descriptor) 参数 Object obj 目标对象 String prop 需要定义的属性 Object descriptor 该属性拥有的特性，可设置的值有： value 属性的值，默认为 undefined。 writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。 get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。 configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable，configurable，enumerable）的行为将被无效化，默认为false`。 enumerable 是否能在 for...in 循环中遍历出来或在 Object.keys 中列举出来。默认为 false。 其中 Object descriptor 是需要重点关注的属性：writable 只有设置为 true 可写，默认为 false，false 为不可写。 12345678910111213141516171819// writable: falsevar o = &#123;&#125;Object.defineProperty(o , 'msg', &#123; value: 'hello', writable: false&#125;)console.log(o.msg) // helloo1.msg = 'world'console.log(o.msg) // hello// writable: truevar o = &#123;&#125;Object.defineProperty(o , 'msg', &#123; value: 'hello', writable: true&#125;)console.log(o.msg) // helloo1.msg = 'world'console.log(o.msg) // world configurable: 如果为 false，则任何尝试删除目标属性或修改属性以下特性（writable，configurable，enumerable）的行为将被无效化，默认为 false。 1234567891011121314151617// configurable: falsevar o = &#123;&#125;Object.defineProperty(o , 'msg', &#123; value: 'hello', configurable: false&#125;)delete o.msgconsole.log(o.msg) //hello// configurable: truevar o = &#123;&#125;Object.defineProperty(o , 'msg', &#123; value: 'hello', configurable: true&#125;)delete o.msgconsole.log(o.msg) //undefined enumerable: true 可枚举，false 不可枚举，默认为 false。 12345678910111213141516171819var o = &#123;&#125;;Object.defineProperty(o, 'a', &#123; value: 1, enumerable: true&#125;)Object.defineProperty(o, 'b', &#123; value: 2, enumerable: false&#125;)Object.defineProperty(o, 'c', &#123; value: 3&#125;) // enumerable defaults to falseo.d = 4 // enumerable defaults to true when creating a property by setting itfor (var i in o) &#123; console.log(i);&#125;// a// d get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。 下面是摘抄数据收集的案例：12345678910111213141516171819202122function archiver() &#123; var temperature = null var archive = [] Object.defineProperty(this, 'temperature', &#123; get () &#123; console.log('get') return temperature &#125;, set (value) &#123; temperature = value archive.push(&#123;val: temperature&#125;) &#125; &#125;) this.getArchive = function () &#123; return archive &#125;&#125;var a = new archiver()a.temperature // geta.temperature = 100 // 100a.temperature = 200 // 200a.getArchive() // [0:&#123;val: 100&#125;, 1:&#123;val: 200&#125;] 注意在 descriptor 中不能同时设置访问器 (get 和 set) 和 wriable 或 value，否则会报以下错误：1Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"}]},{"title":"心情","slug":"feeling","date":"2017-08-16T02:00:00.000Z","updated":"2019-06-18T12:20:24.179Z","comments":true,"path":"2017/08/16/feeling/","link":"","permalink":"http://www.chengkangjian.com/2017/08/16/feeling/","excerpt":"","text":"梦想着有一天，可以，照顾好自己身边的人；顺便的，也成就着自己，过着简单的生活，偶尔会走进大自然感受最本真的世界。 想逃离浮华，不知道有没有办法。活在一个金钱主义的世界里，太难逃脱。 我的追求是放弃追求，明明是我不想追求，为什么我依然在追求…","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"我","slug":"我","permalink":"http://www.chengkangjian.com/tags/我/"},{"name":"心情","slug":"心情","permalink":"http://www.chengkangjian.com/tags/心情/"}]},{"title":"不想失去的东西","slug":"donot-want-lose-thing","date":"2017-08-15T05:30:18.000Z","updated":"2019-06-18T12:20:04.943Z","comments":true,"path":"2017/08/15/donot-want-lose-thing/","link":"","permalink":"http://www.chengkangjian.com/2017/08/15/donot-want-lose-thing/","excerpt":"","text":"小的时候，会有很多天马行空的想法，带着童真、好奇和爱好，可以写小诗，作曲，搞恶作剧… 那时也会有很大的勇气，甚至现在我都对过去自己 的勇气表示佩服，小学的时候和班里的同学一起罢课、打架； 高中的时候见到喜欢的女孩就追； 大学的时候和同学们一起创业； 直到来了北京， 现在除了工作中偶尔会需要勇气接受一些挑战性的工作项目之外，感觉勇气在消磨殆尽…","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.chengkangjian.com/tags/心情/"}]},{"title":"尤雨溪知乎Live总结 下篇","slug":"evan-you-live-pro","date":"2017-06-05T12:04:38.000Z","updated":"2019-06-18T12:20:14.198Z","comments":true,"path":"2017/06/05/evan-you-live-pro/","link":"","permalink":"http://www.chengkangjian.com/2017/06/05/evan-you-live-pro/","excerpt":"","text":"状态管理flux、redux、vuex、mobx、Rx.js… 本质：从源事件映射到状态的迁移（改变），映射到UI的改变。按钮 --1--&gt; 状态 --2--&gt; UI 声明式渲染解决了从状态到UI的映射 状态管理解决的是事件到状态的映射，将这部分代码抽离出来，管理好，维护好，是状态管理工具做的事情。 redux和mobx体现两种截然不同的思维方式或者说范式，redux强调数据不改变，reducer拿到原来的state和action返回的是一个新的state。mobox和vue中数据是可变的。 把 Vue 当 redux 用让 Vue 当 MobX 用 这些方案都没有回答如何处理异步，mobx和vuex的异步处理，就是你在action里想怎么搞怎么搞。 一般的CRUD操作，不存在太复杂的异步，杀鸡不用牛刀。如果遇到复杂的场景，如服务端推送、实时、同时请求。，可以考虑Rx.js处理，Rx.js最适合处理事件流。Rx.jsCycle.js 状态的改变在vuex这些工具中需要在mutation中写出来。如果在使用Rx.js的场景下，直接从事件源，映射到结果。其中为代表的是Cycle.js，从头到尾就是一个流，从获取事件是一个流、到状态改变是一个流、到更新dom是一个流。 组件状态和全局状态如何区分，至今也没有一个好的区分方案。 路由传统的路由思想，比较早的是从Ember.js这个框架中出现单页应用的路由。自从react和vue这些框架出现以后，会发现，把组件和路由解耦是可行的，而且更加灵活，另一个启示是从组件出发思考，路由就是将url映射到组件的一个过程。 url到组件的映射，从url出发还是状态出发，其实url就是一个状态。这样的话，一个简单的路由，就是一个动态组件，在vue里面就是component is，在react里就是一个对象表，通过key去渲染。那是一个假象，完整的路由系统要考虑：hash模式和history模式兼容、懒加载、钩子、跳转…其实这是有些复杂度的。 react-router4是一个去中心化的路由方案，类似通过功能性组件（组件做路由）实现。 Web路由和APP路由区别:切换方式的区别 Web路由：二级切换，切换即替换APP路由：卡碟式切换，切换即覆盖 CSS方案主流的 CSS 方案 跟 JS 完全解耦，靠预处理器和比如 BEM 这样的规范来保持可维护性，偏传统 CSS Modules，依然是 CSS，但是通过编译来避免 CSS 类名的全局冲突 （命名随机化避免命名冲突） 各类 CSS-in-JS 方案，React 社区为代表，比较激进 Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面），一种比较折中的方案 比较要结合场景在单页应用的场景下，使用BEM相当于平行的维护了两套结构，一套是组件结构，一套是规范结构。将两者统一是比较好的方案。 css in jshttps://medium.com/seek-blog/a-unified-styling-language-d0c208de2660 https://medium.com/seek-blog/a-unified-styling-language-d0c208de2660 传统 css 的一些问题： 作用域 （解决的已经很好了，css module， inline sytle ，vue scoped） Critical CSS （仅导出页面相对应的css代码，不加载不必要的css代码） Atomic CSS （减小体积） 分发复用 跨平台复用 css in js 通过运行时能较好的解决问题2。 在vue里 使用CSS Modules 会不会比 使用 scoped 好？没有本质区别，scoped成本更低，但是导出的页面更大。css module一定程度运行时的代价，因为需要动态的class绑定，区别不大。 Atomic CSS：原子类css，将公共的共享的样式类抽象成原子类，最终的体积会比较小。分发复用：css in js都是javascript,可以像普通javascript一样分发的npm上进行复用：其实css放到包里也可以发布到npm上进行复用的，不算是个大优势。跨平台复用：css in js跨平台复用，其实css 也可以pass成javascript进行跨平台复用的。 这个方案，不一定好，态度保留。 构建工具出现背景：平台越来越强 要求越来越高 任务复杂度 工具复杂度 构建工具解决的其实是几方面的问题： 任务的自动化 开发体验和效率（新的语言功能，语法糖，hot reload 等等） 部署相关的需求 编译时优化 grunt - gulp - webpack - rollup - systemjs，这些构建工具中，主打一切皆模块的webpack脱颖而出。 大多数情况下 npm script + webpack 组合就可以了。 最终代码跑在浏览器里，这个限制要求我们必须构建，因为我们没有浏览器的控制权。 现在前端的构建工具链很完善了。html 、css 、js 都有自己的构建工具，只需写转换规则就好。 关于部署的一个文章 部署优化：请求合并（打包），静态资源路径映射，小尺寸资源内联，代码分割、时间戳。webpack复杂是因为解决的问题本来就很复杂。rollup简单优雅，因为做的事情简单。 构建时优化 服务端数据通信restful api ==&gt; crud 实时数据库firebase、horizon ==&gt; 数据实时性 数据关联性 graphQL:暴露一个接口，急于图的查询而不是表，对复杂关联数据的获取，数数据量的优化也更加精确。 服务端的数据是否应该放在store里面去？有些多此一举，因为改还是需要通过接口改。 跨平台渲染React native 、 Weex本质：设计框架的时候，框架的渲染机制和dom解耦。ReactNative 针对每一个平台设计渲染引擎。 新规范Web Component webassembly 总结我们聊了很多东西，可能比较杂，但我希望大家发现其中一些共性的东西：技术方案都是先有问题，再有思路，同时伴随着取舍。在选择衡量技术的时候，尽量去思考这个技术背后是在解决什么问题，它做了怎样的取舍。这样一方面可以帮助我们更好的理解和使用这些技术，也为以后哪天你遇到业务中的特殊情况，需要自己做方案的时候打好基础。 问题关于react和vue具体的技术选型能举个例子来说明这两个框架所适用的场景吗？适用场景几乎差不多。 对于前端框架的学习需要到什么程度才算比较好？熟悉源码？理解思想？还是其他什么？理解思想更重要，学习源码，吸收设计原理和方案对做业务没啥帮助。 vue现在一直在推后端渲染的模式，是为了seo么？现在前端的性能在不断提高，不是应该前端渲染的发展趋势更好么？TTC 直出的价值 让用户早一点再早一点看到界面 现在HTTP/2越来越普及，前端构建工具在针对HTTP/2上怎么去找一个平衡点呢？实际测量才能有的谈","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.chengkangjian.com/tags/vue/"}]},{"title":"尤雨溪知乎Live总结 上篇","slug":"evan-you-live","date":"2017-06-05T11:55:59.000Z","updated":"2019-06-18T12:20:18.427Z","comments":true,"path":"2017/06/05/evan-you-live/","link":"","permalink":"http://www.chengkangjian.com/2017/06/05/evan-you-live/","excerpt":"","text":"开篇框架的比较，不谈场景都是刷流氓：不同的场景，不同的开发者爱好会产生不同的需求，多种方案的并存是必然和优异的。 针对不同的场景、框架背后需要解决的问题、结合经验选择框架。 组件现在所有的框架都已经支持组件化的开发方式。最初是已页面作为开发单位，html、css、js，当时我们的思维方式就是那样。后来我们的前端开发从页面转变为了应用。应用就会有模块封装和切分的需求，很快我们发现应用是可以拆分为组件树的，这是偏展示的一个理解，react的出现揭示了一个事实，就是组件可以是函数。 想象一下，整个应用是一个大的函数，函数里面可以调用别的函数，每个组件是一个函数，一个组件可以调用别的函数，返回viture dom,这突破了我们原来对静态页面的理解方式。但是这种简单的函数式的组件在实际应用过程中是不够的，所以react默认的组件形式里有了state，然后外面用class来包装等等。 组件可以分为四类： 纯展示组件 接入性组件container（会和数据层的serverce打交道） 交互型组件（比如各类加强版的表单组件，通常强调复用） 功能型组件（组件本身不渲染任何内容，作为功能扩展而存在比如 &lt;router-view&gt;，&lt;transition&gt;，作为一种扩展、抽象机制存在。） template和jsx的对比：jsx在写功能性组件的时候，是非常方便的，因为其继承了javascript语言的灵活性，是远超模版的。template在写纯展示型组件的时候是非常方便的。 colocation含义: 把应该放一起的东西放一起，比如vue的单文件把 style 、script 、 template 放一起。（以前是以语言为单位进行切分） 变化侦测和渲染机制Declarative Programming 声明式编程告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。（react、vue等框架的方式，直接描述dom和数据的关系就可以了，这就是数据驱动。）1234567&lt;!--声明式风格--&gt;&lt;!--只需声明你要啥--&gt;var numbers = [1,2,3,4,5]var doubled = numbers.map (function (n) &#123; return n * 2&#125;)console.log (doubled) //=&gt; [2,4,6,8,10] Imperative Programming 命令式编程命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 （jquery直接干的方式） 123456789&lt;!--命令式风格--&gt;&lt;!--需要干事情--&gt;var numbers = [1,2,3,4,5]var doubled = []for(var i = 0; i &lt; numbers.length; i++) &#123; var newNumber = numbers[i] * 2 doubled.push (newNumber)&#125;console.log (doubled) //=&gt; [2,4,6,8,10] view = render(state)render就是react里jsx中的render函数，其实vue的template最终也是编译成一个个render函数的。模版本身和jsx和本质上相似的，他们的输入都是state，输出都是dom。 Virtual DOM底层实现可以是Virtual DOM，也可以是细粒度的绑定等等。 一直有一个疑问，以前 被人诟病，为啥 vue 的声明式写法就是推崇的？onclick绑定的作用域是全局的，造成了环境污染，裸写的函数完全不知道是被哪个dom引用。vue中的绑定是局部作用域，而且javascript的逻辑是放在组件里的，符合colocation的理念，这样就很好维护了。 变化侦测Reactivity in Frontend JavaScript Frameworks 变化侦测有两种方式：pull 和 push react 的 setState 和 angular 的脏检查属于 pull 的方式。 pull的方式，系统不知道数据什么时候变化，那么它需要一个信号告诉他说知道数据有可能变了，这个时候系统来进行一个暴力的比对，react 通过 Virtual DOM 中的diff方式，angular 是脏检查。能过这么做是因为 javascript 已经足够快，有浪费但是可以接受。 push的方式，Vue （响应式）和 Rx.js（Observable） 的方式，更加细粒度的更新，意味着更多的watcher，同样也会带来内存和性能的开销。 vue2选择了相对折中的方案，在组件层面，vue2使用的是 push 的方式，每一个组件都是响应式的watcher，这样vue能够知道哪些组件内部的状态发生了变化，然后在组件内部使用 pull 的方式通过virtual Dom进行比对更新。 pull和push的对比，不能说哪个方案一定好，本质区别是用侦测成本换取自动优化的成本。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://www.chengkangjian.com/tags/vue/"}]},{"title":"从零开始学习webpack搭建vue项目(二)","slug":"webpack-note-02","date":"2017-05-06T11:19:43.000Z","updated":"2019-06-18T12:21:50.133Z","comments":true,"path":"2017/05/06/webpack-note-02/","link":"","permalink":"http://www.chengkangjian.com/2017/05/06/webpack-note-02/","excerpt":"","text":"webpack+vue项目实践记录02配置webpack.config.js文件 支持http dev 支持热替换 支持es6 支持sass 打包的js文件自动插入到index.html模版中安装dev-server 12345# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress 注意的是以上的安装方式除了要安装全局，还要本地安装。 执行webpack-dev-server --progress命令，报错显示没有找到配置文件，原来是需要--config来指定配置文件。 使用webpack-dev-server --config build/webpack.config.js --inline --hot完成服务的启动。 也可以使用 webpack --config build/webpack.config.js --progress --watch //这条命令可以启动watch观察者模式。 12345devServer: &#123; contentBase: path.join(__dirname, &quot;dist&quot;), compress: true, port: 9000&#125; 服务启动的文件如上所示，但是问题又来了，当我访问浏览器localhost:9000时，没有找到资源文件，说明还是有配置没有搞好，主要是路径配置的问题，搞这需要搞明白contentBase、path、publicPath…这些参数的含义。 搞好配置文件，实现可以正常访问项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;)let HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; entry: &#123; app: path.resolve(__dirname, &apos;../src/main.js&apos;), &#125;, output: &#123; path: path.resolve(__dirname, &apos;../dist&apos;), //打包文件的输出地址 filename: &apos;[name].[hash].js&apos;, publicPath: &quot;/&quot; &#125;, resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.common.js&apos; &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; &apos;scss&apos;: &apos;vue-style-loader!css-loader!sass-loader&apos;, &apos;sass&apos;: &apos;vue-style-loader!css-loader!sass-loader?indentedSyntax&apos; &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, loader: &apos;file-loader&apos;, // file-loader 都是用于打包文件和图片 options: &#123; name: &apos;[name].[ext]?[hash]&apos; &#125; &#125; ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), //支持热替换 new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; //指定处理模版 &#125;) ], // devServer: &#123; // colors: true, // &#125;, devServer: &#123; historyApiFallback: true, //不跳转 contentBase: path.join(__dirname, &quot;../src&quot;), //默认访问的本地静态文件的地址目录，建议最好是绝对路径 compress: true, // 启动gzip 压缩 Enable gzip compression inline: true, //时时刷新 hot: true, //支持热更新 port: 9999 &#125;&#125; 如上配置文件，执行webpack-dev-server --config build/webpack.config.js --inline --hot完成dev-server启动操作。 支持热替换其实 –hot 已经支持了热替换 但是另我不明白的是如果在CLI中不使用--line --hot，但是在devServer的配置中添加了指令，webpack-dev-server --config build/webpack.config.js执行时，热替换没有生效。 12345678devServer: &#123; historyApiFallback: true, //不跳转 contentBase: path.join(__dirname, &quot;../src&quot;), //默认访问的本地静态文件的地址目录，建议最好是绝对路径 compress: true, // 启动gzip 压缩 Enable gzip compression inline: true, //时时刷新 hot: true, //支持热更新 port: 9999&#125; 直到我添加下面的这个插件，解决了这个问题。至于原因至今未知。123plugins: [ new webpack.HotModuleReplacementPlugin(),//支持热替换], 在package.json 加上以下这段，就支持了使用npm run start启动项目了。1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --config build/webpack.config.js --inline --hot&quot;&#125;, 支持es6 支持sass到这时，我在想，需要安装些loader，css-loader、sass-loader、style-loader、babel-loader、file-loader(用于打包文件和图片),在这里连续安装了 1npm install sass-loader scss-loader --save-dev 在启动时，提示我需要安装node-sass,node-sass查了一下，简单说，就是将sass编译成css的一个工具，没有深究。 1npm install sass-loader scss-loader --save-dev 装完之后 1234567891011&#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; &apos;scss&apos;: &apos;vue-style-loader!css-loader!sass-loader&apos;, &apos;sass&apos;: &apos;vue-style-loader!css-loader!sass-loader?indentedSyntax&apos; &#125; // other vue-loader options go here &#125;&#125; 就直接ok了。 下一步，支持es6， 123456789101112&#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/&#125;,&#123; test: /\\.(png|jpg|gif|svg)$/, loader: &apos;file-loader&apos;, // file-loader 都是用于打包文件和图片 options: &#123; name: &apos;[name].[ext]?[hash]&apos; &#125;&#125; 执行npm run start,提示安装babel-loader和babel-core，并依次安装 执行编译，自动引入到html文档中，使用html-webpack-plugin这个插件安装npm install html-webpack-plugin --save-dev添加此配置，其中template是指定处理的模版文件 12345plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; //指定处理模版 &#125;)] 另外有一点需要注意的是12345output: &#123; path: path.resolve(__dirname, &apos;../dist&apos;), //打包文件的输出地址 filename: &apos;[name].[hash].js&apos;, publicPath: &quot;/&quot;&#125; html-webpack-plugin插件是根据输出文件的路径配置进行对index.html进行处理的，将js文件插入到index.html中，需要保证此配置正确。其中“path”仅仅告诉Webpack结果存储在哪里，然而“publicPath”项则被许多Webpack的插件用于在生产模式下更新内嵌到css、html文件里的url值。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.chengkangjian.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://www.chengkangjian.com/tags/webpack/"}]},{"title":"第一次控制自我","slug":"control-myself","date":"2017-04-25T09:09:40.000Z","updated":"2019-06-18T12:20:01.756Z","comments":true,"path":"2017/04/25/control-myself/","link":"","permalink":"http://www.chengkangjian.com/2017/04/25/control-myself/","excerpt":"","text":"我知道自己的大脑和自己是两部分，这也形成了自己感性的一面和理性的一面。 当我的身体内的肾上腺激素飙升的时候的时候，往往是面临着压力的到来，感性的一面大行其道，自己的真性情显露无遗，会产生很多应激反应，比如发抖，脸红。 我知道，人没有好坏之分，只有好的时候和坏的时候，人是局限性的，好的时候和坏的时候在很多时候不是自己主动选择的，是自己身处的环境所诱导的。所以我不会和自己说自己是个好人还是坏人，自己都不是，自己就是一个人。 昨天是控制住了自己的感性的一面的第一天，值得铭记的一天，有了这第一次，我相信，后面的路会更好走。 我经常和朋友说，做事之前，需要先分析一下，这个事是好事还是坏事，如果是好事，那就坚持自己的原则做下去，如果是坏事，那么就告诉自己，stop it！我的朋友反驳说：难道你是个圣人？是的，我说的很轻松，做到它谈何容易，当我想干一件事，有时候明明知道是不好的，但是你就是控制不住自己，这就是我的人性的弱点，这就是我的人的局限性。 一直以来我都无法做到控制住自己，即使我想控制，但是心有余而力不足，但是庆幸的是，这些年来，自己的理性的时候占了大多数，导致自己没有陷入坏的自己的世界太深，大致还是向着好的方向发展，这得益于自己的三观相对正常。 每一次完全的掌控自己，过程是痛苦的，结果是美妙的；比如昨天的因导致了今天的果。 今天的感觉很异常，异常的好！","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"},{"name":"我","slug":"我","permalink":"http://www.chengkangjian.com/tags/我/"}]},{"title":"从零开始学习webpack搭建vue项目(一)","slug":"webpack-note-01","date":"2017-04-16T16:59:17.000Z","updated":"2019-06-18T12:21:44.552Z","comments":true,"path":"2017/04/17/webpack-note-01/","link":"","permalink":"http://www.chengkangjian.com/2017/04/17/webpack-note-01/","excerpt":"","text":"webpack+vue项目实践记录01目的：练习render背景：一直使用vue-cli搭建vue工程，虽然vue全家桶在实际项目中应用的还过得去，以及之前也学习和练习了webpack的用法，但是在实践项目中没有使用太多，而且vue的前端工程化学习到的感觉是空中楼阁，对于未来的工程问题，仅仅使用vue-cli时不能够灵活的进行解决的，于是产生重新开始学习vue结合webpack搭建web工程的想法。 开始新建文件夹 vue-pro在vue-pro下新建文件夹 build在vue-pro下新建文件夹 src在vue-pro目录下执行npm init,初始化package.json在vue-pro目录下执行npm install vue --save-dev,安装vue 在src下新建 index.html main.js App.vue 分别作为实例挂载点、实例挂载入口文件、和vue单页模版根文件在build文件夹下创建dev-server.js 用于配置本地项目的启动文件 初始化这个项目下一步： 安装webpack、并配置，跑起来这个项目安装vue-loader安装webpack，查看版本号为1.14，应升级2.33 npm install -g webpack@2.3.3刚开始执行webpack build/webpack/config.js错误，是没找到webpack.config.js这个文件后来cd build 后执行 webpack webpack.config.js 报错 缺少vue-template-compiler，继续安装此模块缺少css-loader，继续安装此模块 执行webpack webpack.config.js成功 双击index.html 报错You are using the runtime-only build of Vue where the template compiler is not available.找到了一篇文章package.json 中的 main 属性决定了，当项目被引入时，输出的是哪个文件，而 vue 的 package.json 中的 main 指向的是 dist/vue.common.js。 擦，并不太懂是什么鬼，就是把 12// import Vue from &apos;Vue&apos;import Vue from &apos;vue/dist/vue.js&apos; 替换就好了。 但是渲染出来没有内容，我目前猜可能是需要服务器渲染的问题》》》 不是服务器渲染的问题 1234render: h =&gt; h(App)// component: &#123;// App// &#125; 这么替换，就完成了页面的渲染。 问题： 1.为什么在build外执行webpack build/webpack/config.js 报错？ 我发现，entry的入口路径参考的是你执行webpack的当前文件夹， 如果我我在webpack.config.js文件下执行webpack，那么这个时候，配置文件的入口地址，可以被找到，因为webpack的执行目录和配置文件所在目录是一致的，当我到上一层执行webpack构建时，就会出现问题，此时可以将entry的入口文件改为绝对地址就没有问题了。12// entry: &apos;../src/main.js&apos;,entry: path.resolve(__dirname, &apos;../src/main.js&apos;), 但是我执行webpack build/webpack/config.js时还是不行，报错：1234No configuration file found and no entry configured via CLI option.When using the CLI you need to provide at least two arguments: entry and output.A configuration file could be named &apos;webpack.config.js&apos; in the current directory.Use --help to display the CLI options. 当我执行webpack --config build/webpack.config.js --progress就可以成功。 这两者有什么区别呢？ 原来，这和progress没关系，Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。 soga！！ 2.import Vue from &#39;Vue&#39; 和 import Vue from &#39;vue/dist/vue.js&#39; 什么区别？ 这个问题还需要从vue的构建方式来看，vue的构建方式有两种独立构建 和运行时构建，其中独立构建= 编译 + 运行时构建， Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。 vue默认的是运行时构建，如果想使用独立构建需要在webpack配置中加入下面这段： 12345resolve: &#123; alias: &#123; &apos;vue$&apos;: vue/dist/vue.esm.js // &apos;vue/dist/vue.common.js&apos; for webpack 1 &#125;&#125; 但是如何区分运行时构建和独立构建？以及怎么分别实现运行时构建和独立构建？ 至此，如果想使用template写模版，需要使用独立构建，如果使用render函数渲染模版使用运行时构建。 独立构建 12345678import Vue from &apos;vue/dist/vue.js&apos; //独立构建// import Vue from &apos;vue/dist/vue.esm.js&apos; //独立构建import App from &apos;./App.vue&apos;new Vue(&#123; el: &apos;#app&apos;, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;).$mount(&apos;#app&apos;) 运行时构建 1234567import Vue from &apos;Vue&apos; //运行时构建import App from &apos;./App.vue&apos;new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App)&#125;)","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.chengkangjian.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://www.chengkangjian.com/tags/webpack/"}]},{"title":"My Girlfriend","slug":"my-girlfriend","date":"2017-04-12T15:14:07.000Z","updated":"2019-06-18T12:20:47.379Z","comments":true,"path":"2017/04/12/my-girlfriend/","link":"","permalink":"http://www.chengkangjian.com/2017/04/12/my-girlfriend/","excerpt":"","text":"这其实是关乎隐私的文章，但是我想记录下来，我希望写下来我的感受，永远的记住它。 说实话，在遇到女朋友之前，我一直都是一个花心的人，但是当我遇到我的女朋友，我变得专一了。这印证了一句话：“抓不住男人的心，就不要说男人花心”(开玩笑)。 女朋友在我心里是全世界最好的女朋友，因为她的存在，我变得更加积极向上、阳光、健康，生活变得更加丰富多彩。 在女朋友心里，我有很多绰号，我能想起来的有：变色龙、盘中餐、大叔、害人精、blue、喵喵、呆萌、萌萌哒、大虫子……等等，当然，更多的时候都是称呼我亲爱的～。 每一个绰号都有故事，都有来源，我们的生活很普通和平凡，但是不单调，因为有她。 我的女朋友有时候也会生气，这个时候，很明显，因为是我做得不够好导致的，作为一名程序员，有时候缺少了制造浪漫，常常以我是简单内向的程序员为借口，但是我的女朋友明知是假的还是将信就信了，去哪找这么“通情达理”的女朋友。 我经常加班，甚至周六也加班，有时候陪他就比较少，女朋友虽然不希望我这么辛苦的加班工作，但是还是很理解我，有时候我挺愧疚的。 有时候晚上回来的十一点了，女朋友做好了水果沙拉，写好了留言条放在桌子上，嘱咐我记得吃，满满的感动，看着她睡着的样子，真想去亲亲她，但又怕打扰她休息-我心里的全世界最好的女朋友。 我有时候会懒惰，但是想想远方的亲人和身边的女朋友，奋斗的动力又十足了。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"}]},{"title":"一段代码-递归调用的返回值问题","slug":"一段代码-递归调用的返回值问题","date":"2017-04-07T04:35:35.000Z","updated":"2019-06-18T13:47:57.015Z","comments":true,"path":"2017/04/07/一段代码-递归调用的返回值问题/","link":"","permalink":"http://www.chengkangjian.com/2017/04/07/一段代码-递归调用的返回值问题/","excerpt":"","text":"今天写一个递归函数，获取的返回值不是自己想要的结果，而是undefined，困扰了我很久。 1234567891011function recuFunc(val) &#123; if (val &gt; 10) &#123; return val &#125; else &#123; recuFunc(val + 1) &#125;&#125;let res = recuFunc(1)console.log(res) //undefined 思考了许久，终于发现了问题之所在。 1234567891011function recuFunc(val) &#123; if (val &gt; 10) &#123; return val &#125; else &#123; return recuFunc(val + 1) &#125;&#125;let res = recuFunc(1)console.log(res) //11 仅仅在递归调用的函数前面加上return，问题迎刃而解。究其原因，简单说就是函数体没有返回值，自然结果是 undefined。最初我以为当我执行到 val &gt; 10 的时候，return val 此时就能得到想要的结果，那是我对递归算法的理解不够。现在想来，其实递归函数就像一个同心圆一样，一层函数嵌套着一层函数，当边界条件被满足时，return val 返回给最里层的函数，如果函数前不加 return ,但是这个函数结果没有被返回,它的上层函数就没有返回值，其结果就是 undefined 了。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"},{"name":"学习","slug":"学习","permalink":"http://www.chengkangjian.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"}]},{"title":"一段代码-检测JS对象值是否为空","slug":"isEmptyValue","date":"2017-04-01T12:03:46.000Z","updated":"2019-06-18T13:37:07.247Z","comments":true,"path":"2017/04/01/isEmptyValue/","link":"","permalink":"http://www.chengkangjian.com/2017/04/01/isEmptyValue/","excerpt":"","text":"前端在开发过程中，经常会遇到后端传过来的数据为空的情况，如果我知道确定的数据类型还比较容易判断，但有时候类型是不确定的，比如数组类型，在数组为空的时候，不知道返回的是[] 还是 null，这个时候如果冒然的使用Array.length()进行判断，当返回的空数组的值不是[]而是null时就会出现问题。 于是我就想写段代码，去检测数据是否为空，以后直接调用它便是。 我将如下的数据值定义为空值，其他值便为非空值。 [] {} ‘’ ‘ ‘ null undefined 由于在JavaScript中的所有事物都是对象，所以需要先进行对象类型的判断，然后再根据不同的类型进行处理。typeof主要进行基本数据类型的检测，在这里不适用。考虑到javascript安全的类型监测，所以在这里如果使用instanceof在多个JS框架环境中使用并不保险。所以安全起见，还是使用Object.prototype.toString.call()比较靠谱。 下面就根据以上的想法产出了下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738function isEmptyVal (val) &#123; let type; let isEmptyObj = function (obj) &#123; for (let name in val) &#123; return false; &#125; return true &#125; type = Object.prototype.toString.call(val).slice(8, -1) switch (type) &#123; case 'Array': return !val.length case 'String': return !val.trim() case 'Object': return isEmptyObj(val) case 'Null': return true case 'Undefined': return true default: return false &#125;&#125;let isEmptyVal1 = isEmptyVal('')let isEmptyVal2 = isEmptyVal(&#123;&#125;)let isEmptyVal3 = isEmptyVal([])let isEmptyVal4 = isEmptyVal(null)let isEmptyVal5 = isEmptyVal(undefined)let isEmptyVal6 = isEmptyVal(' ')console.log(isEmptyVal1) //trueconsole.log(isEmptyVal2) //trueconsole.log(isEmptyVal3) //trueconsole.log(isEmptyVal4) //trueconsole.log(isEmptyVal5) //trueconsole.log(isEmptyVal6) //true","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"}]},{"title":"JS对象的深拷贝和浅拷贝","slug":"JS-deep-copy-and-shallow-copy","date":"2017-03-15T10:35:42.000Z","updated":"2019-06-30T02:34:01.028Z","comments":true,"path":"2017/03/15/JS-deep-copy-and-shallow-copy/","link":"","permalink":"http://www.chengkangjian.com/2017/03/15/JS-deep-copy-and-shallow-copy/","excerpt":"","text":"我们在对数据进行备份的时候，如果这个数据是基本的数据类型，那么很好办，通过赋值实现复制即可。 如果在使用JavaScript对数组或对象进行操作的时候，我们经常需要将数组或对象进行备份，事实证明如果只是简单的将它赋予其他变量，那么我们只要更改其中的任何一个，然后其他的也会跟着改变，这就导致了问题的发生。 这个问题就是深拷贝和浅拷贝的问题。 浅拷贝但是当遇到引用数据类型时，就需要三思而复制，操作而三思。1234567891011let obj1 = &#123; a: 1, b: 2&#125;let obj2 = obj1obj2.b = 3console.log(obj1) // &#123; a: 1, b: 3 &#125;console.log(obj1 === obj2) //true 在这里我只是想obj2复制obj1,当我对obj2进行操作时，obj1的值也发生了变化。换句话说就是因为如果只是简单的赋值，它只是进行了地址的引用，所以改变一个对象另一个对象也会跟着变。上面这种直接赋值方式的复制称之为浅拷贝。 深拷贝我在想如何让obj2复制obj1的对象内容，在我对obj2进行修改时，不影响obj1，下面总结两个方法，可以在不同情况下使用。 1. JSON.parse(JSON.stringify(obj))利用JSON的方式进行浅层次序列化对象进行深拷贝是一个很好的方法。 12345678910let obj1 = &#123; a: 1, b: 2&#125;let obj3 = JSON.parse(JSON.stringify(obj1))obj3.b = 5console.log(obj1) //&#123; a: 1, b: 2 &#125;console.log(obj1 === obj3) //false 但是JSON的方式有局限性，就是对象必须遵从JSON的格式，当遇到层级较深，且序列化对象不完全符合JSON格式时，使用JSON的方式进行深拷贝就会出现问题。 123456789let obj1 = &#123; a: '1', b: '2', c: function func() &#123;&#125;&#125;let obj4 = JSON.parse(JSON.stringify(obj1))console.log(obj4) //&#123; a: '1', b: '2' &#125; 好像漏了些什么😄 2. Object.assign(target, …sources) Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 它接收一个目标对象（target）和 一个或多个源对象（sources）。 我们可以使用它进行对象的复制、合并：12345678// 复制let c = Object.assign(&#123;&#125;, &#123; a: 'apple' &#125;);console.log(c); // &#123; a: 'apple' &#125;//合并let o = &#123;&#125;let c = Object.assign(o, &#123; a: 'apple' &#125;, &#123; b: 'banana' &#125;, &#123; c: 'cake' &#125; )console.log(c) // &#123; a: 'apple', b: 'banana', c: 'cake' &#125; 虽然它可以复制对象，但是 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。1234567891011121314let a = &#123; b: &#123;c:4&#125; , d: &#123; e: &#123;f:1&#125;&#125; &#125;let g = Object.assign(&#123;&#125;,a)let h = JSON.parse(JSON.stringify(a));console.log(g.d) // &#123; e: &#123; f: 1 &#125; &#125;g.d.e = 32console.log('g.d.e set to 32.') // g.d.e set to 32.console.log(g) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125;console.log(a) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125;console.log(h) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: &#123; f: 1 &#125; &#125; &#125;h.d.e = 54console.log('h.d.e set to 54.') // h.d.e set to 54.console.log(g) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125;console.log(a) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125;console.log(h) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 54 &#125; &#125; 而且，原始类型会被包装，null 和 undefined 会被忽略。123var obj = Object.assign(&#123;&#125;, &quot;abc&quot;, null, true, undefined, 10, Symbol(&quot;foo&quot;));// 注意，只有字符串的包装对象才可能有自身可枚举属性。console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; 所以，Object.assign并没有解决我们深度拷贝的需求。 3. 一段深拷贝的代码其实实现对象的深拷贝，只需要把父对象的属性，全部拷贝给子对象，就可以实现复拷贝。1234567function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125; 但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 当对象层级较深，且序列化对象不完全符合JSON格式时，这个时候就需要通过递归调用”浅拷贝”来解决。 12345678910111213141516171819202122232425262728let obj1 = &#123; a: '1', b: '2', c: &#123; d: '3' &#125;, d: function aa () &#123;&#125;&#125;function deepCopy(obj) &#123; if(typeof obj === \"object\") &#123; if(obj.constructor === Array) &#123; var newArr = [] for(var i = 0; i &lt; obj.length; i++) newArr.push(obj[i]) return newArr &#125; else &#123; var newObj = &#123;&#125; for(var key in obj) &#123; newObj[key] = this.deepCopy(obj[key]) &#125; return newObj &#125; &#125; else &#123; return obj &#125;&#125;console.log(deepCopy(obj1)) //&#123; a: '1', b: '2', c: &#123; d: '3' &#125;, d: [Function: aa] &#125; 继续简化一下… 123456789101112131415161718let obj1 = &#123; a: '1', b: '2', c: &#123; d: '3' &#125;, d: function aa () &#123;&#125;&#125;function deepCopy (obj) &#123; let temp = obj.constructor === Array ? [] : &#123;&#125; for (let val in obj) &#123; temp[val] = typeof obj[val] == 'object' ? deepCopy(obj[val]) : obj[val] &#125; return temp&#125;console.log(deepCopy(obj1)) //&#123; a: '1', b: '2', c: &#123; d: '3' &#125;, d: [Function: aa] &#125; 总结在实际开发中，关于对象复制的问题是经常遇到的。最常见的是对对象的复制，重新定义，扩展等。掌握浅拷贝和深拷贝的区别以及如何进行深拷贝，以及选择哪个方式进行深拷贝，会节省许多debug时间，避免很多不必要的麻烦。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"},{"name":"学习","slug":"学习","permalink":"http://www.chengkangjian.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"对象","slug":"对象","permalink":"http://www.chengkangjian.com/tags/对象/"}]},{"title":"记一次敏捷开发Scrum培训及实践的感受","slug":"agile-development-training","date":"2017-03-11T14:24:13.000Z","updated":"2019-06-18T12:19:32.007Z","comments":true,"path":"2017/03/11/agile-development-training/","link":"","permalink":"http://www.chengkangjian.com/2017/03/11/agile-development-training/","excerpt":"","text":"在2016年10月26日，部门请到了亚信的内训师王林皓讲师来给我们BDX的大数据云平台部和数据产品线专门培训敏捷开发Scrum。王老师很早以前就是Scrum Master，带过很多敏捷的团队，在Scrum方面有丰富的经验。 作为自己在这个培训之前，通过工作中的体会和一些资料的阅读，我对敏捷开发也有一点点的认识。知道敏捷开发的敏捷性，小步代跑的过程能够根据不断变化的需求快速响应。 在当天培训中，讲师通过八个章节的内容介绍，中间穿插着一系列的活动作示例，并结合理论的讲解，让我听得受益匪浅，对敏捷开发有了新的认知。 首先，讲师介绍敏捷的五大要素（勇气、开放、承诺、专注、尊重）过程中，自己其实是挺感慨的，自己参与了一年左右的敏捷开发流程，却不知道自己需要以一种怎样的态度来参与敏捷。以上的五大要素中，在自己目前的实践中，自己在勇气和开放方面做的最不好，对于今后，会通过各个击破的方式一项一项整体提高这五大要素的要求。 现在是处于互联网的时代，在这个时代下要求产品的研发要快、准、狠才能跟的上跟得上市场的步伐。敏捷原则和思维刚刚好解释了在这个时代下选择敏捷开发是因为开发需要敏捷这个特性。敏捷不是一个方法论、过程或者框架，敏捷是一种思维。这个思维特性要求自己以一种开放的心态不断的学习和改变来适应周围的变化。 讲师通过一系列的活动实践告诉我们实践敏捷的价值就是优先做最有价值的事，虽然这并不容易做到，这要求参与敏捷的每个人都要拥有共同的价值观，大家齐心协力在一个方向上努力。除非需求的市场前景特别明晰，不然需求价值的大小有时候并不容易统一，这在实践过程中是有挑战的。通过敏捷实践价值这节的学习，要求自己在今后了解自己工作内容的价值，这样应该会让自己更好的开展工作。 通过对scrum的特征、框架、团队方面内容的学习，让我对敏捷开发的认识比较全面。在透明性、跨职能、自组织三个特征中， 目前团队的敏捷实践对这些特征没有明显的体现，可见，我们需要改进的地方还有很多。个人角度来看，需要先从自己的心态上、行为上逐渐的去改变。 讲师在讲解的过程中，也通过提出一个问题引发我们的思考最后解决问题来引起我们的共鸣。有个问题令我印象深刻，“每周计划制定之后，计划外的任务打乱原计划时，计划如何调整？”,因为这个问题目前正在发生，我们的方式是尽量赶计划，实在完成不了计划就会延迟。老师给出”进多少，出多少“的方案是比较客观合理的。 在敏捷开发过程中，有一块内容是我感觉非常困难的，就是敏捷估算。虽然讲师告诉我们不要绝对估算，要使用相对估算的方法，即使这样估算起来还是摸不着头脑。比如在从用户故事进行任务量估算，完全是凭感觉来的，估算的值很不准确，这方面可能随着业务经验的增长会逐渐变好吧。 本次培训是能够引发自己思考的一次培训，因为这和每天的工作息息相关，讲的内容也容易接受。但是理论和实践总是存在着一定的距离。王阳明有句话说：“知之真切笃实处即是行，行之明觉精察处即是知。”，我们下一个目标就是将所学所用付诸于实践，在未来，我们通过点滴的不断的改变不足之处、实践、调整、反思、再实践，团队最终肯定会实现规范的、适合团队的、有效的敏捷开发。","categories":[{"name":"工作","slug":"工作","permalink":"http://www.chengkangjian.com/categories/工作/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://www.chengkangjian.com/tags/敏捷开发/"},{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"}]},{"title":"终身受用的世界顶尖思维","slug":"终身受用的世界顶尖思维","date":"2017-03-10T14:08:46.000Z","updated":"2019-06-18T13:49:56.736Z","comments":true,"path":"2017/03/10/终身受用的世界顶尖思维/","link":"","permalink":"http://www.chengkangjian.com/2017/03/10/终身受用的世界顶尖思维/","excerpt":"","text":"1 素养蓝斯登原则：在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。 提出者：美国管理学家蓝斯登。 点评：进退有度，才不至进退维谷;宠辱皆忘，方可以宠辱不惊。 卢维斯定理：谦虚不是把自己想得很糟，而是完全不想自己。 提出者：美国心理学家h.卢维斯。 点评：如果把自己想得太好，就很容易将别人想得很糟。 托利得定理：测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想而无碍于其处世行事。 提出者：法国社会心理学家h.m.托利得。 点评：思可相反，得须相成。 2 统御刺猬理论：刺猬在天冷时彼此靠拢取暖，但保持一定距离，以免互相刺伤。 点评：保持亲密的重要方法，乃是保持适当的距离。 鲦鱼效应：鲦鱼因个体弱小而常常群居，并以强健者为自然首领。将这条首领鲦鱼脑后控制行为的部分割除后，此鱼便失去自制力，行动也发生紊乱，但其他鲦鱼却仍像从前一样盲目追随。 提出者：德国动物学家霍斯特。 点评： 1、下属的悲剧总是领导一手造成的。 2、下属觉得最没劲的事，是他们跟着一位最差劲的领导。 雷鲍夫法则：在你着手建立合作和信任时要牢记我们语言中： 1、最重要的八个字是：我承认我犯过错误。 2、最重要的七个字是：你干了一件好事! 3、最重要的六个字是：你的看法如何? 4、最重要的五个字是：咱们一起干! 5、最重要的四个字是：不妨试试! 6、最重要的三个字是：谢谢您! 7、最重要的两个字是：咱们。 8、最重要的一个字是：您。 提出者：美国管理学家雷鲍夫。 点评：记住经常使用，它会让你事半功倍。 洛伯定理：对于一个经理人来说，最要紧的不是你在场时的情况，而是你不在场时发生了什么。 提出者：美国管理学家r.洛伯。 点评：如果只想让下属听你的，那么当你不在身边时他们就不知道应该听谁的了。 3 沟通斯坦纳定理：在哪里说得愈少，在那里听到的就愈多。 提出者：美国心理学家s.t.斯坦纳。 点评：只有很好听取别人的，才能更好说出自己的。 费斯诺定理：人两只耳朵却只有一张嘴巴，这意味着人应该多听少讲。 提出者：英国联合航空公司总裁兼总经理l.费斯诺。 点评：说得过多了，说的就会成为做的障碍。 牢骚效应：凡是公司中有对工作发牢骚的人，那家公司或老板一定比没有这种人或有这种人而把牢骚埋在肚子里公司要成功得多。 提出者：美国密歇根大学社会研究院 1、牢骚是改变不合理现状的催化剂。 2、牢骚虽不总是正确的，但认真对待牢骚却总是正确的。 避雷针效应：在高大建筑物顶端安装一个金属棒，用金属线与埋在地下的一块金属板连接起来，利用金属棒的尖端放电，使云层所带的电和地上的电逐渐中和，从而保护建筑物等避免雷击。 点评：善疏则通，能导必安。 4 协调氨基酸组合效应：组成人体蛋白的8种氨基酸，只要有一种含量不足，其他7种就无法合成蛋白质。 点评：当缺一不可时，一就是一切。 米格-25效应：前苏联研制的米格-25喷气式战斗机的许多零部件与美国的相比都落后，但因设计者考虑了整体性能，故能在升降、速度、应急反应等方面成为当时世界一流。 点评：所谓最佳整体，乃是个体的最佳组合。 磨合效应：新组装的机器，通过一定时期的使用，把磨擦面上的加工痕迹磨光而变得更加密合。 点评：要想达到完整的契合，须双方都做出必要的割舍。 5 指导波特定理：当遭受许多批评时，下级往往只记住开头的一些，其余就不听了，因为他们忙于思索论据来反驳开头的批评。 提出者：英国行为学家l.w.波特 点评：总盯着下属的失误，是一个领导者的最大失误。 蓝斯登定律：跟一位朋友一起工作，远较在父亲之下工作有趣得多。 提出者：美国管理学家蓝斯登 点评：可敬不可亲，终难敬;有权没有威，常失权。 吉尔伯特法则：工作危机最确凿的信号，是没有人跟你说该怎样做。 提出者：英国人力培训专家b.吉尔伯特 点评：真正危险的事，是没人跟你谈危险。 权威暗示效应：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖15秒后，前排学生即举手，称自己闻到臭气，而后排的人则陆续举手，纷纷称自己也已闻到，其实瓶中什么也没有。 点评：迷信则轻信，盲目必盲从。 6 组织奥尼尔定理：所有的政治都是地方的。 提出者：美国前众议院院长奥尼尔 点评：只有能切身体会到的，群众才认为那是真实的。 定位效应：社会心理学家曾作过一个试验：在召开会议时先让人们自由选择位子，之后到室外休息片刻再进入室内入座，如此五至六次，发现大多数人都选择他们第一次坐过的位子。 点评：凡是自己认定的，人们大都不想轻易改变它。 艾奇布恩定理：如果你遇见员工而不认得，或忘了他的名字，那你的公司就太大了点。 提出者：英国史蒂芬。约瑟剧院导演亚伦。 点评：摊子一旦铺得过大，你就很难把它照顾周全。 7 培养吉格勒定理：除了生命本身，没有任何才能不需要后天的锻炼。 提出者：美国培训专家吉格•吉格勒 点评：水无积无辽阔，人不养不成才。 犬獒效应：当年幼的藏犬长出牙齿并能撕咬时，主人就把它们放到一个没有食物和水的封闭环境里让这些幼犬自相撕咬，最后剩下一只活着的犬，这只犬称为獒。据说十只犬才能产生一只獒。 点评：困境是造就强者的学校。 8 选拔近因效应：最近或最后的印象对人的认知有强烈的影响。 提出者：美国社会心理学家洛钦斯。 点评：结果往往会被视为过程的总结。 酒井法则：在招工时用尽浑身解数，使出各种方法，不如使自身成为一个好公司，这样人才自然而然会汇集而来。 提出者：日本企业管理顾问酒井正敬。 点评：不能吸引人才，已有的人才也留不住 美即好效应：对一个外表英俊漂亮的人，人们很容易误认为他或她的其他方面也很不错。 提出者：美国心理学家丹尼尔•麦克尼尔。 点评：印象一旦以情绪为基础，这一印象常会偏离事实。 9 任用奥格尔维法则：如果我们每个人都雇用比我们自己都更强的人，我们就能成为巨人公司。 提出者：美国奥格尔维。马瑟公司总裁奥格尔维。 点评：如果你所用的人都比你差，那么他们就只能做出比你更差的事情。 皮尔卡丹定理：用人方面一加一不等于二，搞不好等于零。 提出者：法国著名企业家皮尔•卡丹。 点评：组合失当，常失整体优势，安排得宜，才成最佳配置。 10 激励马蝇效应：再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。 点评：有正确的刺激，才会有正确的反应。 倒u形假说：当一个人处于轻度兴奋时，能把工作做得最好。当一个人一点儿兴奋都没有时，也就没有做好工作的动力了;相应地，当一个人处于极度兴奋时，随之而来的压力可能会使他完不成本该完成的工作。 世界网坛名将贝克尔之所以被称为常胜将军，其秘诀之一即是在比赛中自始至终防止过度兴奋，而保持半兴奋状态。所以有人也将倒u形假说称为“贝克尔境界”。 提出者：英国心理学家罗伯特•耶基斯和多德林。 点评： 1、激情过热，激情就会把理智烧光。 2、热情中的冷静让人清醒，冷静中的热情使人执着。 11 调研特伯论断：在数字中找不到安全。 提出者：美国经济学家w.s.特伯。 点评：数字是死的，情况是活的。 摩斯科定理：你得到的第一个回答，不一定是最好的回答。 提出者：美国管理学家r.摩斯科。 点评：刨根得根，问底知底。 12 预测罗杰斯论断：成功的公司不会等待外界的影响来决定自己的命运，而是始终向前看。 提出者：美国IBM公司前总裁p.罗杰斯。 点评：只想随波逐流，难有理想彼岸。 萨盖定律：戴一块手表的人知道准确的时间，戴两块手表的人便不敢确定几点了。 提出者：英国心理学家p.萨盖。 点评：若选错误参照，必无正确比较。 隧道视野效应：一个人若身处隧道，他看到的就只是前后非常狭窄的视野。 点评： 1、不拓心路，难开视野。 2、视野不宽，脚下的路也会愈走愈窄。 13 目标巴菲特定律：在其他人都投了资的地方去投资，你是不会发财的。 提出者：美国股神巴菲特。 点评： 1、善于走自己的路，才可能走别人没走过的路。 2、特色不特，优势无优。 古特雷定理：每一处出口都是另一处的入口。 提出者：美国管理学家w.古特雷。 点评：上一个目标是下一个目标的基础，下一个目标是上一个目标的延续。 14 计划列文定理：那些犹豫着迟迟不能作出计划的人，通常是因为对自己的能力没有把握。 提出者：法国管理学家p.列文。 点评：如果没有能力去筹划，就只有时间去后悔了。 弗洛斯特法则：在筑墙之前应该知道把什么圈出去，把什么圈进来。 提出者：美国思想家w.p.弗洛斯特 点评：开始就明确了界限，最终就不会作出超越界限的事来。 15 参谋波克定理：只有在争辩中，才可能诞生最好的主意和最好的决定。 提出者：美国庄臣公司总经理詹姆士•波克。 点评：无磨擦便无磨合，有争论才有高论。 韦奇定理：即使你已有了主见，但如果有十个朋友看法和你相反，你就很难不动遥 提出者：美国洛杉矶加州大学经济学家伊渥•韦奇。 点评： 1、未听之时不应有成见，既听之后不可无主见。 2、不怕开始众说纷纭，只怕最后莫衷一是。 16 决策福克兰定律：没有必要作出决定时，就有必要不作决定。 提出者：法国管理学家d.l.福克兰。 点评：当不知如何行动时，最好的行动就是不采取任何行动。 王安论断：犹豫不决固然可以免去一些做错事的机会，但也失去了成功的机遇。 提出者：美籍华裔企业家王安博士。 点评：寡断能使好事由好变坏，果断可将危机转危为安。 17 执行格瑞斯特定理：杰出的策略必须加上杰出的执行才能奏效。 提出者：美国企业家h.格瑞斯特。 点评：好事干实更好，实事办好愈实。 吉德林法则：把难题清清楚楚地写出来，便已经解决了一半。 提出者：美国通用汽车公司管理顾问查尔斯•吉德林。 点评：杂乱无章的思维，不可能产生有条有理的行动。 18 信息沃尔森法则：把信息和情报放在第一位，金钱就会滚滚而来。 提出者：美国企业家s.m.沃尔森。 点评：你能得到多少，往往取决于你能知道多少。 塔马拉效应：塔马拉是捷克雷达专家弗。佩赫发明的一种雷达，它与其他雷达的最大不同是不发射信号而只接收信号，故不会被敌方反雷达装置发现。 点评：善藏者人不可知，能知者人无以藏。 19 监督小池定理：越是沉醉，就越是抓住眼前的东西不放。 提出者：日本管理学家小池敬。 点评：自我陶醉不易清醒，自以为是不喜批评。 赫勒法则：当人们知道自己的工作成绩有人检查的时候会加倍努力。 提出者：英国管理学家h.赫勒。 点评：只有在相互信任的情况下，监督才会成为动力。 来源：TED演讲","categories":[{"name":"工作","slug":"工作","permalink":"http://www.chengkangjian.com/categories/工作/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://www.chengkangjian.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"}]},{"title":"Javascript 安全类型监测","slug":"javascript-safe-type-check","date":"2017-02-13T08:41:27.000Z","updated":"2019-06-18T13:37:18.809Z","comments":true,"path":"2017/02/13/javascript-safe-type-check/","link":"","permalink":"http://www.chengkangjian.com/2017/02/13/javascript-safe-type-check/","excerpt":"","text":"数据类型检测ECMAScript 有五种简单的数据类型，分别为 Undefined、Null、String、Number、Boolean，还有一个复杂的数据类型 Object。ECMAScript 的语言的动态性意味着我们可以使用以上 6 种数据类型表示任何数据。 因为数据类型是松散的，所以我们需要一些手段来准确的检测给定变量的数据类型。 typeoftepeof 是检测基本数据类型的好手，他有六种检测结果，分别是 Undefined、Object、Function、String、Number、Boolean,所以它是判断一个变量是：未定义值、对象、函数、字符串、数值、布尔值的最佳工具。 123456789typeof undefined //\"undefined\"typeof &#123;&#125; //\"object\"typeof function()&#123;&#125; //\"function\"typeof '' //\"string\"typeof 1 //\"number\"typeof true //\"boolean\"typeof null //\"object\"typeof [] //\"object\" 从上面可以看出 typeof 虽然是检测基本数据类型的好手，但是在检测引用类型的数据时就力不从心了，下面会提到如何检测引用数据类型。另外还有个问题值得思考： 为什么null的检测类型是Object？ 看书中对 null 的描述： The value null represents the intentional absence of any objectvalue 首先，null 是一个原始值。关于 typeof null //&quot;object&quot; 的结果，从一开始出现 JavaScript 就是这样的。 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针(大多数平台下值为 0x00)，因此，null 的类型标签也成为了 0，typeof null 就错误的返回了”object”.(referenc) 据说该问题在 ECMAScript 6 中提出typeof null === &#39;null&#39;的讨论 (该提议已被否决)。 安全类型检测javascript 内置的类型检测机制并非完全可靠。比如 typeof 操作符，由于一些无法预知的行为，会得到不靠谱的结果。instanceof 存在于多个作用域的情况，通过下面的方式检测数组： var isArray = value instanceof Array 以上代码若返回 true，value 必须是一个数组，而且必须与 Array 构造函数处于同一个作用域中。如果 value 是别的框架定义的数组，以上的代码又可能会返回 false。 如何解决上述问题上述解决的办法都一样，在任何值上调用 Object 原生的 toString 方法时，都会返回一个类似于［object NativeConstructorName］格式的字符串，比如： Object.prototype.toString.call([&#39;&#39;]) //&quot;[object Array]&quot; 由于原生数组的构造函数名和全局作用域无关，因此使用 toString 就能返回一致的值。利用这点可以创建以下函数： 123456789101112131415function isArray(value) &#123; return Object.prototype.toString.call(value) == \"[object Array]\";&#125;function isFunction(value) &#123; return Object.prototype.toString.call(value) == \"[object Function]\";&#125;function isRegExp(value) &#123; return Object.prototype.toString.call(value) == \"[object RegExp]\";&#125;function isNativeJSON(value) &#123; return window.JSON&amp;&amp;Object.prototype.toString.call(value) == \"[object JSON]\";&#125; 需要注意的一点是，Object.prototype.toString() 本身也会被修改，本文讨论的仅仅是该方法未被修改的情况下。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"}]},{"title":"解决 git bash 不重复输入账号密码","slug":"git-not-repeat-put-password","date":"2016-10-19T05:06:40.000Z","updated":"2019-06-18T13:28:39.695Z","comments":true,"path":"2016/10/19/git-not-repeat-put-password/","link":"","permalink":"http://www.chengkangjian.com/2016/10/19/git-not-repeat-put-password/","excerpt":"","text":"1 寻找并编辑 .git-credentials 文件在%HOME%目录中，一般为 C:\\users\\Administrator，也可以是你自己创建的系统用户名目录，反正都在 C:\\users\\ 中。文件名为 .git-credentials ,由于在 Window 中不允许直接创建以”.” 开头的文件，所以需要借助 git bash 进行，打开 git bash 客户端，进行 %HOME% 目录，然后用 touch 创建文件 .git-credentials, 用 vim 编辑此文件，输入内容格式： 12345touch .git-credentialsvim .git-credentialshttps://&#123;username&#125;:&#123;password&#125;@github.com 2 添加 Git Config 内容进入git bash终端， 输入如下命令： 1git config --global credential.helper store 执行完后查看%HOME%目录下的 .gitconfig 文件，会多了一项： 12[credential]helper = store 重新开启 git bash 会发现 git push 时不用再输入用户名和密码","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.chengkangjian.com/tags/git/"}]},{"title":"回顾老男孩","slug":"dream","date":"2016-09-22T16:55:17.000Z","updated":"2019-06-18T12:20:08.232Z","comments":true,"path":"2016/09/23/dream/","link":"","permalink":"http://www.chengkangjian.com/2016/09/23/dream/","excerpt":"","text":"老男孩是在高二的时候语文老师在全班同学面前播放的一部微电影，当时看的感觉更多是有点意思，没有太多的伤感和感动。今天是大学毕业的第一年，恍然已经六年过去了，今天晚上突然有点怀旧，再次回顾这部微电影，就差稀里糊涂的哭出来了，整个心都酥了，都软了。 现在想来，QQ 空间的说说有一年多没有更新了，我也从曾经的个性张扬，调皮的学生转变为了一名职业人士，开始了自己的职业生活。曾经的老同学不知道会在什么时候突然联系一下，也都有各自的生活了吧，相见不如怀念，让自己更好是现在的最重要的事吧。 审视一下自己的青春，觉得自己的幸运的，犯过无数的错误却总是有改正的机会；经历了老师眼中好学生与坏学生的模样；惹出过很多争议；也曾经失去过自己，又找回了自己；曾经束缚过自己，也在后来找回了自由；身边的朋友有学霸也有学渣；我也算一朵奇葩吧，这一路走来，幸运，感恩！ 我现在也是在从小男孩转变为老男孩的路上，怀揣着自己的梦想，在追求自我实现的路上；生活确实是一把无情的刻刀，改变了我的模样，不变的是依然怀有梦想。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"}]},{"title":"互联网时代(再构)hexo观后感","slug":"internet","date":"2016-09-17T14:49:00.000Z","updated":"2019-06-18T13:29:12.955Z","comments":true,"path":"2016/09/17/internet/","link":"","permalink":"http://www.chengkangjian.com/2016/09/17/internet/","excerpt":"","text":"每一次看过视频后都很有启发，这一次也不例外，互联网再构这部视频用了四十分钟全面而详细的向我们阐述了再构的一前一后。 理解再构，顾名思义，再构就是再一次构建，是指互联网时代的到来，其影响不仅仅是局限于科技，局限于技术，局限于社会表面，其对我们的生活的影响是彻底的，巨大的，从菲特台风的案例，黄灯的故事，李明博事件，可汗学院的建立，奥巴马选举的成功等实例都反映了互联网影响的是人与人之间，人与权利之间，人与社会之间，人与人周围的一切关系。 就像视频中说的那样，一就是无限，每一个声音都面对着世界，每一滴水珠都等同于大海。 这要求我们要不断的学习，要与时俱进，顺势而为，在互联网时代的浪潮里构建的新的社会体系中更好的存活。","categories":[{"name":"工作","slug":"工作","permalink":"http://www.chengkangjian.com/categories/工作/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://www.chengkangjian.com/tags/思考/"},{"name":"互联网","slug":"互联网","permalink":"http://www.chengkangjian.com/tags/互联网/"}]},{"title":"javascript-Array 引用类型用法总结","slug":"javascript-array","date":"2016-09-16T16:56:47.000Z","updated":"2019-06-18T13:44:27.411Z","comments":true,"path":"2016/09/17/javascript-array/","link":"","permalink":"http://www.chengkangjian.com/2016/09/17/javascript-array/","excerpt":"","text":"引用类型-Array类型引用类型是一种数据结构，用于将数据和功能联系起来。 创建对象的方式： new操作符 1var array = new Array() 字面量表示法创建 1var array = [] Array1.检测数组:检测数组是基本类型还是引用类型 2.转换方法:将数组转换成字符串或数组对象 3.栈方法:后进先出的操作数组的方法 4.队列方法:先进先出的操作数组的方法 5.操作方法:数组的拼接、截取、插入、删除、替换 6.位置方法:查找数组项、返回索引值 7.迭代方法:对每个数组项进行操作的方法 8.缩小方法:操作数组的每一项，构建最终的返回值 1 检测数组 检测数组的方法；instanceof 操作符的问题是当开发环境引入多个框架存在多个全局环境的时候，会出现不同的 Array 构造函数，进而出现不同的结果。Array.isArray() 这个方法很好的解决了这个问题。 arrayName instanceof Array 12var array = [1,2,3]console.log(array instanceof Array) // true Array.isArray(arrName) 1console.log(Array.isArray(array)) // true 2 转换方法 toString()：返回以逗号分隔拼接而成的字符串 valueOf()：返回对象 toLocaleString()：区别很小，如果是数组调用这个方法，那么数组的每一项都会调用这个方法 alert(value) == alert(value.toString()) 123456789var array = [1,2,3]var arrayToString = array.toString()var arrayValueOf = array.valueOf()var arrayToLocalString = array.toLocaleString()console.log(arrayToString) // 1,2,3console.log(arrayValueOf) // [1, 2, 3]console.log(arrayToLocalString) // 1,2,3 3 栈方法 (LIFO:last in first out) ES数组类似于数据结构的方法栈是一种限制插入和删除项的数据结构 push()：接收任意数量的参数添加至数组尾部，返回数组长度值 pop()：从数组末尾移除最后一项，减少数组的length值，返回该数组被删除的最后一项 4 队列方法 (FIFO:first in first out)结合 push() 和 shift() 方法可以实现像队列一样使用数组，使用 unshift() 和 pop() 可以从相反的方向模拟队列。 shift() 移除并返回该数组的第一项； unshift() 从数组前端添加任意个参数，并返回新数组的长度 5 操作方法 concat()复制原数组连接新数组形成新副本； 123var arr1 = ['q','w','e']var arr2 = ['h','u','o']document.write(arr1.concat(arr2)) //q,w,e,h,u,o slice() 有一个参数时，复制参数为起始位置到末尾的副本；有两个参数时，复制两个数字中间部分的数组项；如果参数是负数，复制用数组的长度加上负数值得到的两个参数之间的数组项； 1234var arr3 = ['h','e','l','l','o']console.log(arr3.slice(1)) // e,l,l,oconsole.log(arr3.slice(-4)) // e,l,l,oarr3.slice(-4) === arr3.slice(1) // true splice() 三个参数:分别对应起始位置，删除项的个数，替换项;通过对这三个参数的合理运用可以实现删除、插入、替换等操作。 1234567891011121314// 从第一项开始删除两项var splice_arr1 = ['h','e','l','l','o']console.log(splice_arr1.splice(1,2)) // 返回的是被删除的项组成的数组[\"e\", \"l\"]// 从第二项后插入三项oldvar splice_arr2 = ['h','e','l','l','o']var removed = splice_arr2.splice(2,0,\"K\",\"K\")console.log(splice_arr2)//[\"h\", \"e\", \"K\", \"K\", \"l\", \"l\", \"o\"]console.log(removed) // 返回的是一个空数组// 替换var removed = splice_arr3.splice(2,2,\"P\",\"P\")console.log(splice_arr3)//[\"h\", \"e\", \"P\", \"P\", \"o\"]console.log(removed) // 返回的是被替换的值[\"l\", \"l\"] 6 位置方法 返回索引值 indexOf() 从前往后找 lastIndexOf() 从后往前找 1234567891011// indexOf() 从前往后找// lastIndexOf() 从后往前找var index_arr = ['h','e','l','l','o']var indexOf_arr = index_arr.indexOf('l')console.log('原数组:',index_arr) // 原数组不变console.log('返回值:',indexOf_arr) // 返回值是第一个查到位置的索引值2var index_arr2 = ['h','e','l','l','o']var indexOf_arr2 = index_arr2.lastIndexOf('l')console.log('原数组:',index_arr2) // 原数组不变console.log('返回值:',indexOf_arr2) // 返回值是第一个查到位置的索引值3 7 迭代方法 接收两个参数，一个是函数，另一个是运行该函数的作用域对象。 第一个参数函数接收三个参数 数组项的值 item，值的位置 idnex ，数组本身 array every() 都是返回 true 则返回 true 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var everyArr = numbers.every(function(it, index ,arr)&#123; if(it&gt;9)&#123; return true &#125;&#125;)console.log(everyArr) // false some() 有一个返回 true，则返回 true 1234var someArr = numbers.some(function(it, index ,arr)&#123; return (it &gt; 9)&#125;)console.log(someArr) // true forEach() 没有返回值 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var forEachArr = numbers.forEach(function(it, index ,arr)&#123; var it = it*100 console.log(it)&#125;) // 无返回值 filter() 返回该函数会返回true的项组成的数组，用于过滤 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var filterArr = numbers.filter(function(it, index ,arr)&#123; if(it&gt;10)&#123; return it &#125;&#125;)console.log(filterArr) // [65, 33, 21, 23],返回返回值组成的新数组 map() 返回每个函数的返回值 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var mapArray = numbers.map(function(it, index ,arr)&#123; var it = it*100 return it&#125;)console.log(mapArray) // [100, 200, 300, 400, 500, 600, 700, 800, 900, 0, 900, 800, 700, 6500, 500, 400, 3300, 2100, 100, 100, 2300, 300, 400] 8 缩小方法：返回返回值组成的新数组 reduce() 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var allArray = numbers.reduce(function(prev,cur,index,arr)&#123; return (prev+cur)&#125;)console.log(allArray) // 229 reduceRight() 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var allArrayRight = numbers.reduceRight(function(prev,cur,index,arr)&#123; return (prev+cur)&#125;)console.log(allArrayRight) // 229 经过这次总结，对数组的操作更熟悉，觉得自己在以后再次遇到操作数组应该不需要再查文档了；","categories":[{"name":"技术","slug":"技术","permalink":"http://www.chengkangjian.com/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.chengkangjian.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://www.chengkangjian.com/tags/数组/"}]},{"title":"我应该开始写博客了","slug":"why","date":"2016-09-06T16:02:26.000Z","updated":"2019-06-18T12:22:02.034Z","comments":true,"path":"2016/09/07/why/","link":"","permalink":"http://www.chengkangjian.com/2016/09/07/why/","excerpt":"","text":"记得在大四毕业的前夕，我在知乎上提了一个问题“为什么每次想写东西的时候都无从下笔？”。总结知友的回答，再结合自己的感受，试图剖开内心的世界，认真的拷问自己最本质的想法，自问为什么写不出来，也许六耳的回答是自己的那个样子，之所以写不出来，不是真的写不出来，而是害怕写不出好的内容，害怕比较，害怕没人看，害怕写出来的东西被别人讥讽，被别人指指点点，再加上自己是一个好面的人，在那么多外在情绪的干扰下，写不出来是很正常的了。 大四毕业了，现在的我已经正式走上了谋生的道路，正式结束了十几年的学生身份，体会到了谋生的艰辛，生活的压力，身上的责任感。自己意外的成为了一个前端开发者，自然而然的就想为自己搭建一个博客用于记录自己的生活，记录自己的技术积淀，分享自己的生活感悟，分享自己的技术，分享自己的想法，因为互联网时代的本质就是分享，我也鼓励自己要克服害怕写东西，从这种消极情绪中积极的走出来，人生不也就是因为有了奋斗和与自己搏击的过程而显得刺激而有意义吗？ 我还希望通过在写博客的过程中，思考自己的生活，尽量站在客观的角度重新认识自己，进一步了解自己。我也搜索了相关为什么要写博客的文章，如“为什么你要写博客？”借鉴他们的想法之后愈加觉得自己开始做出这个选择的正确性，我要求自己要学习写作，记录想法的同时，要善于总结分享。","categories":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.chengkangjian.com/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://www.chengkangjian.com/tags/感悟/"}]}]}