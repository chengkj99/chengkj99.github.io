{"meta":{"title":"程是非sky","subtitle":"想象中的人是自己...","description":"一边奔跑 一边思考","author":"程康健","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2016-09-04T05:24:18.000Z","updated":"2017-08-15T06:10:35.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"网名：程是非sky 现居：北京 职业：编程 爱好：足球 音乐 梦想：艺术家 每一天都与自己在斗争，不是为了输赢，只是认真。"},{"title":"归档","date":"2017-02-14T10:12:09.000Z","updated":"2017-02-14T10:12:09.000Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-09-04T05:20:57.000Z","updated":"2017-02-05T07:24:26.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-09-04T05:18:59.000Z","updated":"2017-02-05T07:24:26.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"未知的花，魅知的旅","slug":"Capriccio-01","date":"2017-08-18T05:29:08.000Z","updated":"2017-08-23T12:28:55.000Z","comments":true,"path":"2017/08/18/Capriccio-01/","link":"","permalink":"http://yoursite.com/2017/08/18/Capriccio-01/","excerpt":"","text":"在听一首曲子《未知的花，魅知的旅》，有时候音乐的表达更能打动人心。 世界很喧嚣，社会很烦躁，当我带上了耳机，顿时，全世界与我无关。 这种感觉是幸福的。 于是：想到了下面的小诗： 你见，或者不见我， 我就在那里，不悲不喜； 你念，或者不念我， 情就在那里，不来不去； 你爱，或者不爱我， 爱就在那里，不增不减； 你跟，或者不跟我， 我的手就在你手里，不舍不弃； 来我的怀里， 或者， 让我住进你的心里。 默然，相爱；寂静，欢喜… 我喜欢用 省略号 给一首诗、一段话、一篇文章…作结尾。也喜欢用 省略号 给一个不知道想表达的情景作描述。 就像现在这样，这样…","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"Object.defineProperty 的使用总结","slug":"Object-defineProperty","date":"2017-08-16T13:37:02.000Z","updated":"2017-08-16T13:44:24.000Z","comments":true,"path":"2017/08/16/Object-defineProperty/","link":"","permalink":"http://yoursite.com/2017/08/16/Object-defineProperty/","excerpt":"","text":"Object.definedProperty The Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.Object.defineProperty可以在一个对象上定义一个新的属性，或修改一个已经存在的属性。并返回该对象。 简而言之，Object.defineProperty 是定义对象属性的方法。 平时我们通过以下的方式定义属性 123let o = &#123;&#125;o.a = &apos;apple&apos;o[&apos;b&apos;] = &apos;banana&apos; Object.defineProperty 算是第三种，这种方式比以上两种方式更加强大。 语法Object.defineProperty(obj, prop, descriptor) 参数 Object obj 目标对象 String prop 需要定义的属性 Object descriptor 该属性拥有的特性，可设置的值有： value 属性的值，默认为 undefined。 writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），默认为 false。 get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。 configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。 enumerable 是否能在for…in循环中遍历出来或在Object.keys中列举出来。默认为 false。 其中 Object descriptor 是需要重点关注的属性：writable只有设置为true可写，默认为false，false为不可写。12345678910111213141516171819// writable: falsevar o = &#123;&#125;Object.defineProperty(o , &apos;msg&apos;, &#123; value: &apos;hello&apos;, writable: false&#125;)console.log(o.msg) // helloo1.msg = &apos;world&apos;console.log(o.msg) // hello// writable: truevar o = &#123;&#125;Object.defineProperty(o , &apos;msg&apos;, &#123; value: &apos;hello&apos;, writable: true&#125;)console.log(o.msg) // helloo1.msg = &apos;world&apos;console.log(o.msg) // world configurable: 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，默认为 false。 1234567891011121314151617// configurable: falsevar o = &#123;&#125;Object.defineProperty(o , &apos;msg&apos;, &#123; value: &apos;hello&apos;, configurable: false&#125;)delete o.msgconsole.log(o.msg) //hello// configurable: truevar o = &#123;&#125;Object.defineProperty(o , &apos;msg&apos;, &#123; value: &apos;hello&apos;, configurable: true&#125;)delete o.msgconsole.log(o.msg) //undefined enumerable: true可枚举，false不可枚举，默认为false。 123456789101112131415161718192021var o = &#123;&#125;;Object.defineProperty(o, &apos;a&apos;, &#123; value: 1, enumerable: true&#125;)Object.defineProperty(o, &apos;b&apos;, &#123; value: 2, enumerable: false&#125;)Object.defineProperty(o, &apos;c&apos;, &#123; value: 3&#125;) // enumerable defaults to falseo.d = 4 // enumerable defaults to true when creating a property by setting itfor (var i in o) &#123; console.log(i);&#125;// a// d get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。set 一旦目标对象设置该属性，就会调用这个方法。默认为 undeinfed。下面是摘抄数据收集的案例：12345678910111213141516171819202122function archiver() &#123; var temperature = null var archive = [] Object.defineProperty(this, &apos;temperature&apos;, &#123; get () &#123; console.log(&apos;get&apos;) return temperature &#125;, set (value) &#123; temperature = value archive.push(&#123;val: temperature&#125;) &#125; &#125;) this.getArchive = function () &#123; return archive &#125;&#125;var a = new archiver()a.temperature // geta.temperature = 100 // 100a.temperature = 200 // 200a.getArchive() // [0:&#123;val: 100&#125;, 1:&#123;val: 200&#125;] 注意在 descriptor 中不能同时设置访问器 (get 和 set) 和 wriable 或 value，否则会报以下错误：1Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"心情","slug":"心情","date":"2017-08-16T02:00:00.000Z","updated":"2017-08-16T02:05:53.000Z","comments":true,"path":"2017/08/16/心情/","link":"","permalink":"http://yoursite.com/2017/08/16/心情/","excerpt":"","text":"梦想着有一天，可以，照顾好自己身边的人；顺便的，也成就着自己，过着简单的生活，偶尔会走进大自然感受最本真的世界。 想逃离浮华，不知道有没有办法。活在一个金钱主义的世界里，太难逃脱。 我的追求是放弃追求，明明是我不想追求，为什么我依然在追求…","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"},{"name":"我","slug":"我","permalink":"http://yoursite.com/tags/我/"}]},{"title":"不想失去的东西","slug":"不想失去的东西","date":"2017-08-15T05:30:18.000Z","updated":"2017-08-15T05:38:48.000Z","comments":true,"path":"2017/08/15/不想失去的东西/","link":"","permalink":"http://yoursite.com/2017/08/15/不想失去的东西/","excerpt":"","text":"小的时候，会有很多天马行空的想法，带着童真、好奇和爱好，可以写小诗，作曲，搞恶作剧… 那时也会有很大的勇气，甚至现在我都对过去自己 的勇气表示佩服，小学的时候和班里的同学一起罢课、打架； 高中的时候见到喜欢的女孩就追； 大学的时候和同学们一起创业； 直到来了北京， 现在除了工作中偶尔会需要勇气接受一些挑战性的工作项目之外，感觉勇气在消磨殆尽…","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"【转】陆奇最新演讲：如何成为一个优秀的工程师","slug":"luqispeech","date":"2017-07-14T08:51:34.000Z","updated":"2017-08-15T05:46:43.000Z","comments":true,"path":"2017/07/14/luqispeech/","link":"","permalink":"http://yoursite.com/2017/07/14/luqispeech/","excerpt":"","text":"一位工程师，如何才能称得上优秀？除了写得一手好Code，什么样的工作态度和方法才是一个优秀工程师的必备？ 7月11日，陆奇出席百度内部Engineering Leadership Talk。作为计算机科学博士及优秀的管理者，他提出的五点要求，对每一位百度工程师都适用。 &gt;“我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。”“有没有其他人已经解决这个问题？然后你可以把你的时间放在更好的创新上。”“做什么事情一定要做最好，一定要是做业界最强的。”“我把自己想象是一个软件、一个代码，今天的版本一定要比昨天版本好，明天的版本肯定会比今天好。”“看到问题也不要去问别人，就把它Fix。” 欲知是哪五点要求？请往下看👇 1 Believe in 技术首先要相信技术，我刚才已经讲了，整个我们工业界，特别是像百度这样的公司，对技术坚定的、不动摇的信念特别重要。 我也分享一下，盖茨提到微软公司的宗旨就是：写软件代表的是世界的将来。 为什么？未来任何一个工业都会变成软件工业。盖茨是对的，因为任何工业任何行业自动化的程度会越来越高，最后你所处理的就是信息和知识。 但现在软件的做法又往前提了一次，因为在人工智能时代，不光是写代码，你必须懂算法，懂硬件，懂数据，整个人工智能的开发过程有一个很大程度的提高，但是，技术，特别是我们这个工业所代表的技术一定是将来任何工业的前沿。 所以我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。 2 站在巨人的肩膀上做创新我们观察一下，在美国硅谷、在中国，互联网创业公司也好，大型公司也好，大家的起点是越来越高的。为什么现在创新速度那么快？主要是起点高了。我们可以使用的代码模块，使用的服务的能力，都是大大的提升。 在内部我想强调这一点，很多大公司包括微软在内，内部的Code都重做了无数遍。 我现在的要求是，每一次你写一行新的代码，第一要做的，先想一想你这行代码值得不值得写，是不是有人已经做了同样的工作，可能做得比你还好一点。有没有其他人已经解决这个问题，然后你可以把你的时间放在更好的创新上。 特别是大公司里面重复或者是几乎重复的Code实在太多，浪费太多的资源，对每个人的职业生涯都不是好事情。 我再强调，在大公司内部，你写代码之前想一想，你这行代码要不要写，是不是别人已经有了，站在别人的肩膀上去做这件事情。 3 追求Engineering Excellence我要另外强调的一点就是Engineering Excellence，工程的技术的卓越性和能力。 任何市场上竞争就像打仗一样，就看你的部队体能、质量，每一个士兵他的训练的程度，和你给他使机关枪、坦克，还是什么样的武器。 所以Engineering Excellence跟这个类比，我们要建的是一支世界上最强的部队，每一个士兵，每一个领军人，每个人的能力，他的训练都是超强的，然后我们给每个人提供的工具和武器都是一流的。 所以Engineering Excellence是一个永无止境的、个人的、团队的，能力的追求和工具平台的创新，综合在一起可以给我们带来的长期的、核心的竞争力，为社会创造价值，最终的目的是给每个用户、每个企业、整个社会创造价值。 我另外还要在这里强调的一点就是Relentless pursuit of excellence：永无止境的不断的持续的追求。 我们要么不做，要做的事情一定做最好，这是我对大家的要求。数据库也好，做大平台也好，大数据也好，我们要做什么事情，我们一定要下决心，这是我对你们每个人的要求，做什么事情一定要做最好，一定要是做业界最强的。 4 每天学习每天学习，可能是对每个人都是最最重要的。 我今天分享一下，我自己怎么想我自己的。就很简单一个概念，我把自己想象是一个软件、一个代码，今天的版本一定要比昨天版本好，明天的版本肯定会比今天好，因为即使犯了错误，我里面有If statement，说如果见到这个错误，绝对不要再犯。 英语，另外有一句说法就是Life is too short, don’t live the same day twice. 同样一天不要重活两次。每天都是不一样，每天为什么不一样，因为每天都变成最好，每天都变得更好。今天的版本一定要比昨天好，每个好的、杰出的工程师，杰出的技术领袖，一定要保持自己学习的能力，特别是学习的范围。 在这上面我也稍微引申一下，做Computer science的，如果只学Computer science，不去学一些其他的行业，肯定不够。我举个例子，经济学必须要学。为什么这样讲？Computer science它有个很大的限制，他是假定你有输入以后有输出，这种解决问题的方式有它的好处，但有它的限制性。 我给大家举个例子，地图导航，如果你纯粹用这个方式去做，你只是把一个拥挤的地方移到另外一个拥挤的地方。经济学，它对问题的建模是不一样的。它起点是假定是一个整体的一个生态，每个人的输入都是另外一个人的输出，你要用经济学的方式来描述地图导航的问题，你就会去算一个Equilibrium，市场也是这样。 如果把深度学习真的要想彻底，必须把物理重学一遍，把生物学看一遍，再把进化论再看一遍。因为深度学习跟这些东西完全相关，自己肯定想不清楚，要彻底想清楚，必须学。 另外，学产品，我以前跟所有的工程师都讲，如果不懂产品，你不可能成为一个最好的工程师。真正要做世界一流的工程师不光要懂产品，还要懂整个商业，懂生态。因为你的工作的责任，是能够看到将来，把技术展望到将来的需求，把平台、把开发流程、把你的团队为将来做准备。所以学习是非常非常重要的。 5 Ownership最后是从我做起。 我们公司有个非常大的使命，用科技让复杂的世界更简单。整个世界非常非常复杂，人其实所做的事情基本上都是Reduce entropy。 因为从热力学第二定律来讲，世界是会变得越来越乱的，我们想做的事情就是把它变的更简单，让我们生活变得更美好。 而且具体的，我们可以通过人工智能技术来做到唤醒万物，但是这一切是通过每一个人的一点一滴的行为累计起来，从我做起。还有Ownership，看到机会不需要问别人，有机会就去做，看到问题也不要去问别人，就把它Fix。 把我们的使命、把我们的公司当成我们自己每个人的事业来做，我可以坦诚的给每个人讲，如果你把公司的使命，把公司的事业，当成你自己个人的事业，Own everything，你在职业生涯一定是走得最快。从我做起，从身边的每一件事情做起。","categories":[],"tags":[{"name":"转发 成长","slug":"转发-成长","permalink":"http://yoursite.com/tags/转发-成长/"}]},{"title":"尤雨溪知乎Live总结 下篇","slug":"evan-you-live-pro","date":"2017-06-05T12:04:38.000Z","updated":"2017-06-05T12:10:44.000Z","comments":true,"path":"2017/06/05/evan-you-live-pro/","link":"","permalink":"http://yoursite.com/2017/06/05/evan-you-live-pro/","excerpt":"","text":"状态管理flux、redux、vuex、mobx、Rx.js… 本质：从源事件映射到状态的迁移（改变），映射到UI的改变。按钮 --1--&gt; 状态 --2--&gt; UI 声明式渲染解决了从状态到UI的映射 状态管理解决的是事件到状态的映射，将这部分代码抽离出来，管理好，维护好，是状态管理工具做的事情。 redux和mobx体现两种截然不同的思维方式或者说范式，redux强调数据不改变，reducer拿到原来的state和action返回的是一个新的state。mobox和vue中数据是可变的。 把 Vue 当 redux 用让 Vue 当 MobX 用 这些方案都没有回答如何处理异步，mobx和vuex的异步处理，就是你在action里想怎么搞怎么搞。 一般的CRUD操作，不存在太复杂的异步，杀鸡不用牛刀。如果遇到复杂的场景，如服务端推送、实时、同时请求。，可以考虑Rx.js处理，Rx.js最适合处理事件流。Rx.jsCycle.js 状态的改变在vuex这些工具中需要在mutation中写出来。如果在使用Rx.js的场景下，直接从事件源，映射到结果。其中为代表的是Cycle.js，从头到尾就是一个流，从获取事件是一个流、到状态改变是一个流、到更新dom是一个流。 组件状态和全局状态如何区分，至今也没有一个好的区分方案。 路由传统的路由思想，比较早的是从Ember.js这个框架中出现单页应用的路由。自从react和vue这些框架出现以后，会发现，把组件和路由解耦是可行的，而且更加灵活，另一个启示是从组件出发思考，路由就是将url映射到组件的一个过程。 url到组件的映射，从url出发还是状态出发，其实url就是一个状态。这样的话，一个简单的路由，就是一个动态组件，在vue里面就是component is，在react里就是一个对象表，通过key去渲染。那是一个假象，完整的路由系统要考虑：hash模式和history模式兼容、懒加载、钩子、跳转…其实这是有些复杂度的。 react-router4是一个去中心化的路由方案，类似通过功能性组件（组件做路由）实现。 Web路由和APP路由区别:切换方式的区别 Web路由：二级切换，切换即替换APP路由：卡碟式切换，切换即覆盖 CSS方案主流的 CSS 方案 跟 JS 完全解耦，靠预处理器和比如 BEM 这样的规范来保持可维护性，偏传统 CSS Modules，依然是 CSS，但是通过编译来避免 CSS 类名的全局冲突 （命名随机化避免命名冲突） 各类 CSS-in-JS 方案，React 社区为代表，比较激进 Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面），一种比较折中的方案 比较要结合场景在单页应用的场景下，使用BEM相当于平行的维护了两套结构，一套是组件结构，一套是规范结构。将两者统一是比较好的方案。 css in jshttps://medium.com/seek-blog/a-unified-styling-language-d0c208de2660 https://medium.com/seek-blog/a-unified-styling-language-d0c208de2660 传统 css 的一些问题： 作用域 （解决的已经很好了，css module， inline sytle ，vue scoped） Critical CSS （仅导出页面相对应的css代码，不加载不必要的css代码） Atomic CSS （减小体积） 分发复用 跨平台复用 css in js 通过运行时能较好的解决问题2。 在vue里 使用CSS Modules 会不会比 使用 scoped 好？没有本质区别，scoped成本更低，但是导出的页面更大。css module一定程度运行时的代价，因为需要动态的class绑定，区别不大。 Atomic CSS：原子类css，将公共的共享的样式类抽象成原子类，最终的体积会比较小。分发复用：css in js都是javascript,可以像普通javascript一样分发的npm上进行复用：其实css放到包里也可以发布到npm上进行复用的，不算是个大优势。跨平台复用：css in js跨平台复用，其实css 也可以pass成javascript进行跨平台复用的。 这个方案，不一定好，态度保留。 构建工具出现背景：平台越来越强 要求越来越高 任务复杂度 工具复杂度 构建工具解决的其实是几方面的问题： 任务的自动化 开发体验和效率（新的语言功能，语法糖，hot reload 等等） 部署相关的需求 编译时优化 grunt - gulp - webpack - rollup - systemjs，这些构建工具中，主打一切皆模块的webpack脱颖而出。 大多数情况下 npm script + webpack 组合就可以了。 最终代码跑在浏览器里，这个限制要求我们必须构建，因为我们没有浏览器的控制权。 现在前端的构建工具链很完善了。html 、css 、js 都有自己的构建工具，只需写转换规则就好。 关于部署的一个文章 部署优化：请求合并（打包），静态资源路径映射，小尺寸资源内联，代码分割、时间戳。webpack复杂是因为解决的问题本来就很复杂。rollup简单优雅，因为做的事情简单。 构建时优化 服务端数据通信restful api ==&gt; crud 实时数据库firebase、horizon ==&gt; 数据实时性 数据关联性 graphQL:暴露一个接口，急于图的查询而不是表，对复杂关联数据的获取，数数据量的优化也更加精确。 服务端的数据是否应该放在store里面去？有些多此一举，因为改还是需要通过接口改。 跨平台渲染React native 、 Weex本质：设计框架的时候，框架的渲染机制和dom解耦。ReactNative 针对每一个平台设计渲染引擎。 新规范Web Component webassembly 总结我们聊了很多东西，可能比较杂，但我希望大家发现其中一些共性的东西：技术方案都是先有问题，再有思路，同时伴随着取舍。在选择衡量技术的时候，尽量去思考这个技术背后是在解决什么问题，它做了怎样的取舍。这样一方面可以帮助我们更好的理解和使用这些技术，也为以后哪天你遇到业务中的特殊情况，需要自己做方案的时候打好基础。 问题关于react和vue具体的技术选型能举个例子来说明这两个框架所适用的场景吗？适用场景几乎差不多。 对于前端框架的学习需要到什么程度才算比较好？熟悉源码？理解思想？还是其他什么？理解思想更重要，学习源码，吸收设计原理和方案对做业务没啥帮助。 vue现在一直在推后端渲染的模式，是为了seo么？现在前端的性能在不断提高，不是应该前端渲染的发展趋势更好么？TTC 直出的价值 让用户早一点再早一点看到界面 现在HTTP/2越来越普及，前端构建工具在针对HTTP/2上怎么去找一个平衡点呢？实际测量才能有的谈","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"尤雨溪知乎Live总结 上篇","slug":"evan-you-live","date":"2017-06-05T11:55:59.000Z","updated":"2017-06-05T12:10:46.000Z","comments":true,"path":"2017/06/05/evan-you-live/","link":"","permalink":"http://yoursite.com/2017/06/05/evan-you-live/","excerpt":"","text":"开篇框架的比较，不谈场景都是刷流氓：不同的场景，不同的开发者爱好会产生不同的需求，多种方案的并存是必然和优异的。 针对不同的场景、框架背后需要解决的问题、结合经验选择框架。 组件现在所有的框架都已经支持组件化的开发方式。最初是已页面作为开发单位，html、css、js，当时我们的思维方式就是那样。后来我们的前端开发从页面转变为了应用。应用就会有模块封装和切分的需求，很快我们发现应用是可以拆分为组件树的，这是偏展示的一个理解，react的出现揭示了一个事实，就是组件可以是函数。 想象一下，整个应用是一个大的函数，函数里面可以调用别的函数，每个组件是一个函数，一个组件可以调用别的函数，返回viture dom,这突破了我们原来对静态页面的理解方式。但是这种简单的函数式的组件在实际应用过程中是不够的，所以react默认的组件形式里有了state，然后外面用class来包装等等。 组件可以分为四类： 纯展示组件 接入性组件container（会和数据层的serverce打交道） 交互型组件（比如各类加强版的表单组件，通常强调复用） 功能型组件（组件本身不渲染任何内容，作为功能扩展而存在比如 &lt;router-view&gt;，&lt;transition&gt;，作为一种扩展、抽象机制存在。） template和jsx的对比：jsx在写功能性组件的时候，是非常方便的，因为其继承了javascript语言的灵活性，是远超模版的。template在写纯展示型组件的时候是非常方便的。 colocation含义: 把应该放一起的东西放一起，比如vue的单文件把 style 、script 、 template 放一起。（以前是以语言为单位进行切分） 变化侦测和渲染机制Declarative Programming 声明式编程告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。（react、vue等框架的方式，直接描述dom和数据的关系就可以了，这就是数据驱动。）1234567&lt;!--声明式风格--&gt;&lt;!--只需声明你要啥--&gt;var numbers = [1,2,3,4,5]var doubled = numbers.map (function (n) &#123; return n * 2&#125;)console.log (doubled) //=&gt; [2,4,6,8,10] Imperative Programming 命令式编程命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 （jquery直接干的方式） 123456789&lt;!--命令式风格--&gt;&lt;!--需要干事情--&gt;var numbers = [1,2,3,4,5]var doubled = []for(var i = 0; i &lt; numbers.length; i++) &#123; var newNumber = numbers[i] * 2 doubled.push (newNumber)&#125;console.log (doubled) //=&gt; [2,4,6,8,10] view = render(state)render就是react里jsx中的render函数，其实vue的template最终也是编译成一个个render函数的。模版本身和jsx和本质上相似的，他们的输入都是state，输出都是dom。 Virtual DOM底层实现可以是Virtual DOM，也可以是细粒度的绑定等等。 一直有一个疑问，以前 被人诟病，为啥 vue 的声明式写法就是推崇的？onclick绑定的作用域是全局的，造成了环境污染，裸写的函数完全不知道是被哪个dom引用。vue中的绑定是局部作用域，而且javascript的逻辑是放在组件里的，符合colocation的理念，这样就很好维护了。 变化侦测Reactivity in Frontend JavaScript Frameworks 变化侦测有两种方式：pull 和 push react的setState和angular的脏检查属于pull的方式。 pull的方式，系统不知道数据什么时候变化，那么它需要一个信号告诉他说知道数据有可能变了，这个时候系统来进行一个暴力的比对，react通过Virtual DOM中的diff方式，angular是脏检查。能过这么做是因为javascript已经足够快，有浪费但是可以接受。 push的方式，Vue （响应式）和 Rx.js（abzrable） 的方式，更加细粒度的更新，但是同样也会带来内存和性能的开销。 vue2选择了相对折中的方案，在组件层面，vue2使用的是pull的方式，每一个组件都是响应式的watcher，这样vue能够知道哪些组件内部的状态发生了变化，然后在组件内部使用push的方式通过virtual Dom进行比对更新。 pull和push的对比，不能说哪个方案一定好，本质区别是用侦测成本换取自动优化的成本。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"【翻译】什么是Rest API？","slug":"what-is-a-rest-apis","date":"2017-05-15T06:11:56.000Z","updated":"2017-06-05T12:14:51.000Z","comments":true,"path":"2017/05/15/what-is-a-rest-apis/","link":"","permalink":"http://yoursite.com/2017/05/15/what-is-a-rest-apis/","excerpt":"","text":"Rest是一种描述网络架构的方法，和系统系统很类似，但是也有所不同。 https://www.quora.com/What-is-a-REST-API","categories":[],"tags":[{"name":"Rest API","slug":"Rest-API","permalink":"http://yoursite.com/tags/Rest-API/"}]},{"title":"从零开始学习webpack搭建vue工程-02","slug":"webpack-note-02","date":"2017-05-06T11:19:43.000Z","updated":"2017-05-06T11:50:13.000Z","comments":true,"path":"2017/05/06/webpack-note-02/","link":"","permalink":"http://yoursite.com/2017/05/06/webpack-note-02/","excerpt":"","text":"webpack+vue项目实践记录02配置webpack.config.js文件 支持http dev 支持热替换 支持es6 支持sass 打包的js文件自动插入到index.html模版中安装dev-server 12345# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress 注意的是以上的安装方式除了要安装全局，还要本地安装。 执行webpack-dev-server --progress命令，报错显示没有找到配置文件，原来是需要--config来指定配置文件。 使用webpack-dev-server --config build/webpack.config.js --inline --hot完成服务的启动。 也可以使用 webpack --config build/webpack.config.js --progress --watch //这条命令可以启动watch观察者模式。 12345devServer: &#123; contentBase: path.join(__dirname, &quot;dist&quot;), compress: true, port: 9000&#125; 服务启动的文件如上所示，但是问题又来了，当我访问浏览器localhost:9000时，没有找到资源文件，说明还是有配置没有搞好，主要是路径配置的问题，搞这需要搞明白contentBase、path、publicPath…这些参数的含义。 搞好配置文件，实现可以正常访问项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;)let HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; entry: &#123; app: path.resolve(__dirname, &apos;../src/main.js&apos;), &#125;, output: &#123; path: path.resolve(__dirname, &apos;../dist&apos;), //打包文件的输出地址 filename: &apos;[name].[hash].js&apos;, publicPath: &quot;/&quot; &#125;, resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.common.js&apos; &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; &apos;scss&apos;: &apos;vue-style-loader!css-loader!sass-loader&apos;, &apos;sass&apos;: &apos;vue-style-loader!css-loader!sass-loader?indentedSyntax&apos; &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, loader: &apos;file-loader&apos;, // file-loader 都是用于打包文件和图片 options: &#123; name: &apos;[name].[ext]?[hash]&apos; &#125; &#125; ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), //支持热替换 new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; //指定处理模版 &#125;) ], // devServer: &#123; // colors: true, // &#125;, devServer: &#123; historyApiFallback: true, //不跳转 contentBase: path.join(__dirname, &quot;../src&quot;), //默认访问的本地静态文件的地址目录，建议最好是绝对路径 compress: true, // 启动gzip 压缩 Enable gzip compression inline: true, //时时刷新 hot: true, //支持热更新 port: 9999 &#125;&#125; 如上配置文件，执行webpack-dev-server --config build/webpack.config.js --inline --hot完成dev-server启动操作。 支持热替换其实 –hot 已经支持了热替换 但是另我不明白的是如果在CLI中不使用--line --hot，但是在devServer的配置中添加了指令，webpack-dev-server --config build/webpack.config.js执行时，热替换没有生效。 12345678devServer: &#123; historyApiFallback: true, //不跳转 contentBase: path.join(__dirname, &quot;../src&quot;), //默认访问的本地静态文件的地址目录，建议最好是绝对路径 compress: true, // 启动gzip 压缩 Enable gzip compression inline: true, //时时刷新 hot: true, //支持热更新 port: 9999&#125; 直到我添加下面的这个插件，解决了这个问题。至于原因至今未知。123plugins: [ new webpack.HotModuleReplacementPlugin(),//支持热替换], 在package.json 加上以下这段，就支持了使用npm run start启动项目了。1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --config build/webpack.config.js --inline --hot&quot;&#125;, 支持es6 支持sass到这时，我在想，需要安装些loader，css-loader、sass-loader、style-loader、babel-loader、file-loader(用于打包文件和图片),在这里连续安装了 1npm install sass-loader scss-loader --save-dev 在启动时，提示我需要安装node-sass,node-sass查了一下，简单说，就是将sass编译成css的一个工具，没有深究。 1npm install sass-loader scss-loader --save-dev 装完之后 1234567891011&#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; &apos;scss&apos;: &apos;vue-style-loader!css-loader!sass-loader&apos;, &apos;sass&apos;: &apos;vue-style-loader!css-loader!sass-loader?indentedSyntax&apos; &#125; // other vue-loader options go here &#125;&#125; 就直接ok了。 下一步，支持es6， 123456789101112&#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/&#125;,&#123; test: /\\.(png|jpg|gif|svg)$/, loader: &apos;file-loader&apos;, // file-loader 都是用于打包文件和图片 options: &#123; name: &apos;[name].[ext]?[hash]&apos; &#125;&#125; 执行npm run start,提示安装babel-loader和babel-core，并依次安装 执行编译，自动引入到html文档中，使用html-webpack-plugin这个插件安装npm install html-webpack-plugin --save-dev添加此配置，其中template是指定处理的模版文件 12345plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; //指定处理模版 &#125;)] 另外有一点需要注意的是12345output: &#123; path: path.resolve(__dirname, &apos;../dist&apos;), //打包文件的输出地址 filename: &apos;[name].[hash].js&apos;, publicPath: &quot;/&quot;&#125; html-webpack-plugin插件是根据输出文件的路径配置进行对index.html进行处理的，将js文件插入到index.html中，需要保证此配置正确。其中“path”仅仅告诉Webpack结果存储在哪里，然而“publicPath”项则被许多Webpack的插件用于在生产模式下更新内嵌到css、html文件里的url值。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"第一次控制自我","slug":"control-myself","date":"2017-04-25T09:09:40.000Z","updated":"2017-07-16T15:23:00.000Z","comments":true,"path":"2017/04/25/control-myself/","link":"","permalink":"http://yoursite.com/2017/04/25/control-myself/","excerpt":"","text":"我知道自己的大脑和自己是两部分，这也形成了自己感性的一面和理性的一面。 当我的身体内的肾上腺等激素飙升的时候的时候，感性的一面大行其道，理性不复存在，自己的真性情显露无遗，要么发抖，要么脸红。 我知道，人没有好坏之分，只有好的时候和坏的时候，人是局限性的，好的时候和坏的时候在很多时候不是自己主动选择的，是自己身处的环境所诱导的。所以我不会和自己说自己是个好人还是坏人，自己都不是，自己就是一个人。昨天是控制住了自己的感性的一面的第一天，值得铭记的一天，有了这第一次，我相信，后面的路会更好走。 我经常和朋友说，做事之前，需要先分析一下，这个事是好事还是坏事，如果是好事，那就坚持自己的原则做下去，如果是坏事，那么就告诉自己，stop it！我的朋友反驳说：难道你是个圣人？是的，我说的很轻松，做到它谈何容易，当我想干一件事，有时候明明知道是不好的，但是你就是控制不住自己，这就是我的人性的弱点，这就是我的人的局限性。 一直以来我都无法做到控制住自己，即使我想控制，但是心有余而力不足，但是庆幸的是，这些年来，自己的理性的时候占了大多数，导致自己没有陷入坏的自己的世界太深，大致还是向着好的方向发展，这得益于自己的三观相对正常。 但是我昨天控制住了自己，这是一个好的开始，今天的感觉很异常，异常的好。","categories":[],"tags":[{"name":"我","slug":"我","permalink":"http://yoursite.com/tags/我/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"}]},{"title":"从零开始学习webpack搭建vue工程-01","slug":"webpack-note-01","date":"2017-04-16T16:59:17.000Z","updated":"2017-05-06T11:16:25.000Z","comments":true,"path":"2017/04/17/webpack-note-01/","link":"","permalink":"http://yoursite.com/2017/04/17/webpack-note-01/","excerpt":"","text":"webpack+vue项目实践记录01目的：练习render背景：一直使用vue-cli搭建vue工程，虽然vue全家桶在实际项目中应用的还过得去，以及之前也学习和练习了webpack的用法，但是在实践项目中没有使用太多，而且vue的前端工程化学习到的感觉是空中楼阁，对于未来的工程问题，仅仅使用vue-cli时不能够灵活的进行解决的，于是产生重新开始学习vue结合webpack搭建web工程的想法。 开始新建文件夹 vue-pro在vue-pro下新建文件夹 build在vue-pro下新建文件夹 src在vue-pro目录下执行npm init,初始化package.json在vue-pro目录下执行npm install vue --save-dev,安装vue 在src下新建 index.html main.js App.vue 分别作为实例挂载点、实例挂载入口文件、和vue单页模版根文件在build文件夹下创建dev-server.js 用于配置本地项目的启动文件 初始化这个项目下一步： 安装webpack、并配置，跑起来这个项目安装vue-loader安装webpack，查看版本号为1.14，应升级2.33 npm install -g webpack@2.3.3刚开始执行webpack build/webpack/config.js错误，是没找到webpack.config.js这个文件后来cd build 后执行 webpack webpack.config.js 报错 缺少vue-template-compiler，继续安装此模块缺少css-loader，继续安装此模块 执行webpack webpack.config.js成功 双击index.html 报错You are using the runtime-only build of Vue where the template compiler is not available.找到了一篇文章package.json 中的 main 属性决定了，当项目被引入时，输出的是哪个文件，而 vue 的 package.json 中的 main 指向的是 dist/vue.common.js。 擦，并不太懂是什么鬼，就是把 12// import Vue from &apos;Vue&apos;import Vue from &apos;vue/dist/vue.js&apos; 替换就好了。 但是渲染出来没有内容，我目前猜可能是需要服务器渲染的问题》》》 不是服务器渲染的问题 1234render: h =&gt; h(App)// component: &#123;// App// &#125; 这么替换，就完成了页面的渲染。 问题： 1.为什么在build外执行webpack build/webpack/config.js 报错？ 我发现，entry的入口路径参考的是你执行webpack的当前文件夹， 如果我我在webpack.config.js文件下执行webpack，那么这个时候，配置文件的入口地址，可以被找到，因为webpack的执行目录和配置文件所在目录是一致的，当我到上一层执行webpack构建时，就会出现问题，此时可以将entry的入口文件改为绝对地址就没有问题了。12// entry: &apos;../src/main.js&apos;,entry: path.resolve(__dirname, &apos;../src/main.js&apos;), 但是我执行webpack build/webpack/config.js时还是不行，报错：1234No configuration file found and no entry configured via CLI option.When using the CLI you need to provide at least two arguments: entry and output.A configuration file could be named &apos;webpack.config.js&apos; in the current directory.Use --help to display the CLI options. 当我执行webpack --config build/webpack.config.js --progress就可以成功。 这两者有什么区别呢？ 原来，这和progress没关系，Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。 soga！！ 2.import Vue from &#39;Vue&#39; 和 import Vue from &#39;vue/dist/vue.js&#39; 什么区别？ 这个问题还需要从vue的构建方式来看，vue的构建方式有两种独立构建 和运行时构建，其中独立构建= 编译 + 运行时构建， Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。 vue默认的是运行时构建，如果想使用独立构建需要在webpack配置中加入下面这段： 12345resolve: &#123; alias: &#123; &apos;vue$&apos;: vue/dist/vue.esm.js // &apos;vue/dist/vue.common.js&apos; for webpack 1 &#125;&#125; 但是如何区分运行时构建和独立构建？以及怎么分别实现运行时构建和独立构建？ 至此，如果想使用template写模版，需要使用独立构建，如果使用render函数渲染模版使用运行时构建。 独立构建 12345678import Vue from &apos;vue/dist/vue.js&apos; //独立构建// import Vue from &apos;vue/dist/vue.esm.js&apos; //独立构建import App from &apos;./App.vue&apos;new Vue(&#123; el: &apos;#app&apos;, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;).$mount(&apos;#app&apos;) 运行时构建 1234567import Vue from &apos;Vue&apos; //运行时构建import App from &apos;./App.vue&apos;new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App)&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"My-girlfriend","slug":"My-girlfriend","date":"2017-04-12T15:14:07.000Z","updated":"2017-07-16T15:25:31.000Z","comments":true,"path":"2017/04/12/My-girlfriend/","link":"","permalink":"http://yoursite.com/2017/04/12/My-girlfriend/","excerpt":"","text":"这其实是关乎隐私的文章，但是我想记录下来，一来我的博客没什么量，也没人看到，而来看到的人大都是没见过我，也没啥害羞的，最主要的，我希望写下来我的感受，永远的记住它。 说实话，在遇到女朋友之前，我一直都是一个花心的人，但是当我遇到我的女朋友，我变得专一了。这印证了一句话：“抓不住男人的心，就不要说男人花心”。女朋友在我心里是全世界最好的女朋友，因为她的存在，我变得更加积极向上、阳光、健康，生活变得更加丰富多彩。 在女朋友心里，我有很多绰号，我能想起来的有：变色龙、盘中餐、大叔、害人精、blue、喵喵、呆萌、萌萌哒、大虫子……等等，当然，更多的时候都是称呼我亲爱的～。每一个绰号都有故事，都有来源，我们的生活很普通和平凡，但是不单调，因为有她。 我的女朋友有时候也会生气，这个时候，很明显，因为是我做得不够好导致的，作为一名编程工作者，有时候缺少了制造浪漫，常常以我是简单内向的程序员为借口，但是我的女朋友明知是假的还是将信就信了，去哪找这么“通情达理”的女朋友。 我经常加班，甚至周六也加班，有时候陪他就比较少，女朋友虽然不希望我这么辛苦的加班工作，但是还是很理解我，有时候我挺愧疚的。 有时候晚上回来的十一点了，女朋友做好了水果沙拉，写好了留言条放在桌子上，嘱咐我记得吃，满满的感动，看着她睡着的样子，真想去亲亲她，但又怕打扰她休息-我心里的全世界最好的女朋友。 我有时候会懒惰，但是想想远方的亲人和身边的女朋友,X…奋斗的动力又十足了。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"一段代码-递归调用的返回值问题","slug":"一段代码-递归调用的返回值问题","date":"2017-04-07T04:35:35.000Z","updated":"2017-04-07T11:58:11.000Z","comments":true,"path":"2017/04/07/一段代码-递归调用的返回值问题/","link":"","permalink":"http://yoursite.com/2017/04/07/一段代码-递归调用的返回值问题/","excerpt":"","text":"今天写一个递归函数，获取的返回值不是自己想要的结果，而是undefined，困扰了我很久。 1234567891011function recuFunc(val) &#123; if (val &gt; 10) &#123; return val &#125; else &#123; recuFunc(val + 1) &#125;&#125;let res = recuFunc(1)console.log(res) //undefined 思考了许久，终于发现了问题之所在。 1234567891011function recuFunc(val) &#123; if (val &gt; 10) &#123; return val &#125; else &#123; return recuFunc(val + 1) &#125;&#125;let res = recuFunc(1)console.log(res) //11 仅仅在递归调用的函数前面加上return,问题迎刃而解。究其原因，简单说就是函数体没有返回值，自然结果是undefined。最初我以为当我执行到val &gt; 10的时候，return val 此时就能得到想要的结果，那是我对递归算法的理解不够。现在想来，其实递归函数就像一个同心圆一样，一层函数嵌套着一层函数，当边界条件被满足时，return val返回给最里层的函数，如果函数前不加return,但是这个函数结果没有被返回,它的上层函数就没有返回值，其结果就是undefined了。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"}]},{"title":"一段代码-检测JS对象值是否为空","slug":"isEmptyValue","date":"2017-04-01T12:03:46.000Z","updated":"2017-04-01T12:44:56.000Z","comments":true,"path":"2017/04/01/isEmptyValue/","link":"","permalink":"http://yoursite.com/2017/04/01/isEmptyValue/","excerpt":"","text":"前端在开发过程中，经常会遇到后端传过来的数据为空的情况，如果我知道确定的数据类型还比较容易判断，但有时候类型是不确定的，比如数组类型，在数组为空的时候，不知道返回的是[] 还是 null，这个时候如果冒然的使用Array.length()进行判断，当返回的空数组的值不是[]而是null时就会出现问题。 于是我就想写段代码，去检测数据是否为空，以后直接调用它便是。 我将如下的数据值定义为空值，其他值便为非空值。 [] {} ‘’ ‘ ‘ null undefined 由于在JavaScript中的所有事物都是对象，所以需要先进行对象类型的判断，然后再根据不同的类型进行处理。typeof主要进行基本数据类型的检测，在这里不适用。考虑到javascript安全的类型监测，所以在这里如果使用instanceof在多个JS框架环境中使用并不保险。所以安全起见，还是使用Object.prototype.toString.call()比较靠谱。 下面就根据以上的想法产出了下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738function isEmptyVal (val) &#123; let type; let isEmptyObj = function (obj) &#123; for (let name in val) &#123; return false; &#125; return true &#125; type = Object.prototype.toString.call(val).slice(8, -1) switch (type) &#123; case &apos;Array&apos;: return !val.length case &apos;String&apos;: return !val.trim() case &apos;Object&apos;: return isEmptyObj(val) case &apos;Null&apos;: return true case &apos;Undefined&apos;: return true default: return false &#125;&#125;let isEmptyVal1 = isEmptyVal(&apos;&apos;)let isEmptyVal2 = isEmptyVal(&#123;&#125;)let isEmptyVal3 = isEmptyVal([])let isEmptyVal4 = isEmptyVal(null)let isEmptyVal5 = isEmptyVal(undefined)let isEmptyVal6 = isEmptyVal(&apos; &apos;)console.log(isEmptyVal1) //trueconsole.log(isEmptyVal2) //trueconsole.log(isEmptyVal3) //trueconsole.log(isEmptyVal4) //trueconsole.log(isEmptyVal5) //trueconsole.log(isEmptyVal6) //true","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"YOU MIGHT NOT NEED JQUERY","slug":"do-not-need-jquery","date":"2017-03-23T15:18:45.000Z","updated":"2017-03-25T14:02:29.000Z","comments":true,"path":"2017/03/23/do-not-need-jquery/","link":"","permalink":"http://yoursite.com/2017/03/23/do-not-need-jquery/","excerpt":"","text":"jQuery and its cousins are great, and by all means use them if it makes it easier to develop your application. If you’re developing a library on the other hand, please take a moment to consider if you actually need jQuery as a dependency. Maybe you can include a few lines of utility code, and forgo the requirement. If you’re only targeting more modern browsers, you might not need anything more than what the browser ships with. At the very least, make sure you know what jQuery is doing for you, and what it’s not. Some developers believe that jQuery is protecting us from a great demon of browser incompatibility when, in truth, post-IE8, browsers are pretty easy to deal with on their own. 1 AJAXJSONJQUERY123$.getJson(&apos;/my/url&apos;, function () &#123; &#125;); IE9+12345678910111213141516var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function () &#123; if(request.status &gt; 200 &amp;&amp; request.status &lt; 400) &#123; // Success! var data = JSON.parse(request.responseText) &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;request.onerror = function () &#123; // There was a connection error of some sort&#125;request.send(); PostJQUERY12345$.ajax(&#123; type: &apos;POST&apos;, url: &apos;/my/url&apos;, data: data&#125;); IE8+1234var request = new XMLHttpRequest();request.open(&apos;POST&apos;, &apos;/my/url&apos;, true);request.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);request.send(data); RequestJQUERY12345678910$.ajax(&#123; type: &apos;GET&apos;, url: &apos;/my/url&apos;, success: function(resp) &#123; &#125;, error: function() &#123; &#125;&#125;); IE8+123456789101112131415161718var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function() &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! var resp = request.responseText; &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;;request.onerror = function() &#123; // There was a connection error of some sort&#125;;request.send(); 2 EFFECTSFade InJQUERY1$(el).fadeIn(); IE9+1234567891011121314151617function fadeIn(el) &#123; el.style.opacity = 0; var last = +new Date(); var tick = function() &#123; el.style.opacity = +el.style.opacity + (new Date() - last) / 400; last = +new Date(); if (+el.style.opacity &lt; 1) &#123; (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16); &#125; &#125;; tick();&#125;fadeIn(el); HideJQUERY1$(el).hide(); IE8+1el.style.display = &apos;none&apos;; ShowJQUERY1$(el).show(); IE8+1el.style.display = &apos;&apos;; 3 ELEMENTSAdd ClassJQUERY1$(el).addClass(className); IE8+1234if (el.classList) el.classList.add(className);else el.className += &apos; &apos; + className; AfterJQUERY1$(el).after(htmlString); IE8+1el.insertAdjacentHTML(&apos;afterend&apos;, htmlString); AppendJQUERY1$(parent).append(el); IE8+1parent.appendChild(el); BeforeJQUERY1$(el).before(htmlString); IE8+1el.insertAdjacentHTML(&apos;beforebegin&apos;, htmlString); ChildrenJQUERY1$(el).children(); IE9+1el.children CloneJQUERY1$(el).clone(); IE8+1el.cloneNode(true); ContainsJQUERY1$.contains(el, child); IE8+1el !== child &amp;&amp; el.contains(child); Contains SelectorJQUERY1$(el).find(selector).length; IE8+1el.querySelector(selector) !== null EachJQUERY123$(selector).each(function(i, el)&#123;&#125;); IE9+1234var elements = document.querySelectorAll(selector);Array.prototype.forEach.call(elements, function(el, i)&#123;&#125;); EmptyJQUERY1$(el).empty(); IE9+1el.innerHTML = &apos;&apos;; FilterJQUERY1$(selector).filter(filterFn); IE9+1Array.prototype.filter.call(document.querySelectorAll(selector), filterFn); Find ChildrenJQUERY1$(el).find(selector); IE8+1el.querySelectorAll(selector); Find ElementsJQUERY1$(&apos;.my #awesome selector&apos;); IE8+1document.querySelectorAll(&apos;.my #awesome selector&apos;); Get AttributesJQUERY1$(el).attr(&apos;tabindex&apos;); IE8+1el.getAttribute(&apos;tabindex&apos;); Get HtmlJQUERY1$(el).html(); IE8+1el.innerHTML Get Outer HtmlJQUERY1$(&apos;&lt;div&gt;&apos;).append($(el).clone()).html(); IE8+1el.outerHTML Get StyleJQUERY1$(el).css(ruleName); IE9+1getComputedStyle(el)[ruleName]; Get TextJQUERY1$(el).text(); IE9+1el.textContent Has ClassJQUERY1$(el).hasClass(className); IE8+1234if (el.classList) el.classList.contains(className);else new RegExp(&apos;(^| )&apos; + className + &apos;( |$)&apos;, &apos;gi&apos;).test(el.className); MatchesJQUERY1$(el).is($(otherEl)); IE8+1el === otherEl Matches SelectorJQUERY1$(el).is(&apos;.my-class&apos;); IE9+12345var matches = function(el, selector) &#123; return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);&#125;;matches(el, &apos;.my-class&apos;); NextJQUERY1$(el).next(); IE9+1el.nextElementSibling OffsetJQUERY1$(el).offset(); IE8+123456var rect = el.getBoundingClientRect();&#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft&#125; Offset ParentJQUERY1$(el).offsetParent(); IE8+1el.offsetParent || el Outer HeightJQUERY1$(el).outerHeight(); IE8+1el.offsetHeight Outer Height With MarginJQUERY1$(el).outerHeight(true); IE9+123456789function outerHeight(el) &#123; var height = el.offsetHeight; var style = getComputedStyle(el); height += parseInt(style.marginTop) + parseInt(style.marginBottom); return height;&#125;outerHeight(el); Outer WidthJQUERY1$(el).outerWidth(); IE8+1el.offsetWidth Outer Width With MarginJQUERY1$(el).outerWidth(true); IE9+123456789function outerWidth(el) &#123; var width = el.offsetWidth; var style = getComputedStyle(el); width += parseInt(style.marginLeft) + parseInt(style.marginRight); return width;&#125;outerWidth(el); ParentJQUERY1$(el).parent(); IE8+1el.parentNode PositionJQUERY1$(el).position(); IE8+1&#123;left: el.offsetLeft, top: el.offsetTop&#125; Position Relative To ViewportJQUERY123456var offset = el.offset();&#123; top: offset.top - document.body.scrollTop, left: offset.left - document.body.scrollLeft&#125; IE8+1el.getBoundingClientRect() PrependJQUERY1$(parent).prepend(el); IE8+1parent.insertBefore(el, parent.firstChild); PrevJQUERY1$(el).prev(); IE9+1el.previousElementSibling RemoveJQUERY1$(el).remove(); IE8+1el.parentNode.removeChild(el); Remove ClassJQUERY1$(el).removeClass(className); IE8+1234if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;); Replace From HtmlJQUERY1$(el).replaceWith(string); IE8+1el.outerHTML = string; Set AttributesJQUERY1$(el).attr(&apos;tabindex&apos;, 3); IE8+1el.setAttribute(&apos;tabindex&apos;, 3); Set HtmlJQUERY1$(el).html(string); IE8+1el.innerHTML = string; Set StyleJQUERY1$(el).css(&apos;border-width&apos;, &apos;20px&apos;); IE8+12// Use a class if possibleel.style.borderWidth = &apos;20px&apos;; Set TextJQUERY1$(el).text(string); IE9+1el.textContent = string; SiblingsJQUERY1$(el).siblings(); IE8+123Array.prototype.filter.call(el.parentNode.children, function(child)&#123; return child !== el;&#125;); Toggle ClassJQUERY1$(el).toggleClass(className); IE9+12345678910111213if (el.classList) &#123; el.classList.toggle(className);&#125; else &#123; var classes = el.className.split(&apos; &apos;); var existingIndex = classes.indexOf(className); if (existingIndex &gt;= 0) classes.splice(existingIndex, 1); else classes.push(className); el.className = classes.join(&apos; &apos;);&#125; 4 EVENTSOffJQUERY1$(el).off(eventName, eventHandler); IE9+1el.removeEventListener(eventName, eventHandler); OnJQUERY1$(el).on(eventName, eventHandler); IE9+1el.addEventListener(eventName, eventHandler); ReadyJQUERY123$(document).ready(function()&#123;&#125;); IE9+1234567function ready(fn) &#123; if (document.readyState != &apos;loading&apos;)&#123; fn(); &#125; else &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, fn); &#125;&#125; Trigger CustomJQUERY1$(el).trigger(&apos;my-event&apos;, &#123;some: &apos;data&apos;&#125;); IE9+12345678if (window.CustomEvent) &#123; var event = new CustomEvent(&apos;my-event&apos;, &#123;detail: &#123;some: &apos;data&apos;&#125;&#125;);&#125; else &#123; var event = document.createEvent(&apos;CustomEvent&apos;); event.initCustomEvent(&apos;my-event&apos;, true, true, &#123;some: &apos;data&apos;&#125;);&#125;el.dispatchEvent(event); Trigger NativeJQUERY1$(el).trigger(&apos;change&apos;); IE9+1234// For a full list of event types: https://developer.mozilla.org/en-US/docs/Web/API/document.createEventvar event = document.createEvent(&apos;HTMLEvents&apos;);event.initEvent(&apos;change&apos;, true, false);el.dispatchEvent(event); 5 UTILSBindJQUERY1$.proxy(fn, context); IE9+1fn.bind(context); Array EachJQUERY123$.each(array, function(i, item)&#123;&#125;); IE9+123array.forEach(function(item, i)&#123;&#125;); Deep ExtendJQUERY1$.extend(true, &#123;&#125;, objA, objB); IE8+1234567891011121314151617181920212223var deepExtend = function(out) &#123; out = out || &#123;&#125;; for (var i = 1; i &lt; arguments.length; i++) &#123; var obj = arguments[i]; if (!obj) continue; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] === &apos;object&apos;) out[key] = deepExtend(out[key], obj[key]); else out[key] = obj[key]; &#125; &#125; &#125; return out;&#125;;deepExtend(&#123;&#125;, objA, objB); ExtendJQUERY1$.extend(&#123;&#125;, objA, objB); IE8+1234567891011121314151617var extend = function(out) &#123; out = out || &#123;&#125;; for (var i = 1; i &lt; arguments.length; i++) &#123; if (!arguments[i]) continue; for (var key in arguments[i]) &#123; if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key]; &#125; &#125; return out;&#125;;extend(&#123;&#125;, objA, objB); Index OfJQUERY1$.inArray(item, array); IE9+1array.indexOf(item); Is ArrayJQUERY1$.isArray(arr); IE9+1Array.isArray(arr); MapJQUERY123$.map(array, function(value, index)&#123;&#125;); IE8+123array.map(function(value, index)&#123;&#125;); NowJQUERY1$.now(); IE9+1Date.now(); Parse HtmlJQUERY1$.parseHTML(htmlString); IE9+1234567var parseHTML = function(str) &#123; var tmp = document.implementation.createHTMLDocument(); tmp.body.innerHTML = str; return tmp.body.children;&#125;;parseHTML(htmlString); Parse JsonJQUERY1$.parseJSON(string); IE8+1JSON.parse(string); TrimJQUERY1$.trim(string); IE9+1string.trim(); TypeJQUERY1$.type(obj); IE8+1Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, &apos;$1&apos;).toLowerCase();","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS对象的深拷贝和浅拷贝","slug":"JS对象的深拷贝和浅拷贝","date":"2017-03-15T10:35:42.000Z","updated":"2017-03-16T02:07:05.000Z","comments":true,"path":"2017/03/15/JS对象的深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2017/03/15/JS对象的深拷贝和浅拷贝/","excerpt":"","text":"我们在对数据进行备份的时候，如果这个数据是基本的数据类型，那么很好办，通过赋值实现复制即可。 如果在使用JavaScript对数组或对象进行操作的时候，我们经常需要将数组或对象进行备份，事实证明如果只是简单的将它赋予其他变量，那么我们只要更改其中的任何一个，然后其他的也会跟着改变，这就导致了问题的发生。 这个问题就是深拷贝和浅拷贝的问题。 浅拷贝但是当遇到引用数据类型时，就需要三思而复制，操作而三思。1234567891011let obj1 = &#123; a: 1, b: 2&#125;let obj2 = obj1obj2.b = 3console.log(obj1) // &#123; a: 1, b: 3 &#125;console.log(obj1 === obj2) //true 在这里我只是想obj2复制obj1,当我对obj2进行操作时，obj1的值也发生了变化。换句话说就是因为如果只是简单的赋值，它只是进行了地址的引用，所以改变一个对象另一个对象也会跟着变。上面这种直接赋值方式的复制称之为浅拷贝。 深拷贝我在想如何让obj2复制obj1的对象内容，在我对obj2进行修改时，不影响obj1，下面总结两个方法，可以在不同情况下使用。 1. JSON.parse(JSON.stringify(obj))利用JSON的方式进行浅层次序列化对象进行深拷贝是一个很好的方法。 12345678910let obj1 = &#123; a: 1, b: 2&#125;let obj3 = JSON.parse(JSON.stringify(obj1))obj3.b = 5console.log(obj1) //&#123; a: 1, b: 2 &#125;console.log(obj1 === obj3) //false 但是JSON的方式有局限性，就是对象必须遵从JSON的格式，当遇到层级较深，且序列化对象不完全符合JSON格式时，使用JSON的方式进行深拷贝就会出现问题。 123456789let obj1 = &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: function func() &#123;&#125;&#125;let obj4 = JSON.parse(JSON.stringify(obj1))console.log(obj4) //&#123; a: &apos;1&apos;, b: &apos;2&apos; &#125; 好像漏了些什么😄 2. 一段深拷贝的代码其实实现对象的深拷贝，只需要把父对象的属性，全部拷贝给子对象，就可以实现复拷贝。1234567function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125; 但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 当对象层级较深，且序列化对象不完全符合JSON格式时，这个时候就需要通过递归调用”浅拷贝”来解决。 12345678910111213141516171819202122232425262728let obj1 = &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: function aa () &#123;&#125;&#125;function deepCopy(obj) &#123; if(typeof obj === &quot;object&quot;) &#123; if(obj.constructor === Array) &#123; var newArr = [] for(var i = 0; i &lt; obj.length; i++) newArr.push(obj[i]) return newArr &#125; else &#123; var newObj = &#123;&#125; for(var key in obj) &#123; newObj[key] = this.deepCopy(obj[key]) &#125; return newObj &#125; &#125; else &#123; return obj &#125;&#125;console.log(deepCopy(obj1)) //&#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: [Function: aa] &#125; 继续简化一下… 123456789101112131415161718let obj1 = &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: function aa () &#123;&#125;&#125;function deepCopy (obj) &#123; let temp = obj.constructor === Array ? [] : &#123;&#125; for (let val in obj) &#123; temp[val] = typeof obj[val] == &apos;object&apos; ? deepCopy(obj[val]) : obj[val] &#125; return temp&#125;console.log(deepCopy(obj1)) //&#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: [Function: aa] &#125; 总结在实际开发中，关于对象复制的问题是经常遇到的。最常见的是对对象的复制，重新定义，扩展等。掌握浅拷贝和深拷贝的区别以及如何进行深拷贝，以及选择哪个方式进行深拷贝，会节省许多debug时间，避免很多不必要的麻烦。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"记一次敏捷开发Scrum培训及实践的感受","slug":"敏捷开发Scrum培训及实践总结","date":"2017-03-11T14:24:13.000Z","updated":"2017-03-11T14:42:25.000Z","comments":true,"path":"2017/03/11/敏捷开发Scrum培训及实践总结/","link":"","permalink":"http://yoursite.com/2017/03/11/敏捷开发Scrum培训及实践总结/","excerpt":"","text":"在2016年10月26日，部门请到了亚信的内训师，亚信国际的王林皓讲师来给我们BDX的大数据云平台部和数据产品线专门培训敏捷开发Scrum。王老师很早以前就是Scrum Master，带过很多敏捷的团队，在Scrum方面有丰富的经验。 作为自己在这个培训之前，通过工作中的体会和一些资料的阅读，我对敏捷开发也有一点点的认识。知道敏捷开发的敏捷性，小步代跑的过程能够根据不断变化的需求快速响应。 在当天培训中，讲师通过八个章节的内容介绍，中间穿插着一系列的活动作示例，并结合理论的讲解，让我听得受益匪浅，对敏捷开发有了新的认知。 首先，讲师介绍敏捷的五大要素（勇气、开放、承诺、专注、尊重）过程中，自己其实是挺感慨的，自己参与了一年左右的敏捷开发流程，却不知道自己需要以一种怎样的态度来参与敏捷。以上的五大要素中，在自己目前的实践中，自己在勇气和开放方面做的最不好，对于今后，会通过各个击破的方式一项一项整体提高这五大要素的要求。 现在是处于互联网的时代，在这个时代下要求产品的研发要快、准、狠才能跟的上跟得上市场的步伐。敏捷原则和思维刚刚好解释了在这个时代下选择敏捷开发是因为开发需要敏捷这个特性。敏捷不是一个方法论、过程或者框架，敏捷是一种思维。这个思维特性要求自己以一种开放的心态不断的学习和改变来适应周围的变化。 讲师通过一系列的活动实践告诉我们实践敏捷的价值就是优先做最有价值的事，虽然这并不容易做到，这要求参与敏捷的每个人都要拥有共同的价值观，大家齐心协力在一个方向上努力。除非需求的市场前景特别明晰，不然需求价值的大小有时候并不容易统一，这在实践过程中是有挑战的。通过敏捷实践价值这节的学习，要求自己在今后了解自己工作内容的价值，这样应该会让自己更好的开展工作。 通过对scrum的特征、框架、团队方面内容的学习，让我对敏捷开发的认识比较全面。在透明性、跨职能、自组织三个特征中， 目前团队的敏捷实践对这些特征没有明显的体现，可见，我们需要改进的地方还有很多。个人角度来看，需要先从自己的心态上、行为上逐渐的去改变。 讲师在讲解的过程中，也通过提出一个问题引发我们的思考最后解决问题来引起我们的共鸣。有个问题令我印象深刻，“每周计划制定之后，计划外的任务打乱原计划时，计划如何调整？”,因为这个问题目前正在发生，我们的方式是尽量赶计划，实在完成不了计划就会延迟。老师给出”进多少，出多少“的方案是比较客观合理的。 在敏捷开发过程中，有一块内容是我感觉非常困难的，就是敏捷估算。虽然讲师告诉我们不要绝对估算，要使用相对估算的方法，即使这样估算起来还是摸不着头脑。比如在从用户故事进行任务量估算，完全是凭感觉来的，估算的值很不准确，这方面可能随着业务经验的增长会逐渐变好吧。 本次培训是能够引发自己思考的一次培训，因为这和每天的工作息息相关，讲的内容也容易接受。但是理论和实践总是存在着一定的距离。王阳明有句话说：”知之真切笃实处即是行，行之明觉精察处即是知。“，我们下一个目标就是将所学所用付诸于实践，在未来，我们通过点滴的不断的改变不足之处、实践、调整、反思、再实践，团队最终肯定会实现规范的、适合团队的、有效的敏捷开发。","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"},{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://yoursite.com/tags/敏捷开发/"}]},{"title":"终身受用的世界顶尖思维","slug":"终身受用的世界顶尖思维","date":"2017-03-10T14:08:46.000Z","updated":"2017-03-11T14:44:00.000Z","comments":true,"path":"2017/03/10/终身受用的世界顶尖思维/","link":"","permalink":"http://yoursite.com/2017/03/10/终身受用的世界顶尖思维/","excerpt":"","text":"1 素养蓝斯登原则：在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。 提出者：美国管理学家蓝斯登。 点评：进退有度，才不至进退维谷;宠辱皆忘，方可以宠辱不惊。 卢维斯定理：谦虚不是把自己想得很糟，而是完全不想自己。 提出者：美国心理学家h.卢维斯。 点评：如果把自己想得太好，就很容易将别人想得很糟。 托利得定理：测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想而无碍于其处世行事。 提出者：法国社会心理学家h.m.托利得。 点评：思可相反，得须相成。 2 统御刺猬理论：刺猬在天冷时彼此靠拢取暖，但保持一定距离，以免互相刺伤。 点评：保持亲密的重要方法，乃是保持适当的距离。 鲦鱼效应：鲦鱼因个体弱小而常常群居，并以强健者为自然首领。将这条首领鲦鱼脑后控制行为的部分割除后，此鱼便失去自制力，行动也发生紊乱，但其他鲦鱼却仍像从前一样盲目追随。 提出者：德国动物学家霍斯特。 点评： 1、下属的悲剧总是领导一手造成的。 2、下属觉得最没劲的事，是他们跟着一位最差劲的领导。 雷鲍夫法则：在你着手建立合作和信任时要牢记我们语言中： 1、最重要的八个字是：我承认我犯过错误。 2、最重要的七个字是：你干了一件好事! 3、最重要的六个字是：你的看法如何? 4、最重要的五个字是：咱们一起干! 5、最重要的四个字是：不妨试试! 6、最重要的三个字是：谢谢您! 7、最重要的两个字是：咱们。 8、最重要的一个字是：您。 提出者：美国管理学家雷鲍夫。 点评：记住经常使用，它会让你事半功倍。 洛伯定理：对于一个经理人来说，最要紧的不是你在场时的情况，而是你不在场时发生了什么。 提出者：美国管理学家r.洛伯。 点评：如果只想让下属听你的，那么当你不在身边时他们就不知道应该听谁的了。 3 沟通斯坦纳定理：在哪里说得愈少，在那里听到的就愈多。 提出者：美国心理学家s.t.斯坦纳。 点评：只有很好听取别人的，才能更好说出自己的。 费斯诺定理：人两只耳朵却只有一张嘴巴，这意味着人应该多听少讲。 提出者：英国联合航空公司总裁兼总经理l.费斯诺。 点评：说得过多了，说的就会成为做的障碍。 牢骚效应：凡是公司中有对工作发牢骚的人，那家公司或老板一定比没有这种人或有这种人而把牢骚埋在肚子里公司要成功得多。 提出者：美国密歇根大学社会研究院 1、牢骚是改变不合理现状的催化剂。 2、牢骚虽不总是正确的，但认真对待牢骚却总是正确的。 避雷针效应：在高大建筑物顶端安装一个金属棒，用金属线与埋在地下的一块金属板连接起来，利用金属棒的尖端放电，使云层所带的电和地上的电逐渐中和，从而保护建筑物等避免雷击。 点评：善疏则通，能导必安。 4 协调氨基酸组合效应：组成人体蛋白的8种氨基酸，只要有一种含量不足，其他7种就无法合成蛋白质。 点评：当缺一不可时，一就是一切。 米格-25效应：前苏联研制的米格-25喷气式战斗机的许多零部件与美国的相比都落后，但因设计者考虑了整体性能，故能在升降、速度、应急反应等方面成为当时世界一流。 点评：所谓最佳整体，乃是个体的最佳组合。 磨合效应：新组装的机器，通过一定时期的使用，把磨擦面上的加工痕迹磨光而变得更加密合。 点评：要想达到完整的契合，须双方都做出必要的割舍。 5 指导波特定理：当遭受许多批评时，下级往往只记住开头的一些，其余就不听了，因为他们忙于思索论据来反驳开头的批评。 提出者：英国行为学家l.w.波特 点评：总盯着下属的失误，是一个领导者的最大失误。 蓝斯登定律：跟一位朋友一起工作，远较在父亲之下工作有趣得多。 提出者：美国管理学家蓝斯登 点评：可敬不可亲，终难敬;有权没有威，常失权。 吉尔伯特法则：工作危机最确凿的信号，是没有人跟你说该怎样做。 提出者：英国人力培训专家b.吉尔伯特 点评：真正危险的事，是没人跟你谈危险。 权威暗示效应：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖15秒后，前排学生即举手，称自己闻到臭气，而后排的人则陆续举手，纷纷称自己也已闻到，其实瓶中什么也没有。 点评：迷信则轻信，盲目必盲从。 6 组织奥尼尔定理：所有的政治都是地方的。 提出者：美国前众议院院长奥尼尔 点评：只有能切身体会到的，群众才认为那是真实的。 定位效应：社会心理学家曾作过一个试验：在召开会议时先让人们自由选择位子，之后到室外休息片刻再进入室内入座，如此五至六次，发现大多数人都选择他们第一次坐过的位子。 点评：凡是自己认定的，人们大都不想轻易改变它。 艾奇布恩定理：如果你遇见员工而不认得，或忘了他的名字，那你的公司就太大了点。 提出者：英国史蒂芬。约瑟剧院导演亚伦。 点评：摊子一旦铺得过大，你就很难把它照顾周全。 7 培养吉格勒定理：除了生命本身，没有任何才能不需要后天的锻炼。 提出者：美国培训专家吉格•吉格勒 点评：水无积无辽阔，人不养不成才。 犬獒效应：当年幼的藏犬长出牙齿并能撕咬时，主人就把它们放到一个没有食物和水的封闭环境里让这些幼犬自相撕咬，最后剩下一只活着的犬，这只犬称为獒。据说十只犬才能产生一只獒。 点评：困境是造就强者的学校。 8 选拔近因效应：最近或最后的印象对人的认知有强烈的影响。 提出者：美国社会心理学家洛钦斯。 点评：结果往往会被视为过程的总结。 酒井法则：在招工时用尽浑身解数，使出各种方法，不如使自身成为一个好公司，这样人才自然而然会汇集而来。 提出者：日本企业管理顾问酒井正敬。 点评：不能吸引人才，已有的人才也留不住 美即好效应：对一个外表英俊漂亮的人，人们很容易误认为他或她的其他方面也很不错。 提出者：美国心理学家丹尼尔•麦克尼尔。 点评：印象一旦以情绪为基础，这一印象常会偏离事实。 9 任用奥格尔维法则：如果我们每个人都雇用比我们自己都更强的人，我们就能成为巨人公司。 提出者：美国奥格尔维。马瑟公司总裁奥格尔维。 点评：如果你所用的人都比你差，那么他们就只能做出比你更差的事情。 皮尔卡丹定理：用人方面一加一不等于二，搞不好等于零。 提出者：法国著名企业家皮尔•卡丹。 点评：组合失当，常失整体优势，安排得宜，才成最佳配置。 10 激励马蝇效应：再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。 点评：有正确的刺激，才会有正确的反应。 倒u形假说：当一个人处于轻度兴奋时，能把工作做得最好。当一个人一点儿兴奋都没有时，也就没有做好工作的动力了;相应地，当一个人处于极度兴奋时，随之而来的压力可能会使他完不成本该完成的工作。 世界网坛名将贝克尔之所以被称为常胜将军，其秘诀之一即是在比赛中自始至终防止过度兴奋，而保持半兴奋状态。所以有人也将倒u形假说称为“贝克尔境界”。 提出者：英国心理学家罗伯特•耶基斯和多德林。 点评： 1、激情过热，激情就会把理智烧光。 2、热情中的冷静让人清醒，冷静中的热情使人执着。 11 调研特伯论断：在数字中找不到安全。 提出者：美国经济学家w.s.特伯。 点评：数字是死的，情况是活的。 摩斯科定理：你得到的第一个回答，不一定是最好的回答。 提出者：美国管理学家r.摩斯科。 点评：刨根得根，问底知底。 12 预测罗杰斯论断：成功的公司不会等待外界的影响来决定自己的命运，而是始终向前看。 提出者：美国IBM公司前总裁p.罗杰斯。 点评：只想随波逐流，难有理想彼岸。 萨盖定律：戴一块手表的人知道准确的时间，戴两块手表的人便不敢确定几点了。 提出者：英国心理学家p.萨盖。 点评：若选错误参照，必无正确比较。 隧道视野效应：一个人若身处隧道，他看到的就只是前后非常狭窄的视野。 点评： 1、不拓心路，难开视野。 2、视野不宽，脚下的路也会愈走愈窄。 13 目标巴菲特定律：在其他人都投了资的地方去投资，你是不会发财的。 提出者：美国股神巴菲特。 点评： 1、善于走自己的路，才可能走别人没走过的路。 2、特色不特，优势无优。 古特雷定理：每一处出口都是另一处的入口。 提出者：美国管理学家w.古特雷。 点评：上一个目标是下一个目标的基础，下一个目标是上一个目标的延续。 14 计划列文定理：那些犹豫着迟迟不能作出计划的人，通常是因为对自己的能力没有把握。 提出者：法国管理学家p.列文。 点评：如果没有能力去筹划，就只有时间去后悔了。 弗洛斯特法则：在筑墙之前应该知道把什么圈出去，把什么圈进来。 提出者：美国思想家w.p.弗洛斯特 点评：开始就明确了界限，最终就不会作出超越界限的事来。 15 参谋波克定理：只有在争辩中，才可能诞生最好的主意和最好的决定。 提出者：美国庄臣公司总经理詹姆士•波克。 点评：无磨擦便无磨合，有争论才有高论。 韦奇定理：即使你已有了主见，但如果有十个朋友看法和你相反，你就很难不动遥 提出者：美国洛杉矶加州大学经济学家伊渥•韦奇。 点评： 1、未听之时不应有成见，既听之后不可无主见。 2、不怕开始众说纷纭，只怕最后莫衷一是。 16 决策福克兰定律：没有必要作出决定时，就有必要不作决定。 提出者：法国管理学家d.l.福克兰。 点评：当不知如何行动时，最好的行动就是不采取任何行动。 王安论断：犹豫不决固然可以免去一些做错事的机会，但也失去了成功的机遇。 提出者：美籍华裔企业家王安博士。 点评：寡断能使好事由好变坏，果断可将危机转危为安。 17 执行格瑞斯特定理：杰出的策略必须加上杰出的执行才能奏效。 提出者：美国企业家h.格瑞斯特。 点评：好事干实更好，实事办好愈实。 吉德林法则：把难题清清楚楚地写出来，便已经解决了一半。 提出者：美国通用汽车公司管理顾问查尔斯•吉德林。 点评：杂乱无章的思维，不可能产生有条有理的行动。 18 信息沃尔森法则：把信息和情报放在第一位，金钱就会滚滚而来。 提出者：美国企业家s.m.沃尔森。 点评：你能得到多少，往往取决于你能知道多少。 塔马拉效应：塔马拉是捷克雷达专家弗。佩赫发明的一种雷达，它与其他雷达的最大不同是不发射信号而只接收信号，故不会被敌方反雷达装置发现。 点评：善藏者人不可知，能知者人无以藏。 19 监督小池定理：越是沉醉，就越是抓住眼前的东西不放。 提出者：日本管理学家小池敬。 点评：自我陶醉不易清醒，自以为是不喜批评。 赫勒法则：当人们知道自己的工作成绩有人检查的时候会加倍努力。 提出者：英国管理学家h.赫勒。 点评：只有在相互信任的情况下，监督才会成为动力。 来源：TED演讲","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"}]},{"title":"我们这一代如何学习","slug":"我们这一代如何学习","date":"2017-03-09T01:50:42.000Z","updated":"2017-03-09T05:30:07.000Z","comments":true,"path":"2017/03/09/我们这一代如何学习/","link":"","permalink":"http://yoursite.com/2017/03/09/我们这一代如何学习/","excerpt":"","text":"我们这一代人都有知识焦虑，知识总量越来越大，负担越来越沉重，时间也越来越碎片化。那我们这一代人应该怎么学习？我给大家五个建议，也就是五个关键词。 1 人格第一个关键词是人格。这牵扯到对知识的理解。我们过去往往以为阅读就约等于学习，其实不是。阅读是跟书学，但是我的体会是，跟人学效率更高。 知识是啥？知识是一个极其复杂的信息网络，它的真实的存在场景是牛人的大脑里面，是翻江倒海不断在迭代。那为什么过去我们认为读书就是学习呢？没办法嘛。人类在那个时代是印刷文化时代，想保存和传递知识书本是那个时代最好的学习工具。但是现在不一样了，我们有机会重新回到人格这个学习对象。 就像我自己吧，每隔一段时间，我总有一些我佩服的读书人嘛，我就会问他，最近在读什么书啊？有什么漂亮的文章值得推荐呀？关于这个大家都在讨论的问题你有什么意见？拼命问这些人。为啥？因为这样学习的效率更高。牛人就是知识的载体啊，知识已经被他们像买菜一样买回来洗干净，已经切好了，已经搭配和融合好了，当然跟他们学更省时间。这是最好最好的减轻知识的总体负担的方案。这是第一个关键词。 2 概念第二个关键词我称之为叫概念。就是通过不断的搜集新概念来高效学习。比如说高中物理第一册，说白了不就是那些概念嘛，什么是力，什么是运动，牛顿的三大定律，万有引力定律，什么是做功，什么是动能，就这些东西啊。然后纲举目张，任何知识的碎片随便抓进来都能够安放到概念上。 为什么有这个原理？因为我们人类是一个超级模式化的动物嘛，世界本身非常复杂，它怎么能变成知识呢？就是沉淀为一个一个的概念。所以可见概念有多么的重要啊。为啥？因为知识太多了，你拿进来你往哪放呢？如果摊成一地，那都是脏东西啊。我以前讲过，什么叫脏啊？它不是说这个东西天然就脏，是放错位置才脏啊。一个米饭它搁在饭盒里那是干净的，搁在衣服上它就是脏嘛。 那怎么样让知识显得不脏呢？就是一定要有这个概念作为基础框架，所以在了解一本新学科的时候先去了解概念就变得特别重要。掌握知识本质上就是掌握概念，这是第二个关键词。 3 缝合那第三个关键词我称之为叫缝合。什么意思？就是拿针缝一针，把它的合起来。很多人都在感慨，说我读了这么多书，那些字就像流水一样从我脑子里飘过，读完之后，书一合上，啥也没记住，这咋办？你缺的就是这两个字，叫缝合。 知识是自己的事，是从自己的内心盛开的一朵花，它一定是由内而外长大，外在的知识从你眼前飘过，那就是你的，你必须缝一针才是你的。 那怎么缝合？很简单，表达一次。比如说我，我现在学知识，然后要做节目表达出来，然后它就是我的。 那你说我没有做脱口秀的能力呀，没关系，表达分很多种层次。比如说写一个读书笔记，它就是个表达啊，哎呀，你说那太累了，没关系，读书笔记可能就是你一句。我自己就有这样的习惯，很多人在网上看到一些文章，收藏，这文章特别好，这个收藏没有用，过了几天，你全忘了，你连收藏过它你都忘了。这个时候应该干什么？ 就写一句话。看完之后说，这个知识我觉得哪儿很有趣，这就叫缝合，这就叫读书笔记，这就和你原来的知识体系长在一起了。这个知识即使将来你全部忘了，没关系，你知道那儿有，你将来可以去查。现在资讯这么发达，互联网这么发达，什么东西都可以去查，但是知道什么东西在哪，这才是你自己的知识。 4 碎片那第四个关键词，我认为是碎片。这个争议就比较大了，很多人都反对呀，说学习嘛就应该体系化、系统化的学嘛，你碎片化学习，最后一地鸡毛，什么也学不着，也搭建不起巍峨的知识大厦。我不是说系统化学习不好，而是它不现实嘛。我们每个人的时间都在被剧烈的碎片化，我们每个人手里拿着一大堆碎片时间怎么办？不用于学习，难道用于打游戏才对吗？所以碎片化时间是一个基本事实，我们这一代人必须要练成一个本事，就是利用碎片化时间拿到实实在在的知识，我们必须这样做好不好啊。 站在真实的学习场景和站在学习者这一头来看，碎片化学习没有那么糟糕了。我给大家一些理由啊。首先，知识的产生它就是碎片化掉的，那一些再聪明的大脑他一时一刻也只能产生一个念头，一个假设，一个结论嘛，然后可能当论文就发表出来了，这就是知识真实的产生场景。它什么时候变成体系化？被验证之后过了很久，有人用一个理论体系把它总结出来，这已经是陈旧的知识。我们是终身学习者，任何新出来的假说即使没有被验证，了解一下有什么不好？它就是碎片化掉的。 还有一方面，就是如果站在学习者的角度来看，它碎片化是一个最终的结果啊，它一直就是如此啊。比如说你去读一本书，学一个学期的课，最终留下来的是啥？那不就是一些碎片化的印象吗？几个动人的场景，几个金句，几个精辟的结论，读完一本书能够留下这些东西已经是上上大吉了，你没有白读啊，上课也是一样。如果学习的结果就是碎片化，那碎片化学习有什么问题。你看，美国的社会活动家也是政治家富兰克林，我们以前讲过，他说过一句很著名的话，说我一生的知识积累的来源就是这样的，说我在查找一方面资料的同时意外地看到了另外的资料，这就是我的学习呀。你看，这不就是碎片化的学习嘛。这是第四点。 5 目标 那还有第五点，这就更重要了，这一点弄通了，前面四点你才能融会贯通，这一点我称之为叫目标。 我活了四十多年，我现在观察，人间就有两种人。第一种人他的世界里是三个词，叫立场、感受和意见。那第二种人他的世界里也是三个词叫目标、方法和行动。 我四十岁开始创业，其实就为完成一件事，把我的思维方式从第一种，就是立场、感受和意见切换到第二种，就是目标、方法和行动。为什么？这也跟学习有关。因为立场、意见和感受，我可以装一脑子，各种各样的知识和价值观在我脑子里它是打架的，我不知道哪个对哪个错，一会儿觉得这个对，一会儿觉得那个对。 就像我最近在录制《奇葩说》的节目，我发现场上的观众随着辩论赛的展开，双方的拉锯是非常剧烈的，他们一会儿觉得这个对，一会儿又觉得那个对。为什么？因为世界是剧烈分层的，任何一个选择都有无穷的层次，随着场上辩论者的那个不断的挖掘层次，观众的意见就跟着两头跑。对，意见是一个特别不确定的东西，知识在脑子里是散黄的，是在那儿晃来晃去的。可是一旦切换到第二种人生，就是只有目标、方法和行动的时候，一切就被整合起来了，这就是我要创业的根本原因。 总结总结一下刚才我们讲的所有，我们这一代人有知识焦虑，没有办法，知识总量越来越大，负担越来越沉重，我们的时间越来越碎片。怎么办？原来传统的解决方案对于我们这一代人不能完全适用，所以我提出来的5个关键词。第一，就是跟着人学，而不是跟着书本学，先降低我们的知识负担，它帮助我们筛选和归纳。那第二就是概念，通过掌握一个一个的新概念，搭建起我们的知识框架，再进来新的信息，我们知道把它放在哪儿。那第三缝合，信息走来过去，我们不见得都记得住，只有我们通过表达一次，无论是像我这样转述，还是写一则极其简短的读书笔记，在自己的生命和知识树当中把它缝合进来，即使这些信息将来我们忘光了，我们也知道到哪里去找它。那第四，就是碎片，这是我们提升学习效率，在这个时代几乎是唯一的法门。当然最重要的是目标，只有目标明确，不断往前拱，我们才能把知识落实为我们行动的成果。这就是我学习的基本方法。 本文源自：《得到》订阅专栏“罗辑思维”讲述：罗振宇","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"}]},{"title":"vue开发者必装的Atom插件","slug":"vue开发者必装的atom插件","date":"2017-03-07T07:05:10.000Z","updated":"2017-03-09T05:36:25.000Z","comments":true,"path":"2017/03/07/vue开发者必装的atom插件/","link":"","permalink":"http://yoursite.com/2017/03/07/vue开发者必装的atom插件/","excerpt":"","text":"之前一直用webstrom，在没有遇到Atom之前，总觉得JetBrains系列的IDE工具是世界最好的，也觉得JetBrains是世界上最懂开发者的公司，直到我遇到了Atom，于是顿时对Atom产生了好感，用了几下，便爱上了它无法自拔，后来有同事陆续推荐了VScode等其他工具，也没有改变我对Atom的坚持。 工作中，我是一名主要使用vue的前端开发者，也发现了几款不错的插件，我觉得这几款是屌丝程序员必备的了！ File-icons：给你的文件图标润色一下 这个插件，是必须要装的，没有它，看代码是煎熬，有了它，就好多啦！ atom-clock:给状态栏添加时钟等状态信息装上它，在Atom的右下角会出现一些你当前操作的状态信息，比如时间，git分支等等，有用。 pigments:文件内色值高亮 👇下面这个web开发者必备有没有… vue相关 language-vue:支持vue语法高亮 vue-autocomplete:vue语法自动补全 vue-element-ui-snippets：基于vue样式框架element的插件 vue相关的三个插件，配合着File-icons,开发已经很爽了，但是总觉得好像还是少点什么？？？ activate-power-mode：boom 这个厉害了下面这个是纯屌丝必备… 以后码代码不但是享受，还带着节奏… 终于找到你，再来一波boom………..","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"javascript安全类型监测","slug":"javascript安全类型监测","date":"2017-02-13T08:41:27.000Z","updated":"2017-03-06T07:43:38.000Z","comments":true,"path":"2017/02/13/javascript安全类型监测/","link":"","permalink":"http://yoursite.com/2017/02/13/javascript安全类型监测/","excerpt":"","text":"数据类型检测ECMAScript有五种简单的数据类型，分别为Undefined、Null、String、Number、Boolean，还有一个复杂的数据类型Object。ECMAScript的语言的动态性意味着我们可以使用以上6种数据类型表示任何数据。 因为数据类型是松散的，所以我们需要一些手段来准确的检测给定变量的数据类型。 typeoftepeof是检测基本数据类型的好手，他有六种检测结果，分别是Undefined、Object、Function、String、Number、Boolean,所以它是判断一个变量是：未定义值、对象、函数、字符串、数值、布尔值的最佳工具。123456789typeof undefined //&quot;undefined&quot;typeof &#123;&#125; //&quot;object&quot;typeof function()&#123;&#125; //&quot;function&quot;typeof &apos;&apos; //&quot;string&quot;typeof 1 //&quot;number&quot;typeof true //&quot;boolean&quot;typeof null //&quot;object&quot;typeof [] //&quot;object&quot; 从上面可以看出typeof虽然是检测基本数据类型的好手，但是在检测引用类型的数据时就力不从心了，下面会提到如何检测引用数据类型。另外还有个问题值得思考： 为什么null的检测类型是Object？ 看书中对null的描述： The value null represents the intentional absence of any objectvalue 首先，null是一个原始值。关于 typeof null //&quot;object&quot; 的结果，从一开始出现JavaScript就是这样的。 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是0。由于 null 代表的是空指针(大多数平台下值为0x00)，因此，null的类型标签也成为了0，typeof null就错误的返回了”object”.(referenc) 据说该问题在ECMAScript 6中提出typeof null === &#39;null&#39;的讨论 (该提议已被否决)。 安全类型检测javascript内置的类型检测机制并非完全可靠。比如typeof操作符，由于一些无法预知的行为，会得到不靠谱的结果。instanceof存在于多个作用域的情况，通过下面的方式检测数组： var isArray = value instanceof Array 以上代码若返回true，value必须是一个数组，而且必须与Array构造函数处于同一个作用域中。如果value是别的框架定义的数组，以上的代码又可能会返回false。 如何解决上述问题上述解决的办法都一样，在任何值上调用Object原生的toString方法时，都会返回一个类似于［object NativeConstructorName］格式的字符串，比如： Object.prototype.toString.call([&#39;&#39;]) //&quot;[object Array]&quot; 由于原生数组的构造函数名和全局作用域无关，因此使用toString就能返回一致的值。利用这点可以创建以下函数： 123456789101112131415function isArray(value) &#123; return Object.prototype.toString.call(value) == &quot;[object Array]&quot;;&#125;function isFunction(value) &#123; return Object.prototype.toString.call(value) == &quot;[object Function]&quot;;&#125;function isRegExp(value) &#123; return Object.prototype.toString.call(value) == &quot;[object RegExp]&quot;;&#125;function isNativeJSON(value) &#123; return window.JSON&amp;&amp;Object.prototype.toString.call(value) == &quot;[object JSON]&quot;;&#125; ⚠需要注意的一点是，Object.prototype.toString()本身也会被修改，本文讨论的仅仅是该方法未被修改的情况下。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"解决 git bash 不重复输入账号密码","slug":"git-not-repeat-put-password","date":"2016-10-19T05:06:40.000Z","updated":"2017-03-11T14:43:23.000Z","comments":true,"path":"2016/10/19/git-not-repeat-put-password/","link":"","permalink":"http://yoursite.com/2016/10/19/git-not-repeat-put-password/","excerpt":"","text":"1 寻找并编辑 .git-credentials 文件在%HOME%目录中，一般为C:\\users\\Administrator，也可以是你自己创建的系统用户名目录，反正都在C:\\users\\中。文件名为.git-credentials,由于在Window中不允许直接创建以”.”开头的文件，所以需要借助git bash进行，打开git bash客户端，进行%HOME%目录，然后用touch创建文件 .git-credentials, 用vim编辑此文件，输入内容格式： 12345touch .git-credentialsvim .git-credentialshttps://&#123;username&#125;:&#123;password&#125;@github.com 2 添加Git Config 内容进入git bash终端， 输入如下命令： git config --global credential.helper store 执行完后查看%HOME%目录下的.gitconfig文件，会多了一项： 12[credential]helper = store 重新开启git bash会发现git push时不用再输入用户名和密码","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"互联网时代-值得思考的话","slug":"internet-collect","date":"2016-09-26T14:54:01.000Z","updated":"2017-03-11T14:42:53.000Z","comments":true,"path":"2016/09/26/internet-collect/","link":"","permalink":"http://yoursite.com/2016/09/26/internet-collect/","excerpt":"","text":"人类社会从来不缺少善良的愿望，只不过在过去漫长的岁月，难以因为具体的动机而汇聚。 当信息突破了时间和空间的阻隔，它所携带的信息的能量，就能够具有这样一种非常神奇的力量，可以凝聚共识啊，可以焕发情感啊，能够形成一种强大的社会动员力量。 网络技术导致沟通出现彻底的转变，每个人可以与谁沟通也有所变化。因此，沟通的转变和对网络的需求共同创造了一种新的社会结构。 互联网产生了互相感召的力量。将无数同样拥有关怀之情的人形成了强大的自组织力量，是一种充分可持续的力量。人类以一种全新的组织、连接方式化合出无数钻石般的群体行动。 群体具备个人所不具备的性质，而究其原因，则在于我们组织个体的方式，使得群体优于个体。想一想碳元素，把碳原子以某种方式连接，你将得到铅笔中软而黑的石墨。如果以另一种方式连接碳原子，则将得到坚硬而清澈的钻石。 这种汇聚了的善的能量，是新时代赋予整个人类的一份财富。所有的信息都能以我们看不见的面貌，以我们经验不能体验的速度，创造出前所未有的时代动力。 我们都有梦想、希望和想象。然而没有人教我们如何做梦，我们只是行动起来，但是如果没有教育，凭梦想这些女孩只能走这么远。 埃文斯萌生这个看似遥不可及的梦想，不是因为他出身、教育、钱财、智商，而是因为他出生在互联网时代。 在过去的历史上，人类以金字塔的形式把所有人的善意汇聚起来，形成特定的组织实施救助。互联网时代，人们可以以地球为平台，以人类为范围，每一个人都有可能获得与过去世界级慈善组织相媲美的道德力量。 只要有共同意愿，无限的碎片就瞬间产生效能，产生让整个人类自我敬仰的力量，人类互相鼓舞创造美好人生的念头，在互联网时代，变得像投下一枚硬币那么简单。 人类社会的公共组织在它运行过程中，有自身繁育的充沛动力，各个层级不光会追逐层级的独特利益，而且还会膨胀层级本身。—帕金森定律。 现在淡水湖中的三文鱼是由内务部负责管理的，但是如果鱼游进了海水中，就归商务部管了；要是这些鱼被熏制好了，事情恐怕就更复杂了。 在曾经的漫长岁月，人类社会结构的层层叠叠中，大量的信息既在损耗也被扭曲，互联网穿透了社会坚厚的岩层，使所有相邻或相距遥远的层级，彼此面对。身份、财富、地域，都不再是传播的权利或枷锁。每个人的传播能量已经穿破层级壁垒，开始顶层和底层的直接交流。 在水平网络中，人们可以相连、分离、相聚、分散，整个社会和政治组织的形式都在变化。我们曾经谈论过后工业社会，“后”意味着我们并不明白。 人类社会一经诞生，就有金字塔一般由层级堆垒起来的醒目中心。在互联网时代，金字塔塔顶上的那块石头，已经可以轻松触摸它基座最深处的那一粒岩石，无论在哪一个位置上一块石头，都拥有了新时代的上帝之手。 微信，五亿；新浪微博，五亿；QQ，八亿；脸谱，十二亿。这些惊人的不断成长的数字田野里，瞬间崛起的不是数字，而是数字背后的声音和人 互联网实际上是把人与人联结在一起了，另外一个是把人与信息联结在一起了。因为这两个联结实际上大大提升了我们讲的那个信息的一个传播的效率，创造了效率。 工业时代，通过组织的方式和公约的形式，形成公共意志。公约形式就意味着注定有一小部分社会成员被公共意志所忽略，他们捍卫被忽略的权利的组织意愿，始终存在着。 不断被忽略的力量组织起来，构造成了公共组织形态和社会自组织形态的有机体。人们就生活在这样一个组织常态中。互联网时代，传统常态的经验和结构已不能容纳互联网组织起来的社会能量。信息传播技术，创造了绝对的少数也不能被忽略的可能。每一个声音都面对着世界，每一滴水珠都等同于大海。 人人都有自己的声音，即使你是矮穷挫，委身于地下室，香蕉皮等垃圾盖满地板，你却和那些坐在游泳池里的高富帅有着同样的声音。只要你能上得了网。 互联网让那些以前没有发言权的人发声，但是你怎么知道，你怎么知道那些声音是仇恨的声音还是团结协作的声音，是敌对的声音还是进步的声音？所以不能简单地由科技联想到价值。 曾经孕育了互联网的教育制度，受到网络本身组织能量的冲击，整个世界会变成一个没有边界的学校吗？理论上，一门课程，将来在世界上只需要一个老师，一等于无限，地球上的每个人都享有平等的受教育的权利。那将是矗立了四千五百年的金字塔，能够目睹的这个星球上最动人的一幕。每一个人都可以站在大地，分享这个世界，并触摸天空。 当人类的精神成长过程被重组，与奇观相伴而来的是所有拥有母校的人们是否都可能产生让我们精神紧张的感念。那个因为远离世俗功利，因此总是储存着我们美好回忆的地方；那个因为身在成长中的朦胧，因此总是友情似水又不由分说地规定了我们生命的节律的地方；那些曾经属于每一个人幼儿园里的青梅竹马，属于每个人小学、中学的两小无猜，属于每一个人大学校园里林荫树下的恋情又将会在哪里？","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"},{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/tags/互联网/"}]},{"title":"回顾老男孩","slug":"dream","date":"2016-09-22T16:55:17.000Z","updated":"2017-03-06T07:55:04.000Z","comments":true,"path":"2016/09/23/dream/","link":"","permalink":"http://yoursite.com/2016/09/23/dream/","excerpt":"","text":"老男孩是在高二的时候语文老师在全班同学面前播放的一部微电影，当时看的感觉更多是有点意思，没有太多的伤感和感动。今天是大学毕业的第一年，恍然已经六年过去了，今天晚上突然有点怀旧，再次回顾这部微电影，就差稀里糊涂的哭出来了，整个心都酥了，都软了。现在想来，QQ空间的说说有一年多没有更新了，我也从曾经的个性张扬，调皮的学生转变为了一名职业人士，开始了自己的职业生活。曾经的老同学不知道会在什么时候突然联系一下，也都有各自的生活了吧，相见不如怀念，让自己更好是现在的最重要的事吧。审视一下自己的青春，觉得自己的幸运的，犯过无数的错误却总是有改正的机会；经历了老师眼中好学生与坏学生的模样；惹出过很多争议；也曾经失去过自己，又找回了自己；曾经束缚过自己，也在后来找回了自由；身边的朋友有学霸也有学渣；我也算一朵奇葩吧，这一路走来，幸运，感恩！我现在也是在从小男孩转变为老男孩的路上，怀揣着自己的梦想，在追求自我实现的路上；生活确实是一把无情的刻刀，改变了我的模样，不变的是和经典一样的梦想。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"互联网时代-再构观后感","slug":"internet","date":"2016-09-17T14:49:00.000Z","updated":"2017-03-11T14:44:46.000Z","comments":true,"path":"2016/09/17/internet/","link":"","permalink":"http://yoursite.com/2016/09/17/internet/","excerpt":"","text":"每一次看过视频后都很有启发，这一次也不例外，互联网再构这部视频用了四十分钟全面而详细的向我们阐述了再构的一前一后，怎么理解再构，顾名思义，再构就是再一次构建，是指互联网时代的到来，其影响不仅仅是局限于科技，局限于技术，局限于社会表面，其对我们的生活的影响是彻底的，巨大的，从菲特台风的案例，黄灯的故事，李明博事件，可汗学院的建立，奥巴马选举的成功等实例都反映了互联网影响的是人与人之间，人与权利之间，人与社会之间，人与人周围的一切关系。就像视频中说的那样，一就是无限，每一个声音都面对着世界，每一滴水珠都等同于大海。 ，这要求我们要不断的学习，要与时俱进，顺势而为，在互联网时代的浪潮里构建的新的社会体系中更好的存活。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"},{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/tags/互联网/"}]},{"title":"javascript高级编程-Array引用类型用法总结","slug":"javascriptArray","date":"2016-09-16T16:56:47.000Z","updated":"2017-03-24T12:41:54.000Z","comments":true,"path":"2016/09/17/javascriptArray/","link":"","permalink":"http://yoursite.com/2016/09/17/javascriptArray/","excerpt":"","text":"引用类型-Array类型引用类型是一种数据结构，用于将数据和功能联系起来。 创建对象的方式： 1.new操作符 var array = new Array() 2.字面量表示法创建 var array = [] Array1.检测数组:检测数组是基本类型还是引用类型 2.转换方法:将数组转换成字符串或数组对象 3.栈方法:后进先出的操作数组的方法 4.队列方法:先进先出的操作数组的方法 5.操作方法:数组的拼接、截取、插入、删除、替换 6.位置方法:查找数组项、返回索引值 7.迭代方法:对每个数组项进行操作的方法 8.缩小方法:操作数组的每一项，构建最终的返回值 1 检测数组 检测数组的方法；instanceof操作符的问题是当开发环境引入多个框架存在多个全局环境的时候，会出现不同的Array构造函数，进而出现不同的结果。Array.isArray()这个方法很好的解决了这个问题。 arrName instanceof Array 12var array = [1,2,3]console.log(array instanceof Array) // true Array.isArray(arrName) 1console.log(Array.isArray(array)) // true 2 转换方法 toString()：返回以逗号分隔拼接而成的字符串 valueOf()：返回对象 toLocaleString()：区别很小，如果是数组调用这个方法，那么数组的每一项都会调用这个方法 alert(value) == alert(value.toString()) 123456789var array = [1,2,3]var arrayToString = array.toString()var arrayValueOf = array.valueOf()var arrayToLocalString = array.toLocaleString()console.log(arrayToString) // 1,2,3console.log(arrayValueOf) // [1, 2, 3]console.log(arrayToLocalString) // 1,2,3 3 栈方法 (LIFO:last in first out) ES数组类似于数据结构的方法栈是一种限制插入和删除项的数据结构 push()：接收任意数量的参数添加至数组尾部，返回数组长度值 pop():从数组末尾移除最后一项，减少数组的length值，返回该数组被删除的最后一项 4 队列方法 (FIFO:first in first out) 结合push()和shift()方法可以实现像队列一样使用数组使用unshift()和pop()可以从相反的方向模拟队列 shift()移除并返回该数组的第一项； unshift()从数组前端添加任意个参数，并返回新数组的长度 5 操作方法 concat()复制原数组连接新数组形成新副本； 123var arr1 = [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;]var arr2 = [&apos;h&apos;,&apos;u&apos;,&apos;o&apos;]document.write(arr1.concat(arr2)) //q,w,e,h,u,o slice() 有一个参数时，复制参数为起始位置到末尾的副本；有两个参数时，复制两个数字中间部分的数组项；如果参数是负数，复制用数组的长度加上负数值得到的两个参数之间的数组项； 1234var arr3 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]console.log(arr3.slice(1)) // e,l,l,oconsole.log(arr3.slice(-4)) // e,l,l,oarr3.slice(-4) === arr3.slice(1) // true splice() 三个参数:分别对应起始位置，删除项的个数，替换项;通过对这三个参数的合理运用可以实现删除、插入、替换等操作。 1234567891011121314// 从第一项开始删除两项var splice_arr1 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]console.log(splice_arr1.splice(1,2)) // 返回的是被删除的项组成的数组[&quot;e&quot;, &quot;l&quot;]// 从第二项后插入三项oldvar splice_arr2 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]var removed = splice_arr2.splice(2,0,&quot;K&quot;,&quot;K&quot;)console.log(splice_arr2)//[&quot;h&quot;, &quot;e&quot;, &quot;K&quot;, &quot;K&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] console.log(removed) // 返回的是一个空数组// 替换var removed = splice_arr3.splice(2,2,&quot;P&quot;,&quot;P&quot;)console.log(splice_arr3)//[&quot;h&quot;, &quot;e&quot;, &quot;P&quot;, &quot;P&quot;, &quot;o&quot;]console.log(removed) // 返回的是被替换的值[&quot;l&quot;, &quot;l&quot;] 6 位置方法 返回索引值 indexOf() 从前往后找 lastIndexOf() 从后往前找 1234567891011// indexOf() 从前往后找// lastIndexOf() 从后往前找var index_arr = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]var indexOf_arr = index_arr.indexOf(&apos;l&apos;)console.log(&apos;原数组:&apos;,index_arr) // 原数组不变console.log(&apos;返回值:&apos;,indexOf_arr) // 返回值是第一个查到位置的索引值2var index_arr2 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]var indexOf_arr2 = index_arr2.lastIndexOf(&apos;l&apos;)console.log(&apos;原数组:&apos;,index_arr2) // 原数组不变console.log(&apos;返回值:&apos;,indexOf_arr2) // 返回值是第一个查到位置的索引值3 7 迭代方法 接收两个参数，一个是函数，另一个是运行该函数的作用域对象。 第一个参数函数接收三个参数 数组项的值 item，值的位置 idnex ，数组本身 array every() // 都是返回true则返回true 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var everyArr = numbers.every(function(it, index ,arr)&#123; if(it&gt;9)&#123; return true &#125;&#125;)console.log(everyArr) // false some() // 有一个返回true，则返回true 1234var someArr = numbers.some(function(it, index ,arr)&#123; return (it &gt; 9)&#125;)console.log(someArr) // true forEach() // 没有返回值 123456var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var forEachArr = numbers.forEach(function(it, index ,arr)&#123; var it = it*100 console.log(it)&#125;) // 无返回值 filter() // 返回该函数会返回true的项组成的数组，用于过滤 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var filterArr = numbers.filter(function(it, index ,arr)&#123; if(it&gt;10)&#123; return it &#125;&#125;)console.log(filterArr) // [65, 33, 21, 23],返回返回值组成的新数组 map()//返回每个函数的返回值 12345678var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var mapArray = numbers.map(function(it, index ,arr)&#123; var it = it*100 return it&#125;)console.log(mapArray) // [100, 200, 300, 400, 500, 600, 700, 800, 900, 0, 900, 800, 700, 6500, 500, 400, 3300, 2100, 100, 100, 2300, 300, 400],返回返回值组成的新数组 8 缩小方法 reduce() 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var allArray = numbers.reduce(function(prev,cur,index,arr)&#123; return (prev+cur)&#125;)console.log(allArray) // 229 reduceRight() 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var allArrayRight = numbers.reduceRight(function(prev,cur,index,arr)&#123; return (prev+cur)&#125;)console.log(allArrayRight) // 229 总结：经过这次总结和练习，觉得自己在以后再次遇到操作数组应该不会再感到害怕了；自己的工作中用的最多的是split()这个字符串截取的操作方法，这个方法虽然是字符串的方法但是很好用。这种总结方式，效果挺好，就是效率稍微低一点，这点咋解决啊，是个问题。。。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"我应该开始写博客了","slug":"why","date":"2016-09-06T16:02:26.000Z","updated":"2017-03-11T14:43:15.000Z","comments":true,"path":"2016/09/07/why/","link":"","permalink":"http://yoursite.com/2016/09/07/why/","excerpt":"","text":"记得在大四毕业的前夕，我在知乎上提了一个问题“为什么每次想写东西的时候都无从下笔？”。总结知友的回答，再结合自己的感受，试图剖开内心的世界，认真的拷问自己最本质的想法，自问为什么写不出来，也许六耳的回答是自己的那个样子，之所以写不出来，不是真的写不出来，而是害怕写不出好的内容，害怕比较，害怕没人看，害怕写出来的东西被别人讥讽，被别人指指点点，再加上自己是一个好面的人，在那么多外在情绪的干扰下，写不出来是很正常的了。 大四毕业了，现在的我已经正式走上了谋生的道路，正式结束了十几年的学生身份，体会到了谋生的艰辛，生活的压力，身上的责任感。自己意外的成为了一个前端开发者，自然而然的就想为自己搭建一个博客用于记录自己的生活，记录自己的技术积淀，分享自己的生活感悟，分享自己的技术，分享自己的想法，因为互联网时代的本质就是分享，我也鼓励自己要克服害怕写东西，从这种消极情绪中积极的走出来，人生不也就是因为有了奋斗和与自己搏击的过程而显得刺激而有意义吗？ 我还希望通过在写博客的过程中，思考自己的生活，尽量站在客观的角度重新认识自己，进一步了解自己。我也搜索了相关为什么要写博客的文章，如“为什么你要写博客？”借鉴他们的想法之后愈加觉得自己开始做出这个选择的正确性，我要求自己要写下去，我想让尽量多的人知道，一个叫程康建小伙子曾经来过这个世界，这个世界有他的足迹。然后当我有朝一日老的时候，如果能够阅读自己年轻时候的心态，何尝不是一件幸福的事情。 写吧！再次告诉自己！写到天荒地老海枯石烂…add oil！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://yoursite.com/tags/感悟/"}]},{"title":"新地盘 新生活 新开始.","slug":"start","date":"2016-09-03T16:19:47.000Z","updated":"2017-03-11T14:43:08.000Z","comments":true,"path":"2016/09/04/start/","link":"","permalink":"http://yoursite.com/2016/09/04/start/","excerpt":"","text":"通过hexo搭建的一个博客，虽然很简单，也是用了很长的时间，经过自己的双手敲出来的东西，可能简单了些，但是很有成就感。嗯，这是一个开始！add oil!","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://yoursite.com/tags/感悟/"}]}]}