{"meta":{"title":"程是非sky","subtitle":"简单，可信赖。 Simple and reliable.","description":"一边奔跑 一边思考","author":"程康健","url":"http://yoursite.com"},"pages":[{"title":"关于 程是非sky","date":"2016-09-04T05:24:18.000Z","updated":"2017-04-08T02:04:21.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎您来到这里，就像行星撞地球一样的几率让你我相遇 ！ 姓名：程康健 网络ID：程是非sky 现居：北京 职业：业务研发工程师(web) 爱好：足球 音乐"},{"title":"归档","date":"2017-02-14T10:12:09.000Z","updated":"2017-02-14T10:12:09.000Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-09-04T05:18:59.000Z","updated":"2017-02-05T07:24:26.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-09-04T05:20:57.000Z","updated":"2017-02-05T07:24:26.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"一段代码-递归调用的返回值问题","slug":"一段代码-递归调用的返回值问题","date":"2017-04-07T04:35:35.000Z","updated":"2017-04-07T11:58:11.000Z","comments":true,"path":"2017/04/07/一段代码-递归调用的返回值问题/","link":"","permalink":"http://yoursite.com/2017/04/07/一段代码-递归调用的返回值问题/","excerpt":"","text":"今天写一个递归函数，获取的返回值不是自己想要的结果，而是undefined，困扰了我很久。 1234567891011function recuFunc(val) &#123; if (val &gt; 10) &#123; return val &#125; else &#123; recuFunc(val + 1) &#125;&#125;let res = recuFunc(1)console.log(res) //undefined 思考了许久，终于发现了问题之所在。 1234567891011function recuFunc(val) &#123; if (val &gt; 10) &#123; return val &#125; else &#123; return recuFunc(val + 1) &#125;&#125;let res = recuFunc(1)console.log(res) //11 仅仅在递归调用的函数前面加上return,问题迎刃而解。究其原因，简单说就是函数体没有返回值，自然结果是undefined。最初我以为当我执行到val &gt; 10的时候，return val 此时就能得到想要的结果，那是我对递归算法的理解不够。现在想来，其实递归函数就像一个同心圆一样，一层函数嵌套着一层函数，当边界条件被满足时，return val返回给最里层的函数，如果函数前不加return,但是这个函数结果没有被返回,它的上层函数就没有返回值，其结果就是undefined了。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"}]},{"title":"一段代码-检测JS对象值是否为空","slug":"isEmptyValue","date":"2017-04-01T12:03:46.000Z","updated":"2017-04-01T12:44:56.000Z","comments":true,"path":"2017/04/01/isEmptyValue/","link":"","permalink":"http://yoursite.com/2017/04/01/isEmptyValue/","excerpt":"","text":"前端在开发过程中，经常会遇到后端传过来的数据为空的情况，如果我知道确定的数据类型还比较容易判断，但有时候类型是不确定的，比如数组类型，在数组为空的时候，不知道返回的是[] 还是 null，这个时候如果冒然的使用Array.length()进行判断，当返回的空数组的值不是[]而是null时就会出现问题。 于是我就想写段代码，去检测数据是否为空，以后直接调用它便是。 我将如下的数据值定义为空值，其他值便为非空值。 [] {} ‘’ ‘ ‘ null undefined 由于在JavaScript中的所有事物都是对象，所以需要先进行对象类型的判断，然后再根据不同的类型进行处理。typeof主要进行基本数据类型的检测，在这里不适用。考虑到javascript安全的类型监测，所以在这里如果使用instanceof在多个JS框架环境中使用并不保险。所以安全起见，还是使用Object.prototype.toString.call()比较靠谱。 下面就根据以上的想法产出了下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738function isEmptyVal (val) &#123; let type; let isEmptyObj = function (obj) &#123; for (let name in val) &#123; return false; &#125; return true &#125; type = Object.prototype.toString.call(val).slice(8, -1) switch (type) &#123; case &apos;Array&apos;: return !val.length case &apos;String&apos;: return !val.trim() case &apos;Object&apos;: return isEmptyObj(val) case &apos;Null&apos;: return true case &apos;Undefined&apos;: return true default: return false &#125;&#125;let isEmptyVal1 = isEmptyVal(&apos;&apos;)let isEmptyVal2 = isEmptyVal(&#123;&#125;)let isEmptyVal3 = isEmptyVal([])let isEmptyVal4 = isEmptyVal(null)let isEmptyVal5 = isEmptyVal(undefined)let isEmptyVal6 = isEmptyVal(&apos; &apos;)console.log(isEmptyVal1) //trueconsole.log(isEmptyVal2) //trueconsole.log(isEmptyVal3) //trueconsole.log(isEmptyVal4) //trueconsole.log(isEmptyVal5) //trueconsole.log(isEmptyVal6) //true","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"YOU MIGHT NOT NEED JQUERY","slug":"do-not-need-jquery","date":"2017-03-23T15:18:45.000Z","updated":"2017-03-25T14:02:29.000Z","comments":true,"path":"2017/03/23/do-not-need-jquery/","link":"","permalink":"http://yoursite.com/2017/03/23/do-not-need-jquery/","excerpt":"","text":"jQuery and its cousins are great, and by all means use them if it makes it easier to develop your application. If you’re developing a library on the other hand, please take a moment to consider if you actually need jQuery as a dependency. Maybe you can include a few lines of utility code, and forgo the requirement. If you’re only targeting more modern browsers, you might not need anything more than what the browser ships with. At the very least, make sure you know what jQuery is doing for you, and what it’s not. Some developers believe that jQuery is protecting us from a great demon of browser incompatibility when, in truth, post-IE8, browsers are pretty easy to deal with on their own. 1 AJAXJSONJQUERY123$.getJson(&apos;/my/url&apos;, function () &#123; &#125;); IE9+12345678910111213141516var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function () &#123; if(request.status &gt; 200 &amp;&amp; request.status &lt; 400) &#123; // Success! var data = JSON.parse(request.responseText) &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;request.onerror = function () &#123; // There was a connection error of some sort&#125;request.send(); PostJQUERY12345$.ajax(&#123; type: &apos;POST&apos;, url: &apos;/my/url&apos;, data: data&#125;); IE8+1234var request = new XMLHttpRequest();request.open(&apos;POST&apos;, &apos;/my/url&apos;, true);request.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);request.send(data); RequestJQUERY12345678910$.ajax(&#123; type: &apos;GET&apos;, url: &apos;/my/url&apos;, success: function(resp) &#123; &#125;, error: function() &#123; &#125;&#125;); IE8+123456789101112131415161718var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function() &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! var resp = request.responseText; &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;;request.onerror = function() &#123; // There was a connection error of some sort&#125;;request.send(); 2 EFFECTSFade InJQUERY1$(el).fadeIn(); IE9+1234567891011121314151617function fadeIn(el) &#123; el.style.opacity = 0; var last = +new Date(); var tick = function() &#123; el.style.opacity = +el.style.opacity + (new Date() - last) / 400; last = +new Date(); if (+el.style.opacity &lt; 1) &#123; (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16); &#125; &#125;; tick();&#125;fadeIn(el); HideJQUERY1$(el).hide(); IE8+1el.style.display = &apos;none&apos;; ShowJQUERY1$(el).show(); IE8+1el.style.display = &apos;&apos;; 3 ELEMENTSAdd ClassJQUERY1$(el).addClass(className); IE8+1234if (el.classList) el.classList.add(className);else el.className += &apos; &apos; + className; AfterJQUERY1$(el).after(htmlString); IE8+1el.insertAdjacentHTML(&apos;afterend&apos;, htmlString); AppendJQUERY1$(parent).append(el); IE8+1parent.appendChild(el); BeforeJQUERY1$(el).before(htmlString); IE8+1el.insertAdjacentHTML(&apos;beforebegin&apos;, htmlString); ChildrenJQUERY1$(el).children(); IE9+1el.children CloneJQUERY1$(el).clone(); IE8+1el.cloneNode(true); ContainsJQUERY1$.contains(el, child); IE8+1el !== child &amp;&amp; el.contains(child); Contains SelectorJQUERY1$(el).find(selector).length; IE8+1el.querySelector(selector) !== null EachJQUERY123$(selector).each(function(i, el)&#123;&#125;); IE9+1234var elements = document.querySelectorAll(selector);Array.prototype.forEach.call(elements, function(el, i)&#123;&#125;); EmptyJQUERY1$(el).empty(); IE9+1el.innerHTML = &apos;&apos;; FilterJQUERY1$(selector).filter(filterFn); IE9+1Array.prototype.filter.call(document.querySelectorAll(selector), filterFn); Find ChildrenJQUERY1$(el).find(selector); IE8+1el.querySelectorAll(selector); Find ElementsJQUERY1$(&apos;.my #awesome selector&apos;); IE8+1document.querySelectorAll(&apos;.my #awesome selector&apos;); Get AttributesJQUERY1$(el).attr(&apos;tabindex&apos;); IE8+1el.getAttribute(&apos;tabindex&apos;); Get HtmlJQUERY1$(el).html(); IE8+1el.innerHTML Get Outer HtmlJQUERY1$(&apos;&lt;div&gt;&apos;).append($(el).clone()).html(); IE8+1el.outerHTML Get StyleJQUERY1$(el).css(ruleName); IE9+1getComputedStyle(el)[ruleName]; Get TextJQUERY1$(el).text(); IE9+1el.textContent Has ClassJQUERY1$(el).hasClass(className); IE8+1234if (el.classList) el.classList.contains(className);else new RegExp(&apos;(^| )&apos; + className + &apos;( |$)&apos;, &apos;gi&apos;).test(el.className); MatchesJQUERY1$(el).is($(otherEl)); IE8+1el === otherEl Matches SelectorJQUERY1$(el).is(&apos;.my-class&apos;); IE9+12345var matches = function(el, selector) &#123; return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);&#125;;matches(el, &apos;.my-class&apos;); NextJQUERY1$(el).next(); IE9+1el.nextElementSibling OffsetJQUERY1$(el).offset(); IE8+123456var rect = el.getBoundingClientRect();&#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft&#125; Offset ParentJQUERY1$(el).offsetParent(); IE8+1el.offsetParent || el Outer HeightJQUERY1$(el).outerHeight(); IE8+1el.offsetHeight Outer Height With MarginJQUERY1$(el).outerHeight(true); IE9+123456789function outerHeight(el) &#123; var height = el.offsetHeight; var style = getComputedStyle(el); height += parseInt(style.marginTop) + parseInt(style.marginBottom); return height;&#125;outerHeight(el); Outer WidthJQUERY1$(el).outerWidth(); IE8+1el.offsetWidth Outer Width With MarginJQUERY1$(el).outerWidth(true); IE9+123456789function outerWidth(el) &#123; var width = el.offsetWidth; var style = getComputedStyle(el); width += parseInt(style.marginLeft) + parseInt(style.marginRight); return width;&#125;outerWidth(el); ParentJQUERY1$(el).parent(); IE8+1el.parentNode PositionJQUERY1$(el).position(); IE8+1&#123;left: el.offsetLeft, top: el.offsetTop&#125; Position Relative To ViewportJQUERY123456var offset = el.offset();&#123; top: offset.top - document.body.scrollTop, left: offset.left - document.body.scrollLeft&#125; IE8+1el.getBoundingClientRect() PrependJQUERY1$(parent).prepend(el); IE8+1parent.insertBefore(el, parent.firstChild); PrevJQUERY1$(el).prev(); IE9+1el.previousElementSibling RemoveJQUERY1$(el).remove(); IE8+1el.parentNode.removeChild(el); Remove ClassJQUERY1$(el).removeClass(className); IE8+1234if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;); Replace From HtmlJQUERY1$(el).replaceWith(string); IE8+1el.outerHTML = string; Set AttributesJQUERY1$(el).attr(&apos;tabindex&apos;, 3); IE8+1el.setAttribute(&apos;tabindex&apos;, 3); Set HtmlJQUERY1$(el).html(string); IE8+1el.innerHTML = string; Set StyleJQUERY1$(el).css(&apos;border-width&apos;, &apos;20px&apos;); IE8+12// Use a class if possibleel.style.borderWidth = &apos;20px&apos;; Set TextJQUERY1$(el).text(string); IE9+1el.textContent = string; SiblingsJQUERY1$(el).siblings(); IE8+123Array.prototype.filter.call(el.parentNode.children, function(child)&#123; return child !== el;&#125;); Toggle ClassJQUERY1$(el).toggleClass(className); IE9+12345678910111213if (el.classList) &#123; el.classList.toggle(className);&#125; else &#123; var classes = el.className.split(&apos; &apos;); var existingIndex = classes.indexOf(className); if (existingIndex &gt;= 0) classes.splice(existingIndex, 1); else classes.push(className); el.className = classes.join(&apos; &apos;);&#125; 4 EVENTSOffJQUERY1$(el).off(eventName, eventHandler); IE9+1el.removeEventListener(eventName, eventHandler); OnJQUERY1$(el).on(eventName, eventHandler); IE9+1el.addEventListener(eventName, eventHandler); ReadyJQUERY123$(document).ready(function()&#123;&#125;); IE9+1234567function ready(fn) &#123; if (document.readyState != &apos;loading&apos;)&#123; fn(); &#125; else &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, fn); &#125;&#125; Trigger CustomJQUERY1$(el).trigger(&apos;my-event&apos;, &#123;some: &apos;data&apos;&#125;); IE9+12345678if (window.CustomEvent) &#123; var event = new CustomEvent(&apos;my-event&apos;, &#123;detail: &#123;some: &apos;data&apos;&#125;&#125;);&#125; else &#123; var event = document.createEvent(&apos;CustomEvent&apos;); event.initCustomEvent(&apos;my-event&apos;, true, true, &#123;some: &apos;data&apos;&#125;);&#125;el.dispatchEvent(event); Trigger NativeJQUERY1$(el).trigger(&apos;change&apos;); IE9+1234// For a full list of event types: https://developer.mozilla.org/en-US/docs/Web/API/document.createEventvar event = document.createEvent(&apos;HTMLEvents&apos;);event.initEvent(&apos;change&apos;, true, false);el.dispatchEvent(event); 5 UTILSBindJQUERY1$.proxy(fn, context); IE9+1fn.bind(context); Array EachJQUERY123$.each(array, function(i, item)&#123;&#125;); IE9+123array.forEach(function(item, i)&#123;&#125;); Deep ExtendJQUERY1$.extend(true, &#123;&#125;, objA, objB); IE8+1234567891011121314151617181920212223var deepExtend = function(out) &#123; out = out || &#123;&#125;; for (var i = 1; i &lt; arguments.length; i++) &#123; var obj = arguments[i]; if (!obj) continue; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] === &apos;object&apos;) out[key] = deepExtend(out[key], obj[key]); else out[key] = obj[key]; &#125; &#125; &#125; return out;&#125;;deepExtend(&#123;&#125;, objA, objB); ExtendJQUERY1$.extend(&#123;&#125;, objA, objB); IE8+1234567891011121314151617var extend = function(out) &#123; out = out || &#123;&#125;; for (var i = 1; i &lt; arguments.length; i++) &#123; if (!arguments[i]) continue; for (var key in arguments[i]) &#123; if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key]; &#125; &#125; return out;&#125;;extend(&#123;&#125;, objA, objB); Index OfJQUERY1$.inArray(item, array); IE9+1array.indexOf(item); Is ArrayJQUERY1$.isArray(arr); IE9+1Array.isArray(arr); MapJQUERY123$.map(array, function(value, index)&#123;&#125;); IE8+123array.map(function(value, index)&#123;&#125;); NowJQUERY1$.now(); IE9+1Date.now(); Parse HtmlJQUERY1$.parseHTML(htmlString); IE9+1234567var parseHTML = function(str) &#123; var tmp = document.implementation.createHTMLDocument(); tmp.body.innerHTML = str; return tmp.body.children;&#125;;parseHTML(htmlString); Parse JsonJQUERY1$.parseJSON(string); IE8+1JSON.parse(string); TrimJQUERY1$.trim(string); IE9+1string.trim(); TypeJQUERY1$.type(obj); IE8+1Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, &apos;$1&apos;).toLowerCase();","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS对象的深拷贝和浅拷贝","slug":"JS对象的深拷贝和浅拷贝","date":"2017-03-15T10:35:42.000Z","updated":"2017-03-16T02:07:05.000Z","comments":true,"path":"2017/03/15/JS对象的深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2017/03/15/JS对象的深拷贝和浅拷贝/","excerpt":"","text":"我们在对数据进行备份的时候，如果这个数据是基本的数据类型，那么很好办，通过赋值实现复制即可。 如果在使用JavaScript对数组或对象进行操作的时候，我们经常需要将数组或对象进行备份，事实证明如果只是简单的将它赋予其他变量，那么我们只要更改其中的任何一个，然后其他的也会跟着改变，这就导致了问题的发生。 这个问题就是深拷贝和浅拷贝的问题。 浅拷贝但是当遇到引用数据类型时，就需要三思而复制，操作而三思。1234567891011let obj1 = &#123; a: 1, b: 2&#125;let obj2 = obj1obj2.b = 3console.log(obj1) // &#123; a: 1, b: 3 &#125;console.log(obj1 === obj2) //true 在这里我只是想obj2复制obj1,当我对obj2进行操作时，obj1的值也发生了变化。换句话说就是因为如果只是简单的赋值，它只是进行了地址的引用，所以改变一个对象另一个对象也会跟着变。上面这种直接赋值方式的复制称之为浅拷贝。 深拷贝我在想如何让obj2复制obj1的对象内容，在我对obj2进行修改时，不影响obj1，下面总结两个方法，可以在不同情况下使用。 1. JSON.parse(JSON.stringify(obj))利用JSON的方式进行浅层次序列化对象进行深拷贝是一个很好的方法。 12345678910let obj1 = &#123; a: 1, b: 2&#125;let obj3 = JSON.parse(JSON.stringify(obj1))obj3.b = 5console.log(obj1) //&#123; a: 1, b: 2 &#125;console.log(obj1 === obj3) //false 但是JSON的方式有局限性，就是对象必须遵从JSON的格式，当遇到层级较深，且序列化对象不完全符合JSON格式时，使用JSON的方式进行深拷贝就会出现问题。 123456789let obj1 = &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: function func() &#123;&#125;&#125;let obj4 = JSON.parse(JSON.stringify(obj1))console.log(obj4) //&#123; a: &apos;1&apos;, b: &apos;2&apos; &#125; 好像漏了些什么😄 2. 一段深拷贝的代码其实实现对象的深拷贝，只需要把父对象的属性，全部拷贝给子对象，就可以实现复拷贝。1234567function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125; 但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 当对象层级较深，且序列化对象不完全符合JSON格式时，这个时候就需要通过递归调用”浅拷贝”来解决。 12345678910111213141516171819202122232425262728let obj1 = &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: function aa () &#123;&#125;&#125;function deepCopy(obj) &#123; if(typeof obj === &quot;object&quot;) &#123; if(obj.constructor === Array) &#123; var newArr = [] for(var i = 0; i &lt; obj.length; i++) newArr.push(obj[i]) return newArr &#125; else &#123; var newObj = &#123;&#125; for(var key in obj) &#123; newObj[key] = this.deepCopy(obj[key]) &#125; return newObj &#125; &#125; else &#123; return obj &#125;&#125;console.log(deepCopy(obj1)) //&#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: [Function: aa] &#125; 继续简化一下… 123456789101112131415161718let obj1 = &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: function aa () &#123;&#125;&#125;function deepCopy (obj) &#123; let temp = obj.constructor === Array ? [] : &#123;&#125; for (let val in obj) &#123; temp[val] = typeof obj[val] == &apos;object&apos; ? deepCopy(obj[val]) : obj[val] &#125; return temp&#125;console.log(deepCopy(obj1)) //&#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &#123; d: &apos;3&apos; &#125;, d: [Function: aa] &#125; 总结在实际开发中，关于对象复制的问题是经常遇到的。最常见的是对对象的复制，重新定义，扩展等。掌握浅拷贝和深拷贝的区别以及如何进行深拷贝，以及选择哪个方式进行深拷贝，会节省许多debug时间，避免很多不必要的麻烦。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"记一次敏捷开发Scrum培训及实践的感受","slug":"敏捷开发Scrum培训及实践总结","date":"2017-03-11T14:24:13.000Z","updated":"2017-03-11T14:42:25.000Z","comments":true,"path":"2017/03/11/敏捷开发Scrum培训及实践总结/","link":"","permalink":"http://yoursite.com/2017/03/11/敏捷开发Scrum培训及实践总结/","excerpt":"","text":"在2016年10月26日，部门请到了亚信的内训师，亚信国际的王林皓讲师来给我们BDX的大数据云平台部和数据产品线专门培训敏捷开发Scrum。王老师很早以前就是Scrum Master，带过很多敏捷的团队，在Scrum方面有丰富的经验。 作为自己在这个培训之前，通过工作中的体会和一些资料的阅读，我对敏捷开发也有一点点的认识。知道敏捷开发的敏捷性，小步代跑的过程能够根据不断变化的需求快速响应。 在当天培训中，讲师通过八个章节的内容介绍，中间穿插着一系列的活动作示例，并结合理论的讲解，让我听得受益匪浅，对敏捷开发有了新的认知。 首先，讲师介绍敏捷的五大要素（勇气、开放、承诺、专注、尊重）过程中，自己其实是挺感慨的，自己参与了一年左右的敏捷开发流程，却不知道自己需要以一种怎样的态度来参与敏捷。以上的五大要素中，在自己目前的实践中，自己在勇气和开放方面做的最不好，对于今后，会通过各个击破的方式一项一项整体提高这五大要素的要求。 现在是处于互联网的时代，在这个时代下要求产品的研发要快、准、狠才能跟的上跟得上市场的步伐。敏捷原则和思维刚刚好解释了在这个时代下选择敏捷开发是因为开发需要敏捷这个特性。敏捷不是一个方法论、过程或者框架，敏捷是一种思维。这个思维特性要求自己以一种开放的心态不断的学习和改变来适应周围的变化。 讲师通过一系列的活动实践告诉我们实践敏捷的价值就是优先做最有价值的事，虽然这并不容易做到，这要求参与敏捷的每个人都要拥有共同的价值观，大家齐心协力在一个方向上努力。除非需求的市场前景特别明晰，不然需求价值的大小有时候并不容易统一，这在实践过程中是有挑战的。通过敏捷实践价值这节的学习，要求自己在今后了解自己工作内容的价值，这样应该会让自己更好的开展工作。 通过对scrum的特征、框架、团队方面内容的学习，让我对敏捷开发的认识比较全面。在透明性、跨职能、自组织三个特征中， 目前团队的敏捷实践对这些特征没有明显的体现，可见，我们需要改进的地方还有很多。个人角度来看，需要先从自己的心态上、行为上逐渐的去改变。 讲师在讲解的过程中，也通过提出一个问题引发我们的思考最后解决问题来引起我们的共鸣。有个问题令我印象深刻，“每周计划制定之后，计划外的任务打乱原计划时，计划如何调整？”,因为这个问题目前正在发生，我们的方式是尽量赶计划，实在完成不了计划就会延迟。老师给出”进多少，出多少“的方案是比较客观合理的。 在敏捷开发过程中，有一块内容是我感觉非常困难的，就是敏捷估算。虽然讲师告诉我们不要绝对估算，要使用相对估算的方法，即使这样估算起来还是摸不着头脑。比如在从用户故事进行任务量估算，完全是凭感觉来的，估算的值很不准确，这方面可能随着业务经验的增长会逐渐变好吧。 本次培训是能够引发自己思考的一次培训，因为这和每天的工作息息相关，讲的内容也容易接受。但是理论和实践总是存在着一定的距离。王阳明有句话说：”知之真切笃实处即是行，行之明觉精察处即是知。“，我们下一个目标就是将所学所用付诸于实践，在未来，我们通过点滴的不断的改变不足之处、实践、调整、反思、再实践，团队最终肯定会实现规范的、适合团队的、有效的敏捷开发。","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"},{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://yoursite.com/tags/敏捷开发/"}]},{"title":"终身受用的世界顶尖思维","slug":"终身受用的世界顶尖思维","date":"2017-03-10T14:08:46.000Z","updated":"2017-03-11T14:44:00.000Z","comments":true,"path":"2017/03/10/终身受用的世界顶尖思维/","link":"","permalink":"http://yoursite.com/2017/03/10/终身受用的世界顶尖思维/","excerpt":"","text":"1 素养蓝斯登原则：在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。 提出者：美国管理学家蓝斯登。 点评：进退有度，才不至进退维谷;宠辱皆忘，方可以宠辱不惊。 卢维斯定理：谦虚不是把自己想得很糟，而是完全不想自己。 提出者：美国心理学家h.卢维斯。 点评：如果把自己想得太好，就很容易将别人想得很糟。 托利得定理：测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想而无碍于其处世行事。 提出者：法国社会心理学家h.m.托利得。 点评：思可相反，得须相成。 2 统御刺猬理论：刺猬在天冷时彼此靠拢取暖，但保持一定距离，以免互相刺伤。 点评：保持亲密的重要方法，乃是保持适当的距离。 鲦鱼效应：鲦鱼因个体弱小而常常群居，并以强健者为自然首领。将这条首领鲦鱼脑后控制行为的部分割除后，此鱼便失去自制力，行动也发生紊乱，但其他鲦鱼却仍像从前一样盲目追随。 提出者：德国动物学家霍斯特。 点评： 1、下属的悲剧总是领导一手造成的。 2、下属觉得最没劲的事，是他们跟着一位最差劲的领导。 雷鲍夫法则：在你着手建立合作和信任时要牢记我们语言中： 1、最重要的八个字是：我承认我犯过错误。 2、最重要的七个字是：你干了一件好事! 3、最重要的六个字是：你的看法如何? 4、最重要的五个字是：咱们一起干! 5、最重要的四个字是：不妨试试! 6、最重要的三个字是：谢谢您! 7、最重要的两个字是：咱们。 8、最重要的一个字是：您。 提出者：美国管理学家雷鲍夫。 点评：记住经常使用，它会让你事半功倍。 洛伯定理：对于一个经理人来说，最要紧的不是你在场时的情况，而是你不在场时发生了什么。 提出者：美国管理学家r.洛伯。 点评：如果只想让下属听你的，那么当你不在身边时他们就不知道应该听谁的了。 3 沟通斯坦纳定理：在哪里说得愈少，在那里听到的就愈多。 提出者：美国心理学家s.t.斯坦纳。 点评：只有很好听取别人的，才能更好说出自己的。 费斯诺定理：人两只耳朵却只有一张嘴巴，这意味着人应该多听少讲。 提出者：英国联合航空公司总裁兼总经理l.费斯诺。 点评：说得过多了，说的就会成为做的障碍。 牢骚效应：凡是公司中有对工作发牢骚的人，那家公司或老板一定比没有这种人或有这种人而把牢骚埋在肚子里公司要成功得多。 提出者：美国密歇根大学社会研究院 1、牢骚是改变不合理现状的催化剂。 2、牢骚虽不总是正确的，但认真对待牢骚却总是正确的。 避雷针效应：在高大建筑物顶端安装一个金属棒，用金属线与埋在地下的一块金属板连接起来，利用金属棒的尖端放电，使云层所带的电和地上的电逐渐中和，从而保护建筑物等避免雷击。 点评：善疏则通，能导必安。 4 协调氨基酸组合效应：组成人体蛋白的8种氨基酸，只要有一种含量不足，其他7种就无法合成蛋白质。 点评：当缺一不可时，一就是一切。 米格-25效应：前苏联研制的米格-25喷气式战斗机的许多零部件与美国的相比都落后，但因设计者考虑了整体性能，故能在升降、速度、应急反应等方面成为当时世界一流。 点评：所谓最佳整体，乃是个体的最佳组合。 磨合效应：新组装的机器，通过一定时期的使用，把磨擦面上的加工痕迹磨光而变得更加密合。 点评：要想达到完整的契合，须双方都做出必要的割舍。 5 指导波特定理：当遭受许多批评时，下级往往只记住开头的一些，其余就不听了，因为他们忙于思索论据来反驳开头的批评。 提出者：英国行为学家l.w.波特 点评：总盯着下属的失误，是一个领导者的最大失误。 蓝斯登定律：跟一位朋友一起工作，远较在父亲之下工作有趣得多。 提出者：美国管理学家蓝斯登 点评：可敬不可亲，终难敬;有权没有威，常失权。 吉尔伯特法则：工作危机最确凿的信号，是没有人跟你说该怎样做。 提出者：英国人力培训专家b.吉尔伯特 点评：真正危险的事，是没人跟你谈危险。 权威暗示效应：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖15秒后，前排学生即举手，称自己闻到臭气，而后排的人则陆续举手，纷纷称自己也已闻到，其实瓶中什么也没有。 点评：迷信则轻信，盲目必盲从。 6 组织奥尼尔定理：所有的政治都是地方的。 提出者：美国前众议院院长奥尼尔 点评：只有能切身体会到的，群众才认为那是真实的。 定位效应：社会心理学家曾作过一个试验：在召开会议时先让人们自由选择位子，之后到室外休息片刻再进入室内入座，如此五至六次，发现大多数人都选择他们第一次坐过的位子。 点评：凡是自己认定的，人们大都不想轻易改变它。 艾奇布恩定理：如果你遇见员工而不认得，或忘了他的名字，那你的公司就太大了点。 提出者：英国史蒂芬。约瑟剧院导演亚伦。 点评：摊子一旦铺得过大，你就很难把它照顾周全。 7 培养吉格勒定理：除了生命本身，没有任何才能不需要后天的锻炼。 提出者：美国培训专家吉格•吉格勒 点评：水无积无辽阔，人不养不成才。 犬獒效应：当年幼的藏犬长出牙齿并能撕咬时，主人就把它们放到一个没有食物和水的封闭环境里让这些幼犬自相撕咬，最后剩下一只活着的犬，这只犬称为獒。据说十只犬才能产生一只獒。 点评：困境是造就强者的学校。 8 选拔近因效应：最近或最后的印象对人的认知有强烈的影响。 提出者：美国社会心理学家洛钦斯。 点评：结果往往会被视为过程的总结。 酒井法则：在招工时用尽浑身解数，使出各种方法，不如使自身成为一个好公司，这样人才自然而然会汇集而来。 提出者：日本企业管理顾问酒井正敬。 点评：不能吸引人才，已有的人才也留不住 美即好效应：对一个外表英俊漂亮的人，人们很容易误认为他或她的其他方面也很不错。 提出者：美国心理学家丹尼尔•麦克尼尔。 点评：印象一旦以情绪为基础，这一印象常会偏离事实。 9 任用奥格尔维法则：如果我们每个人都雇用比我们自己都更强的人，我们就能成为巨人公司。 提出者：美国奥格尔维。马瑟公司总裁奥格尔维。 点评：如果你所用的人都比你差，那么他们就只能做出比你更差的事情。 皮尔卡丹定理：用人方面一加一不等于二，搞不好等于零。 提出者：法国著名企业家皮尔•卡丹。 点评：组合失当，常失整体优势，安排得宜，才成最佳配置。 10 激励马蝇效应：再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。 点评：有正确的刺激，才会有正确的反应。 倒u形假说：当一个人处于轻度兴奋时，能把工作做得最好。当一个人一点儿兴奋都没有时，也就没有做好工作的动力了;相应地，当一个人处于极度兴奋时，随之而来的压力可能会使他完不成本该完成的工作。 世界网坛名将贝克尔之所以被称为常胜将军，其秘诀之一即是在比赛中自始至终防止过度兴奋，而保持半兴奋状态。所以有人也将倒u形假说称为“贝克尔境界”。 提出者：英国心理学家罗伯特•耶基斯和多德林。 点评： 1、激情过热，激情就会把理智烧光。 2、热情中的冷静让人清醒，冷静中的热情使人执着。 11 调研特伯论断：在数字中找不到安全。 提出者：美国经济学家w.s.特伯。 点评：数字是死的，情况是活的。 摩斯科定理：你得到的第一个回答，不一定是最好的回答。 提出者：美国管理学家r.摩斯科。 点评：刨根得根，问底知底。 12 预测罗杰斯论断：成功的公司不会等待外界的影响来决定自己的命运，而是始终向前看。 提出者：美国IBM公司前总裁p.罗杰斯。 点评：只想随波逐流，难有理想彼岸。 萨盖定律：戴一块手表的人知道准确的时间，戴两块手表的人便不敢确定几点了。 提出者：英国心理学家p.萨盖。 点评：若选错误参照，必无正确比较。 隧道视野效应：一个人若身处隧道，他看到的就只是前后非常狭窄的视野。 点评： 1、不拓心路，难开视野。 2、视野不宽，脚下的路也会愈走愈窄。 13 目标巴菲特定律：在其他人都投了资的地方去投资，你是不会发财的。 提出者：美国股神巴菲特。 点评： 1、善于走自己的路，才可能走别人没走过的路。 2、特色不特，优势无优。 古特雷定理：每一处出口都是另一处的入口。 提出者：美国管理学家w.古特雷。 点评：上一个目标是下一个目标的基础，下一个目标是上一个目标的延续。 14 计划列文定理：那些犹豫着迟迟不能作出计划的人，通常是因为对自己的能力没有把握。 提出者：法国管理学家p.列文。 点评：如果没有能力去筹划，就只有时间去后悔了。 弗洛斯特法则：在筑墙之前应该知道把什么圈出去，把什么圈进来。 提出者：美国思想家w.p.弗洛斯特 点评：开始就明确了界限，最终就不会作出超越界限的事来。 15 参谋波克定理：只有在争辩中，才可能诞生最好的主意和最好的决定。 提出者：美国庄臣公司总经理詹姆士•波克。 点评：无磨擦便无磨合，有争论才有高论。 韦奇定理：即使你已有了主见，但如果有十个朋友看法和你相反，你就很难不动遥 提出者：美国洛杉矶加州大学经济学家伊渥•韦奇。 点评： 1、未听之时不应有成见，既听之后不可无主见。 2、不怕开始众说纷纭，只怕最后莫衷一是。 16 决策福克兰定律：没有必要作出决定时，就有必要不作决定。 提出者：法国管理学家d.l.福克兰。 点评：当不知如何行动时，最好的行动就是不采取任何行动。 王安论断：犹豫不决固然可以免去一些做错事的机会，但也失去了成功的机遇。 提出者：美籍华裔企业家王安博士。 点评：寡断能使好事由好变坏，果断可将危机转危为安。 17 执行格瑞斯特定理：杰出的策略必须加上杰出的执行才能奏效。 提出者：美国企业家h.格瑞斯特。 点评：好事干实更好，实事办好愈实。 吉德林法则：把难题清清楚楚地写出来，便已经解决了一半。 提出者：美国通用汽车公司管理顾问查尔斯•吉德林。 点评：杂乱无章的思维，不可能产生有条有理的行动。 18 信息沃尔森法则：把信息和情报放在第一位，金钱就会滚滚而来。 提出者：美国企业家s.m.沃尔森。 点评：你能得到多少，往往取决于你能知道多少。 塔马拉效应：塔马拉是捷克雷达专家弗。佩赫发明的一种雷达，它与其他雷达的最大不同是不发射信号而只接收信号，故不会被敌方反雷达装置发现。 点评：善藏者人不可知，能知者人无以藏。 19 监督小池定理：越是沉醉，就越是抓住眼前的东西不放。 提出者：日本管理学家小池敬。 点评：自我陶醉不易清醒，自以为是不喜批评。 赫勒法则：当人们知道自己的工作成绩有人检查的时候会加倍努力。 提出者：英国管理学家h.赫勒。 点评：只有在相互信任的情况下，监督才会成为动力。 来源：TED演讲","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"}]},{"title":"我们这一代如何学习","slug":"我们这一代如何学习","date":"2017-03-09T01:50:42.000Z","updated":"2017-03-09T05:30:07.000Z","comments":true,"path":"2017/03/09/我们这一代如何学习/","link":"","permalink":"http://yoursite.com/2017/03/09/我们这一代如何学习/","excerpt":"","text":"我们这一代人都有知识焦虑，知识总量越来越大，负担越来越沉重，时间也越来越碎片化。那我们这一代人应该怎么学习？我给大家五个建议，也就是五个关键词。 1 人格第一个关键词是人格。这牵扯到对知识的理解。我们过去往往以为阅读就约等于学习，其实不是。阅读是跟书学，但是我的体会是，跟人学效率更高。 知识是啥？知识是一个极其复杂的信息网络，它的真实的存在场景是牛人的大脑里面，是翻江倒海不断在迭代。那为什么过去我们认为读书就是学习呢？没办法嘛。人类在那个时代是印刷文化时代，想保存和传递知识书本是那个时代最好的学习工具。但是现在不一样了，我们有机会重新回到人格这个学习对象。 就像我自己吧，每隔一段时间，我总有一些我佩服的读书人嘛，我就会问他，最近在读什么书啊？有什么漂亮的文章值得推荐呀？关于这个大家都在讨论的问题你有什么意见？拼命问这些人。为啥？因为这样学习的效率更高。牛人就是知识的载体啊，知识已经被他们像买菜一样买回来洗干净，已经切好了，已经搭配和融合好了，当然跟他们学更省时间。这是最好最好的减轻知识的总体负担的方案。这是第一个关键词。 2 概念第二个关键词我称之为叫概念。就是通过不断的搜集新概念来高效学习。比如说高中物理第一册，说白了不就是那些概念嘛，什么是力，什么是运动，牛顿的三大定律，万有引力定律，什么是做功，什么是动能，就这些东西啊。然后纲举目张，任何知识的碎片随便抓进来都能够安放到概念上。 为什么有这个原理？因为我们人类是一个超级模式化的动物嘛，世界本身非常复杂，它怎么能变成知识呢？就是沉淀为一个一个的概念。所以可见概念有多么的重要啊。为啥？因为知识太多了，你拿进来你往哪放呢？如果摊成一地，那都是脏东西啊。我以前讲过，什么叫脏啊？它不是说这个东西天然就脏，是放错位置才脏啊。一个米饭它搁在饭盒里那是干净的，搁在衣服上它就是脏嘛。 那怎么样让知识显得不脏呢？就是一定要有这个概念作为基础框架，所以在了解一本新学科的时候先去了解概念就变得特别重要。掌握知识本质上就是掌握概念，这是第二个关键词。 3 缝合那第三个关键词我称之为叫缝合。什么意思？就是拿针缝一针，把它的合起来。很多人都在感慨，说我读了这么多书，那些字就像流水一样从我脑子里飘过，读完之后，书一合上，啥也没记住，这咋办？你缺的就是这两个字，叫缝合。 知识是自己的事，是从自己的内心盛开的一朵花，它一定是由内而外长大，外在的知识从你眼前飘过，那就是你的，你必须缝一针才是你的。 那怎么缝合？很简单，表达一次。比如说我，我现在学知识，然后要做节目表达出来，然后它就是我的。 那你说我没有做脱口秀的能力呀，没关系，表达分很多种层次。比如说写一个读书笔记，它就是个表达啊，哎呀，你说那太累了，没关系，读书笔记可能就是你一句。我自己就有这样的习惯，很多人在网上看到一些文章，收藏，这文章特别好，这个收藏没有用，过了几天，你全忘了，你连收藏过它你都忘了。这个时候应该干什么？ 就写一句话。看完之后说，这个知识我觉得哪儿很有趣，这就叫缝合，这就叫读书笔记，这就和你原来的知识体系长在一起了。这个知识即使将来你全部忘了，没关系，你知道那儿有，你将来可以去查。现在资讯这么发达，互联网这么发达，什么东西都可以去查，但是知道什么东西在哪，这才是你自己的知识。 4 碎片那第四个关键词，我认为是碎片。这个争议就比较大了，很多人都反对呀，说学习嘛就应该体系化、系统化的学嘛，你碎片化学习，最后一地鸡毛，什么也学不着，也搭建不起巍峨的知识大厦。我不是说系统化学习不好，而是它不现实嘛。我们每个人的时间都在被剧烈的碎片化，我们每个人手里拿着一大堆碎片时间怎么办？不用于学习，难道用于打游戏才对吗？所以碎片化时间是一个基本事实，我们这一代人必须要练成一个本事，就是利用碎片化时间拿到实实在在的知识，我们必须这样做好不好啊。 站在真实的学习场景和站在学习者这一头来看，碎片化学习没有那么糟糕了。我给大家一些理由啊。首先，知识的产生它就是碎片化掉的，那一些再聪明的大脑他一时一刻也只能产生一个念头，一个假设，一个结论嘛，然后可能当论文就发表出来了，这就是知识真实的产生场景。它什么时候变成体系化？被验证之后过了很久，有人用一个理论体系把它总结出来，这已经是陈旧的知识。我们是终身学习者，任何新出来的假说即使没有被验证，了解一下有什么不好？它就是碎片化掉的。 还有一方面，就是如果站在学习者的角度来看，它碎片化是一个最终的结果啊，它一直就是如此啊。比如说你去读一本书，学一个学期的课，最终留下来的是啥？那不就是一些碎片化的印象吗？几个动人的场景，几个金句，几个精辟的结论，读完一本书能够留下这些东西已经是上上大吉了，你没有白读啊，上课也是一样。如果学习的结果就是碎片化，那碎片化学习有什么问题。你看，美国的社会活动家也是政治家富兰克林，我们以前讲过，他说过一句很著名的话，说我一生的知识积累的来源就是这样的，说我在查找一方面资料的同时意外地看到了另外的资料，这就是我的学习呀。你看，这不就是碎片化的学习嘛。这是第四点。 5 目标 那还有第五点，这就更重要了，这一点弄通了，前面四点你才能融会贯通，这一点我称之为叫目标。 我活了四十多年，我现在观察，人间就有两种人。第一种人他的世界里是三个词，叫立场、感受和意见。那第二种人他的世界里也是三个词叫目标、方法和行动。 我四十岁开始创业，其实就为完成一件事，把我的思维方式从第一种，就是立场、感受和意见切换到第二种，就是目标、方法和行动。为什么？这也跟学习有关。因为立场、意见和感受，我可以装一脑子，各种各样的知识和价值观在我脑子里它是打架的，我不知道哪个对哪个错，一会儿觉得这个对，一会儿觉得那个对。 就像我最近在录制《奇葩说》的节目，我发现场上的观众随着辩论赛的展开，双方的拉锯是非常剧烈的，他们一会儿觉得这个对，一会儿又觉得那个对。为什么？因为世界是剧烈分层的，任何一个选择都有无穷的层次，随着场上辩论者的那个不断的挖掘层次，观众的意见就跟着两头跑。对，意见是一个特别不确定的东西，知识在脑子里是散黄的，是在那儿晃来晃去的。可是一旦切换到第二种人生，就是只有目标、方法和行动的时候，一切就被整合起来了，这就是我要创业的根本原因。 总结总结一下刚才我们讲的所有，我们这一代人有知识焦虑，没有办法，知识总量越来越大，负担越来越沉重，我们的时间越来越碎片。怎么办？原来传统的解决方案对于我们这一代人不能完全适用，所以我提出来的5个关键词。第一，就是跟着人学，而不是跟着书本学，先降低我们的知识负担，它帮助我们筛选和归纳。那第二就是概念，通过掌握一个一个的新概念，搭建起我们的知识框架，再进来新的信息，我们知道把它放在哪儿。那第三缝合，信息走来过去，我们不见得都记得住，只有我们通过表达一次，无论是像我这样转述，还是写一则极其简短的读书笔记，在自己的生命和知识树当中把它缝合进来，即使这些信息将来我们忘光了，我们也知道到哪里去找它。那第四，就是碎片，这是我们提升学习效率，在这个时代几乎是唯一的法门。当然最重要的是目标，只有目标明确，不断往前拱，我们才能把知识落实为我们行动的成果。这就是我学习的基本方法。 本文源自：《得到》订阅专栏“罗辑思维”讲述：罗振宇","categories":[],"tags":[{"name":"成长","slug":"成长","permalink":"http://yoursite.com/tags/成长/"}]},{"title":"vue开发者必装的Atom插件","slug":"vue开发者必装的atom插件","date":"2017-03-07T07:05:10.000Z","updated":"2017-03-09T05:36:25.000Z","comments":true,"path":"2017/03/07/vue开发者必装的atom插件/","link":"","permalink":"http://yoursite.com/2017/03/07/vue开发者必装的atom插件/","excerpt":"","text":"之前一直用webstrom，在没有遇到Atom之前，总觉得JetBrains系列的IDE工具是世界最好的，也觉得JetBrains是世界上最懂开发者的公司，直到我遇到了Atom，于是顿时对Atom产生了好感，用了几下，便爱上了它无法自拔，后来有同事陆续推荐了VScode等其他工具，也没有改变我对Atom的坚持。 工作中，我是一名主要使用vue的前端开发者，也发现了几款不错的插件，我觉得这几款是屌丝程序员必备的了！ File-icons：给你的文件图标润色一下 这个插件，是必须要装的，没有它，看代码是煎熬，有了它，就好多啦！ atom-clock:给状态栏添加时钟等状态信息装上它，在Atom的右下角会出现一些你当前操作的状态信息，比如时间，git分支等等，有用。 pigments:文件内色值高亮 👇下面这个web开发者必备有没有… vue相关 language-vue:支持vue语法高亮 vue-autocomplete:vue语法自动补全 vue-element-ui-snippets：基于vue样式框架element的插件 vue相关的三个插件，配合着File-icons,开发已经很爽了，但是总觉得好像还是少点什么？？？ activate-power-mode：boom 这个厉害了下面这个是纯屌丝必备… 以后码代码不但是享受，还带着节奏… 终于找到你，再来一波boom………..","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"javascript安全类型监测","slug":"javascript安全类型监测","date":"2017-02-13T08:41:27.000Z","updated":"2017-03-06T07:43:38.000Z","comments":true,"path":"2017/02/13/javascript安全类型监测/","link":"","permalink":"http://yoursite.com/2017/02/13/javascript安全类型监测/","excerpt":"","text":"数据类型检测ECMAScript有五种简单的数据类型，分别为Undefined、Null、String、Number、Boolean，还有一个复杂的数据类型Object。ECMAScript的语言的动态性意味着我们可以使用以上6种数据类型表示任何数据。 因为数据类型是松散的，所以我们需要一些手段来准确的检测给定变量的数据类型。 typeoftepeof是检测基本数据类型的好手，他有六种检测结果，分别是Undefined、Object、Function、String、Number、Boolean,所以它是判断一个变量是：未定义值、对象、函数、字符串、数值、布尔值的最佳工具。123456789typeof undefined //&quot;undefined&quot;typeof &#123;&#125; //&quot;object&quot;typeof function()&#123;&#125; //&quot;function&quot;typeof &apos;&apos; //&quot;string&quot;typeof 1 //&quot;number&quot;typeof true //&quot;boolean&quot;typeof null //&quot;object&quot;typeof [] //&quot;object&quot; 从上面可以看出typeof虽然是检测基本数据类型的好手，但是在检测引用类型的数据时就力不从心了，下面会提到如何检测引用数据类型。另外还有个问题值得思考： 为什么null的检测类型是Object？ 看书中对null的描述： The value null represents the intentional absence of any objectvalue 首先，null是一个原始值。关于 typeof null //&quot;object&quot; 的结果，从一开始出现JavaScript就是这样的。 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是0。由于 null 代表的是空指针(大多数平台下值为0x00)，因此，null的类型标签也成为了0，typeof null就错误的返回了”object”.(referenc) 据说该问题在ECMAScript 6中提出typeof null === &#39;null&#39;的讨论 (该提议已被否决)。 安全类型检测javascript内置的类型检测机制并非完全可靠。比如typeof操作符，由于一些无法预知的行为，会得到不靠谱的结果。instanceof存在于多个作用域的情况，通过下面的方式检测数组： var isArray = value instanceof Array 以上代码若返回true，value必须是一个数组，而且必须与Array构造函数处于同一个作用域中。如果value是别的框架定义的数组，以上的代码又可能会返回false。 如何解决上述问题上述解决的办法都一样，在任何值上调用Object原生的toString方法时，都会返回一个类似于［object NativeConstructorName］格式的字符串，比如： Object.prototype.toString.call([&#39;&#39;]) //&quot;[object Array]&quot; 由于原生数组的构造函数名和全局作用域无关，因此使用toString就能返回一致的值。利用这点可以创建以下函数： 123456789101112131415function isArray(value) &#123; return Object.prototype.toString.call(value) == &quot;[object Array]&quot;;&#125;function isFunction(value) &#123; return Object.prototype.toString.call(value) == &quot;[object Function]&quot;;&#125;function isRegExp(value) &#123; return Object.prototype.toString.call(value) == &quot;[object RegExp]&quot;;&#125;function isNativeJSON(value) &#123; return window.JSON&amp;&amp;Object.prototype.toString.call(value) == &quot;[object JSON]&quot;;&#125; ⚠需要注意的一点是，Object.prototype.toString()本身也会被修改，本文讨论的仅仅是该方法未被修改的情况下。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"解决 git bash 不重复输入账号密码","slug":"git-not-repeat-put-password","date":"2016-10-19T05:06:40.000Z","updated":"2017-03-11T14:43:23.000Z","comments":true,"path":"2016/10/19/git-not-repeat-put-password/","link":"","permalink":"http://yoursite.com/2016/10/19/git-not-repeat-put-password/","excerpt":"","text":"1 寻找并编辑 .git-credentials 文件在%HOME%目录中，一般为C:\\users\\Administrator，也可以是你自己创建的系统用户名目录，反正都在C:\\users\\中。文件名为.git-credentials,由于在Window中不允许直接创建以”.”开头的文件，所以需要借助git bash进行，打开git bash客户端，进行%HOME%目录，然后用touch创建文件 .git-credentials, 用vim编辑此文件，输入内容格式： 12345touch .git-credentialsvim .git-credentialshttps://&#123;username&#125;:&#123;password&#125;@github.com 2 添加Git Config 内容进入git bash终端， 输入如下命令： git config --global credential.helper store 执行完后查看%HOME%目录下的.gitconfig文件，会多了一项： 12[credential]helper = store 重新开启git bash会发现git push时不用再输入用户名和密码","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"互联网时代-值得思考的话","slug":"internet-collect","date":"2016-09-26T14:54:01.000Z","updated":"2017-03-11T14:42:53.000Z","comments":true,"path":"2016/09/26/internet-collect/","link":"","permalink":"http://yoursite.com/2016/09/26/internet-collect/","excerpt":"","text":"人类社会从来不缺少善良的愿望，只不过在过去漫长的岁月，难以因为具体的动机而汇聚。 当信息突破了时间和空间的阻隔，它所携带的信息的能量，就能够具有这样一种非常神奇的力量，可以凝聚共识啊，可以焕发情感啊，能够形成一种强大的社会动员力量。 网络技术导致沟通出现彻底的转变，每个人可以与谁沟通也有所变化。因此，沟通的转变和对网络的需求共同创造了一种新的社会结构。 互联网产生了互相感召的力量。将无数同样拥有关怀之情的人形成了强大的自组织力量，是一种充分可持续的力量。人类以一种全新的组织、连接方式化合出无数钻石般的群体行动。 群体具备个人所不具备的性质，而究其原因，则在于我们组织个体的方式，使得群体优于个体。想一想碳元素，把碳原子以某种方式连接，你将得到铅笔中软而黑的石墨。如果以另一种方式连接碳原子，则将得到坚硬而清澈的钻石。 这种汇聚了的善的能量，是新时代赋予整个人类的一份财富。所有的信息都能以我们看不见的面貌，以我们经验不能体验的速度，创造出前所未有的时代动力。 我们都有梦想、希望和想象。然而没有人教我们如何做梦，我们只是行动起来，但是如果没有教育，凭梦想这些女孩只能走这么远。 埃文斯萌生这个看似遥不可及的梦想，不是因为他出身、教育、钱财、智商，而是因为他出生在互联网时代。 在过去的历史上，人类以金字塔的形式把所有人的善意汇聚起来，形成特定的组织实施救助。互联网时代，人们可以以地球为平台，以人类为范围，每一个人都有可能获得与过去世界级慈善组织相媲美的道德力量。 只要有共同意愿，无限的碎片就瞬间产生效能，产生让整个人类自我敬仰的力量，人类互相鼓舞创造美好人生的念头，在互联网时代，变得像投下一枚硬币那么简单。 人类社会的公共组织在它运行过程中，有自身繁育的充沛动力，各个层级不光会追逐层级的独特利益，而且还会膨胀层级本身。—帕金森定律。 现在淡水湖中的三文鱼是由内务部负责管理的，但是如果鱼游进了海水中，就归商务部管了；要是这些鱼被熏制好了，事情恐怕就更复杂了。 在曾经的漫长岁月，人类社会结构的层层叠叠中，大量的信息既在损耗也被扭曲，互联网穿透了社会坚厚的岩层，使所有相邻或相距遥远的层级，彼此面对。身份、财富、地域，都不再是传播的权利或枷锁。每个人的传播能量已经穿破层级壁垒，开始顶层和底层的直接交流。 在水平网络中，人们可以相连、分离、相聚、分散，整个社会和政治组织的形式都在变化。我们曾经谈论过后工业社会，“后”意味着我们并不明白。 人类社会一经诞生，就有金字塔一般由层级堆垒起来的醒目中心。在互联网时代，金字塔塔顶上的那块石头，已经可以轻松触摸它基座最深处的那一粒岩石，无论在哪一个位置上一块石头，都拥有了新时代的上帝之手。 微信，五亿；新浪微博，五亿；QQ，八亿；脸谱，十二亿。这些惊人的不断成长的数字田野里，瞬间崛起的不是数字，而是数字背后的声音和人 互联网实际上是把人与人联结在一起了，另外一个是把人与信息联结在一起了。因为这两个联结实际上大大提升了我们讲的那个信息的一个传播的效率，创造了效率。 工业时代，通过组织的方式和公约的形式，形成公共意志。公约形式就意味着注定有一小部分社会成员被公共意志所忽略，他们捍卫被忽略的权利的组织意愿，始终存在着。 不断被忽略的力量组织起来，构造成了公共组织形态和社会自组织形态的有机体。人们就生活在这样一个组织常态中。互联网时代，传统常态的经验和结构已不能容纳互联网组织起来的社会能量。信息传播技术，创造了绝对的少数也不能被忽略的可能。每一个声音都面对着世界，每一滴水珠都等同于大海。 人人都有自己的声音，即使你是矮穷挫，委身于地下室，香蕉皮等垃圾盖满地板，你却和那些坐在游泳池里的高富帅有着同样的声音。只要你能上得了网。 互联网让那些以前没有发言权的人发声，但是你怎么知道，你怎么知道那些声音是仇恨的声音还是团结协作的声音，是敌对的声音还是进步的声音？所以不能简单地由科技联想到价值。 曾经孕育了互联网的教育制度，受到网络本身组织能量的冲击，整个世界会变成一个没有边界的学校吗？理论上，一门课程，将来在世界上只需要一个老师，一等于无限，地球上的每个人都享有平等的受教育的权利。那将是矗立了四千五百年的金字塔，能够目睹的这个星球上最动人的一幕。每一个人都可以站在大地，分享这个世界，并触摸天空。 当人类的精神成长过程被重组，与奇观相伴而来的是所有拥有母校的人们是否都可能产生让我们精神紧张的感念。那个因为远离世俗功利，因此总是储存着我们美好回忆的地方；那个因为身在成长中的朦胧，因此总是友情似水又不由分说地规定了我们生命的节律的地方；那些曾经属于每一个人幼儿园里的青梅竹马，属于每个人小学、中学的两小无猜，属于每一个人大学校园里林荫树下的恋情又将会在哪里？","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/tags/互联网/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"}]},{"title":"回顾老男孩","slug":"dream","date":"2016-09-22T16:55:17.000Z","updated":"2017-03-06T07:55:04.000Z","comments":true,"path":"2016/09/23/dream/","link":"","permalink":"http://yoursite.com/2016/09/23/dream/","excerpt":"","text":"老男孩是在高二的时候语文老师在全班同学面前播放的一部微电影，当时看的感觉更多是有点意思，没有太多的伤感和感动。今天是大学毕业的第一年，恍然已经六年过去了，今天晚上突然有点怀旧，再次回顾这部微电影，就差稀里糊涂的哭出来了，整个心都酥了，都软了。现在想来，QQ空间的说说有一年多没有更新了，我也从曾经的个性张扬，调皮的学生转变为了一名职业人士，开始了自己的职业生活。曾经的老同学不知道会在什么时候突然联系一下，也都有各自的生活了吧，相见不如怀念，让自己更好是现在的最重要的事吧。审视一下自己的青春，觉得自己的幸运的，犯过无数的错误却总是有改正的机会；经历了老师眼中好学生与坏学生的模样；惹出过很多争议；也曾经失去过自己，又找回了自己；曾经束缚过自己，也在后来找回了自由；身边的朋友有学霸也有学渣；我也算一朵奇葩吧，这一路走来，幸运，感恩！我现在也是在从小男孩转变为老男孩的路上，怀揣着自己的梦想，在追求自我实现的路上；生活确实是一把无情的刻刀，改变了我的模样，不变的是和经典一样的梦想。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"互联网时代-再构观后感","slug":"internet","date":"2016-09-17T14:49:00.000Z","updated":"2017-03-11T14:44:46.000Z","comments":true,"path":"2016/09/17/internet/","link":"","permalink":"http://yoursite.com/2016/09/17/internet/","excerpt":"","text":"每一次看过视频后都很有启发，这一次也不例外，互联网再构这部视频用了四十分钟全面而详细的向我们阐述了再构的一前一后，怎么理解再构，顾名思义，再构就是再一次构建，是指互联网时代的到来，其影响不仅仅是局限于科技，局限于技术，局限于社会表面，其对我们的生活的影响是彻底的，巨大的，从菲特台风的案例，黄灯的故事，李明博事件，可汗学院的建立，奥巴马选举的成功等实例都反映了互联网影响的是人与人之间，人与权利之间，人与社会之间，人与人周围的一切关系。就像视频中说的那样，一就是无限，每一个声音都面对着世界，每一滴水珠都等同于大海。 ，这要求我们要不断的学习，要与时俱进，顺势而为，在互联网时代的浪潮里构建的新的社会体系中更好的存活。","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://yoursite.com/tags/互联网/"},{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"}]},{"title":"javascript高级编程-Array引用类型用法总结","slug":"javascriptArray","date":"2016-09-16T16:56:47.000Z","updated":"2017-03-24T12:41:54.000Z","comments":true,"path":"2016/09/17/javascriptArray/","link":"","permalink":"http://yoursite.com/2016/09/17/javascriptArray/","excerpt":"","text":"引用类型-Array类型引用类型是一种数据结构，用于将数据和功能联系起来。 创建对象的方式： 1.new操作符 var array = new Array() 2.字面量表示法创建 var array = [] Array1.检测数组:检测数组是基本类型还是引用类型 2.转换方法:将数组转换成字符串或数组对象 3.栈方法:后进先出的操作数组的方法 4.队列方法:先进先出的操作数组的方法 5.操作方法:数组的拼接、截取、插入、删除、替换 6.位置方法:查找数组项、返回索引值 7.迭代方法:对每个数组项进行操作的方法 8.缩小方法:操作数组的每一项，构建最终的返回值 1 检测数组 检测数组的方法；instanceof操作符的问题是当开发环境引入多个框架存在多个全局环境的时候，会出现不同的Array构造函数，进而出现不同的结果。Array.isArray()这个方法很好的解决了这个问题。 arrName instanceof Array 12var array = [1,2,3]console.log(array instanceof Array) // true Array.isArray(arrName) 1console.log(Array.isArray(array)) // true 2 转换方法 toString()：返回以逗号分隔拼接而成的字符串 valueOf()：返回对象 toLocaleString()：区别很小，如果是数组调用这个方法，那么数组的每一项都会调用这个方法 alert(value) == alert(value.toString()) 123456789var array = [1,2,3]var arrayToString = array.toString()var arrayValueOf = array.valueOf()var arrayToLocalString = array.toLocaleString()console.log(arrayToString) // 1,2,3console.log(arrayValueOf) // [1, 2, 3]console.log(arrayToLocalString) // 1,2,3 3 栈方法 (LIFO:last in first out) ES数组类似于数据结构的方法栈是一种限制插入和删除项的数据结构 push()：接收任意数量的参数添加至数组尾部，返回数组长度值 pop():从数组末尾移除最后一项，减少数组的length值，返回该数组被删除的最后一项 4 队列方法 (FIFO:first in first out) 结合push()和shift()方法可以实现像队列一样使用数组使用unshift()和pop()可以从相反的方向模拟队列 shift()移除并返回该数组的第一项； unshift()从数组前端添加任意个参数，并返回新数组的长度 5 操作方法 concat()复制原数组连接新数组形成新副本； 123var arr1 = [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;]var arr2 = [&apos;h&apos;,&apos;u&apos;,&apos;o&apos;]document.write(arr1.concat(arr2)) //q,w,e,h,u,o slice() 有一个参数时，复制参数为起始位置到末尾的副本；有两个参数时，复制两个数字中间部分的数组项；如果参数是负数，复制用数组的长度加上负数值得到的两个参数之间的数组项； 1234var arr3 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]console.log(arr3.slice(1)) // e,l,l,oconsole.log(arr3.slice(-4)) // e,l,l,oarr3.slice(-4) === arr3.slice(1) // true splice() 三个参数:分别对应起始位置，删除项的个数，替换项;通过对这三个参数的合理运用可以实现删除、插入、替换等操作。 1234567891011121314// 从第一项开始删除两项var splice_arr1 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]console.log(splice_arr1.splice(1,2)) // 返回的是被删除的项组成的数组[&quot;e&quot;, &quot;l&quot;]// 从第二项后插入三项oldvar splice_arr2 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]var removed = splice_arr2.splice(2,0,&quot;K&quot;,&quot;K&quot;)console.log(splice_arr2)//[&quot;h&quot;, &quot;e&quot;, &quot;K&quot;, &quot;K&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] console.log(removed) // 返回的是一个空数组// 替换var removed = splice_arr3.splice(2,2,&quot;P&quot;,&quot;P&quot;)console.log(splice_arr3)//[&quot;h&quot;, &quot;e&quot;, &quot;P&quot;, &quot;P&quot;, &quot;o&quot;]console.log(removed) // 返回的是被替换的值[&quot;l&quot;, &quot;l&quot;] 6 位置方法 返回索引值 indexOf() 从前往后找 lastIndexOf() 从后往前找 1234567891011// indexOf() 从前往后找// lastIndexOf() 从后往前找var index_arr = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]var indexOf_arr = index_arr.indexOf(&apos;l&apos;)console.log(&apos;原数组:&apos;,index_arr) // 原数组不变console.log(&apos;返回值:&apos;,indexOf_arr) // 返回值是第一个查到位置的索引值2var index_arr2 = [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]var indexOf_arr2 = index_arr2.lastIndexOf(&apos;l&apos;)console.log(&apos;原数组:&apos;,index_arr2) // 原数组不变console.log(&apos;返回值:&apos;,indexOf_arr2) // 返回值是第一个查到位置的索引值3 7 迭代方法 接收两个参数，一个是函数，另一个是运行该函数的作用域对象。 第一个参数函数接收三个参数 数组项的值 item，值的位置 idnex ，数组本身 array every() // 都是返回true则返回true 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var everyArr = numbers.every(function(it, index ,arr)&#123; if(it&gt;9)&#123; return true &#125;&#125;)console.log(everyArr) // false some() // 有一个返回true，则返回true 1234var someArr = numbers.some(function(it, index ,arr)&#123; return (it &gt; 9)&#125;)console.log(someArr) // true forEach() // 没有返回值 123456var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var forEachArr = numbers.forEach(function(it, index ,arr)&#123; var it = it*100 console.log(it)&#125;) // 无返回值 filter() // 返回该函数会返回true的项组成的数组，用于过滤 1234567var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var filterArr = numbers.filter(function(it, index ,arr)&#123; if(it&gt;10)&#123; return it &#125;&#125;)console.log(filterArr) // [65, 33, 21, 23],返回返回值组成的新数组 map()//返回每个函数的返回值 12345678var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var mapArray = numbers.map(function(it, index ,arr)&#123; var it = it*100 return it&#125;)console.log(mapArray) // [100, 200, 300, 400, 500, 600, 700, 800, 900, 0, 900, 800, 700, 6500, 500, 400, 3300, 2100, 100, 100, 2300, 300, 400],返回返回值组成的新数组 8 缩小方法 reduce() 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var allArray = numbers.reduce(function(prev,cur,index,arr)&#123; return (prev+cur)&#125;)console.log(allArray) // 229 reduceRight() 12345var numbers = [1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4]var allArrayRight = numbers.reduceRight(function(prev,cur,index,arr)&#123; return (prev+cur)&#125;)console.log(allArrayRight) // 229 总结：经过这次总结和练习，觉得自己在以后再次遇到操作数组应该不会再感到害怕了；自己的工作中用的最多的是split()这个字符串截取的操作方法，这个方法虽然是字符串的方法但是很好用。这种总结方式，效果挺好，就是效率稍微低一点，这点咋解决啊，是个问题。。。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"我应该开始写博客了","slug":"why","date":"2016-09-06T16:02:26.000Z","updated":"2017-03-11T14:43:15.000Z","comments":true,"path":"2016/09/07/why/","link":"","permalink":"http://yoursite.com/2016/09/07/why/","excerpt":"","text":"记得在大四毕业的前夕，我在知乎上提了一个问题“为什么每次想写东西的时候都无从下笔？”。总结知友的回答，再结合自己的感受，试图剖开内心的世界，认真的拷问自己最本质的想法，自问为什么写不出来，也许六耳的回答是自己的那个样子，之所以写不出来，不是真的写不出来，而是害怕写不出好的内容，害怕比较，害怕没人看，害怕写出来的东西被别人讥讽，被别人指指点点，再加上自己是一个好面的人，在那么多外在情绪的干扰下，写不出来是很正常的了。 大四毕业了，现在的我已经正式走上了谋生的道路，正式结束了十几年的学生身份，体会到了谋生的艰辛，生活的压力，身上的责任感。自己意外的成为了一个前端开发者，自然而然的就想为自己搭建一个博客用于记录自己的生活，记录自己的技术积淀，分享自己的生活感悟，分享自己的技术，分享自己的想法，因为互联网时代的本质就是分享，我也鼓励自己要克服害怕写东西，从这种消极情绪中积极的走出来，人生不也就是因为有了奋斗和与自己搏击的过程而显得刺激而有意义吗？ 我还希望通过在写博客的过程中，思考自己的生活，尽量站在客观的角度重新认识自己，进一步了解自己。我也搜索了相关为什么要写博客的文章，如“为什么你要写博客？”借鉴他们的想法之后愈加觉得自己开始做出这个选择的正确性，我要求自己要写下去，我想让尽量多的人知道，一个叫程康建小伙子曾经来过这个世界，这个世界有他的足迹。然后当我有朝一日老的时候，如果能够阅读自己年轻时候的心态，何尝不是一件幸福的事情。 写吧！再次告诉自己！写到天荒地老海枯石烂…add oil！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://yoursite.com/tags/感悟/"}]},{"title":"新地盘 新生活 新开始.","slug":"start","date":"2016-09-03T16:19:47.000Z","updated":"2017-03-11T14:43:08.000Z","comments":true,"path":"2016/09/04/start/","link":"","permalink":"http://yoursite.com/2016/09/04/start/","excerpt":"","text":"通过hexo搭建的一个博客，虽然很简单，也是用了很长的时间，经过自己的双手敲出来的东西，可能简单了些，但是很有成就感。嗯，这是一个开始！add oil!","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"http://yoursite.com/tags/感悟/"}]}]}